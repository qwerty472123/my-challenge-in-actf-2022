From cd132114bb21845ce63199b6fe9a771d9b2459a8 Mon Sep 17 00:00:00 2001
From: qwerty472123 <4qwerty7@163.com>
Date: Tue, 21 Jun 2022 18:48:40 +0800
Subject: [PATCH] Add precompiled and marshal opcodes

---
 core/vm/analysis.go                           |    2 +-
 core/vm/contracts.go                          |  167 ++-
 core/vm/contracts_test.go                     |   60 +
 core/vm/opcodes.go                            |  156 +--
 crypto/bn256/bn256_fast.go                    |    7 +-
 crypto/bn256/bn256_slow.go                    |   24 -
 crypto/bn256/cloudflare/bn256.go              |  103 +-
 crypto/bn256/cloudflare/constants.go          |   18 +
 crypto/bn256/cloudflare/curve.go              |    7 +
 crypto/bn256/cloudflare/gfp.go                |  119 +-
 crypto/bn256/cloudflare/hash.go               |  102 ++
 crypto/bn256/cloudflare/hash_test.go          |   93 ++
 crypto/bn256/cloudflare/main_test.go          |    3 +-
 crypto/bn256/google/bn256.go                  |  460 --------
 crypto/bn256/google/bn256_test.go             |  311 -----
 crypto/bn256/google/constants.go              |   47 -
 crypto/bn256/google/curve.go                  |  286 -----
 crypto/bn256/google/example_test.go           |   43 -
 crypto/bn256/google/gfp12.go                  |  200 ----
 crypto/bn256/google/gfp2.go                   |  227 ----
 crypto/bn256/google/gfp6.go                   |  296 -----
 crypto/bn256/google/main_test.go              |   71 --
 crypto/bn256/google/optate.go                 |  397 -------
 crypto/bn256/google/twist.go                  |  263 -----
 crypto/edwards25519/doc.go                    |   22 +
 crypto/edwards25519/edwards25519.go           |  427 +++++++
 crypto/edwards25519/edwards25519_test.go      |  304 +++++
 .../edwards25519/field/_asm/fe_amd64_asm.go   |  294 +++++
 crypto/edwards25519/field/_asm/go.mod         |    5 +
 crypto/edwards25519/field/_asm/go.sum         |   31 +
 crypto/edwards25519/field/fe.go               |  416 +++++++
 crypto/edwards25519/field/fe_alias_test.go    |  126 ++
 crypto/edwards25519/field/fe_amd64.go         |   13 +
 crypto/edwards25519/field/fe_amd64.s          |  378 ++++++
 crypto/edwards25519/field/fe_amd64_noasm.go   |   11 +
 crypto/edwards25519/field/fe_arm64.go         |   15 +
 crypto/edwards25519/field/fe_arm64.s          |   42 +
 crypto/edwards25519/field/fe_arm64_noasm.go   |   11 +
 crypto/edwards25519/field/fe_bench_test.go    |   36 +
 crypto/edwards25519/field/fe_generic.go       |  264 +++++
 crypto/edwards25519/field/fe_test.go          |  558 +++++++++
 crypto/edwards25519/scalar.go                 | 1025 +++++++++++++++++
 crypto/edwards25519/scalar_alias_test.go      |   93 ++
 crypto/edwards25519/scalar_test.go            |  233 ++++
 crypto/edwards25519/scalarmult.go             |  214 ++++
 crypto/edwards25519/scalarmult_test.go        |  209 ++++
 crypto/edwards25519/tables.go                 |  129 +++
 crypto/edwards25519/tables_test.go            |  119 ++
 go.mod                                        |    1 +
 go.sum                                        |    2 +
 params/protocol_params.go                     |    7 +
 51 files changed, 5724 insertions(+), 2723 deletions(-)
 delete mode 100644 crypto/bn256/bn256_slow.go
 create mode 100644 crypto/bn256/cloudflare/hash.go
 create mode 100644 crypto/bn256/cloudflare/hash_test.go
 delete mode 100644 crypto/bn256/google/bn256.go
 delete mode 100644 crypto/bn256/google/bn256_test.go
 delete mode 100644 crypto/bn256/google/constants.go
 delete mode 100644 crypto/bn256/google/curve.go
 delete mode 100644 crypto/bn256/google/example_test.go
 delete mode 100644 crypto/bn256/google/gfp12.go
 delete mode 100644 crypto/bn256/google/gfp2.go
 delete mode 100644 crypto/bn256/google/gfp6.go
 delete mode 100644 crypto/bn256/google/main_test.go
 delete mode 100644 crypto/bn256/google/optate.go
 delete mode 100644 crypto/bn256/google/twist.go
 create mode 100644 crypto/edwards25519/doc.go
 create mode 100644 crypto/edwards25519/edwards25519.go
 create mode 100644 crypto/edwards25519/edwards25519_test.go
 create mode 100644 crypto/edwards25519/field/_asm/fe_amd64_asm.go
 create mode 100644 crypto/edwards25519/field/_asm/go.mod
 create mode 100644 crypto/edwards25519/field/_asm/go.sum
 create mode 100644 crypto/edwards25519/field/fe.go
 create mode 100644 crypto/edwards25519/field/fe_alias_test.go
 create mode 100644 crypto/edwards25519/field/fe_amd64.go
 create mode 100644 crypto/edwards25519/field/fe_amd64.s
 create mode 100644 crypto/edwards25519/field/fe_amd64_noasm.go
 create mode 100644 crypto/edwards25519/field/fe_arm64.go
 create mode 100644 crypto/edwards25519/field/fe_arm64.s
 create mode 100644 crypto/edwards25519/field/fe_arm64_noasm.go
 create mode 100644 crypto/edwards25519/field/fe_bench_test.go
 create mode 100644 crypto/edwards25519/field/fe_generic.go
 create mode 100644 crypto/edwards25519/field/fe_test.go
 create mode 100644 crypto/edwards25519/scalar.go
 create mode 100644 crypto/edwards25519/scalar_alias_test.go
 create mode 100644 crypto/edwards25519/scalar_test.go
 create mode 100644 crypto/edwards25519/scalarmult.go
 create mode 100644 crypto/edwards25519/scalarmult_test.go
 create mode 100644 crypto/edwards25519/tables.go
 create mode 100644 crypto/edwards25519/tables_test.go

diff --git a/core/vm/analysis.go b/core/vm/analysis.go
index 4aa8cfe70..98d76f038 100644
--- a/core/vm/analysis.go
+++ b/core/vm/analysis.go
@@ -76,7 +76,7 @@ func codeBitmapInternal(code, bits bitvec) bitvec {
 	for pc := uint64(0); pc < uint64(len(code)); {
 		op := OpCode(code[pc])
 		pc++
-		if int8(op) < int8(PUSH1) { // If not PUSH (the int8(op) > int(PUSH32) is always false).
+		if (uint8(op) < uint8(PUSH1)) || (uint8(op) > uint8(PUSH32)) { // If not PUSH (the int8(op) > int(PUSH32) is always false).
 			continue
 		}
 		numbits := op - PUSH1 + 1
diff --git a/core/vm/contracts.go b/core/vm/contracts.go
index 1b832b638..1f4af8467 100644
--- a/core/vm/contracts.go
+++ b/core/vm/contracts.go
@@ -16,10 +16,14 @@
 
 package vm
 
+// "github.com/ethereum/go-ethereum/crypto/edwards25519" is a copy of "crypto/ed25519/internal/edwards25519"
+
 import (
 	"crypto/sha256"
 	"encoding/binary"
 	"errors"
+	"github.com/Scratch-net/vxeddsa/extra25519"
+	"github.com/ethereum/go-ethereum/crypto/edwards25519"
 	"math/big"
 
 	"github.com/ethereum/go-ethereum/common"
@@ -79,15 +83,21 @@ var PrecompiledContractsIstanbul = map[common.Address]PrecompiledContract{
 // PrecompiledContractsBerlin contains the default set of pre-compiled Ethereum
 // contracts used in the Berlin release.
 var PrecompiledContractsBerlin = map[common.Address]PrecompiledContract{
-	common.BytesToAddress([]byte{1}): &ecrecover{},
-	common.BytesToAddress([]byte{2}): &sha256hash{},
-	common.BytesToAddress([]byte{3}): &ripemd160hash{},
-	common.BytesToAddress([]byte{4}): &dataCopy{},
-	common.BytesToAddress([]byte{5}): &bigModExp{eip2565: true},
-	common.BytesToAddress([]byte{6}): &bn256AddIstanbul{},
-	common.BytesToAddress([]byte{7}): &bn256ScalarMulIstanbul{},
-	common.BytesToAddress([]byte{8}): &bn256PairingIstanbul{},
-	common.BytesToAddress([]byte{9}): &blake2F{},
+	common.BytesToAddress([]byte{1}):  &ecrecover{},
+	common.BytesToAddress([]byte{2}):  &sha256hash{},
+	common.BytesToAddress([]byte{3}):  &ripemd160hash{},
+	common.BytesToAddress([]byte{4}):  &dataCopy{},
+	common.BytesToAddress([]byte{5}):  &bigModExp{eip2565: true},
+	common.BytesToAddress([]byte{6}):  &bn256AddIstanbul{},
+	common.BytesToAddress([]byte{7}):  &bn256ScalarMulIstanbul{},
+	common.BytesToAddress([]byte{8}):  &bn256PairingIstanbul{},
+	common.BytesToAddress([]byte{9}):  &blake2F{},
+	common.BytesToAddress([]byte{21}): &ed25519Add{},
+	common.BytesToAddress([]byte{22}): &ed25519ScalarMul{},
+	common.BytesToAddress([]byte{23}): &ed25519HashToPoint{},
+	common.BytesToAddress([]byte{24}): &bn256Add{},
+	common.BytesToAddress([]byte{25}): &bn256ScalarMul{},
+	common.BytesToAddress([]byte{26}): &bn256HashToPoint{},
 }
 
 // PrecompiledContractsBLS contains the set of pre-compiled Ethereum
@@ -1041,3 +1051,142 @@ func (c *bls12381MapG2) Run(input []byte) ([]byte, error) {
 	// Encode the G2 point to 256 bytes
 	return g.EncodePoint(r), nil
 }
+
+// newCurvePointEd25519 unmarshals a binary blob into a bn256 elliptic curve point,
+// returning it, or an error if the point is invalid.
+func newCurvePointEd25519(blob []byte) (*edwards25519.Point, error) {
+	p, err := (&edwards25519.Point{}).SetBytes(blob)
+	if err != nil {
+		return nil, err
+	}
+	return p, nil
+}
+
+// ed25519Add implements a native elliptic curve point addition on ed25519 curve.
+type ed25519Add struct{}
+
+// RequiredGas returns the gas required to execute the pre-compiled contract.
+func (c *ed25519Add) RequiredGas(input []byte) uint64 {
+	return params.Ed25519AddGas
+}
+
+func (c *ed25519Add) Run(input []byte) ([]byte, error) {
+	x, err := newCurvePointEd25519(getData(input, 0, 32))
+	if err != nil {
+		return nil, err
+	}
+	y, err := newCurvePointEd25519(getData(input, 32, 32))
+	if err != nil {
+		return nil, err
+	}
+	res := (&edwards25519.Point{}).Add(x, y)
+	return res.Bytes(), nil
+}
+
+func reverseBytes(src []byte) []byte {
+	buf := make([]byte, len(src))
+	copy(buf, src)
+	for from, to := 0, len(buf)-1; from < to; from, to = from+1, to-1 {
+		buf[from], buf[to] = buf[to], buf[from]
+	}
+	return buf
+}
+
+// ed25519ScalarMul implements a native elliptic curve scalar
+// multiplication conforming to Istanbul consensus rules.
+type ed25519ScalarMul struct{}
+
+// RequiredGas returns the gas required to execute the pre-compiled contract.
+func (c *ed25519ScalarMul) RequiredGas(input []byte) uint64 {
+	return params.Ed25519ScalarMulGas
+}
+
+func (c *ed25519ScalarMul) Run(input []byte) ([]byte, error) {
+	p, err := newCurvePointEd25519(getData(input, 0, 32))
+	if err != nil {
+		return nil, err
+	}
+	x, err := edwards25519.NewScalar().SetCanonicalBytes(reverseBytes(getData(input, 32, 32)))
+	if err != nil {
+		return nil, err
+	}
+	res := (&edwards25519.Point{}).ScalarMult(x, p)
+	return res.Bytes(), nil
+}
+
+// ed25519HashToPoint implements hash-to-point function on ed25519 curve
+type ed25519HashToPoint struct{}
+
+// RequiredGas returns the gas required to execute the pre-compiled contract.
+func (c *ed25519HashToPoint) RequiredGas(input []byte) uint64 {
+	return uint64(len(input)+31)/32*params.Ed25519HashToPointPerWordGas + params.Ed25519HashToPointBaseGas
+}
+
+func (c *ed25519HashToPoint) Run(input []byte) ([]byte, error) {
+	ret := new([32]byte)
+	extra25519.HashToPoint(input[:]).ToBytes(ret)
+	return (*ret)[:], nil
+}
+
+// newCurvePointBn256 unmarshals a binary blob into a bn256 elliptic curve point,
+// returning it, or an error if the point is invalid.
+func newCurvePointBn256(blob []byte) (*bn256.G1, error) {
+	p := new(bn256.G1)
+	if _, err := p.UnmarshalCompressed(blob); err != nil {
+		return nil, err
+	}
+	return p, nil
+}
+
+// bn256Add implements a native elliptic curve point addition on ed25519 curve.
+type bn256Add struct{}
+
+// RequiredGas returns the gas required to execute the pre-compiled contract.
+func (c *bn256Add) RequiredGas(input []byte) uint64 {
+	return params.Bn256AddGasIstanbul
+}
+
+func (c *bn256Add) Run(input []byte) ([]byte, error) {
+	x, err := newCurvePointBn256(getData(input, 0, 32))
+	if err != nil {
+		return nil, err
+	}
+	y, err := newCurvePointBn256(getData(input, 32, 32))
+	if err != nil {
+		return nil, err
+	}
+	res := new(bn256.G1)
+	res.Add(x, y)
+	return res.MarshalCompressed(), nil
+}
+
+// bn256ScalarMul implements a native elliptic curve scalar
+// multiplication conforming to Istanbul consensus rules.
+type bn256ScalarMul struct{}
+
+// RequiredGas returns the gas required to execute the pre-compiled contract.
+func (c *bn256ScalarMul) RequiredGas(input []byte) uint64 {
+	return params.Bn256ScalarMulGasIstanbul
+}
+
+func (c *bn256ScalarMul) Run(input []byte) ([]byte, error) {
+	p, err := newCurvePointBn256(getData(input, 0, 32))
+	if err != nil {
+		return nil, err
+	}
+	res := new(bn256.G1)
+	res.ScalarMult(p, new(big.Int).SetBytes(getData(input, 32, 32)))
+	return res.MarshalCompressed(), nil
+}
+
+// ed25519HashToPoint implements hash-to-point function on ed25519 curve
+type bn256HashToPoint struct{}
+
+// RequiredGas returns the gas required to execute the pre-compiled contract.
+func (c *bn256HashToPoint) RequiredGas(input []byte) uint64 {
+	return uint64(len(input)+31)/32*params.Bn256HashToPointPerWordGas + params.Bn256HashToPointBaseGas
+}
+
+func (c *bn256HashToPoint) Run(input []byte) ([]byte, error) {
+	return bn256.HashG1(input[:]).MarshalCompressed(), nil
+}
diff --git a/core/vm/contracts_test.go b/core/vm/contracts_test.go
index b22d999e6..688accfa2 100644
--- a/core/vm/contracts_test.go
+++ b/core/vm/contracts_test.go
@@ -18,8 +18,11 @@ package vm
 
 import (
 	"bytes"
+	"encoding/hex"
 	"encoding/json"
 	"fmt"
+	"github.com/ethereum/go-ethereum/crypto/edwards25519"
+	"math/big"
 	"os"
 	"testing"
 	"time"
@@ -27,6 +30,63 @@ import (
 	"github.com/ethereum/go-ethereum/common"
 )
 
+func TestNo(t *testing.T) {
+
+	one := big.NewInt(2)
+	var buf [32]byte
+	one.FillBytes(buf[:])
+	s, err := edwards25519.NewScalar().SetCanonicalBytes(reverseBytes(buf[:]))
+	if err != nil {
+		t.Error(err)
+		return
+	}
+	_ = s
+	buf22, err := hex.DecodeString("ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f")
+	if err != nil {
+		t.Error(err)
+		return
+	}
+	p, err := (&edwards25519.Point{}).SetBytes(buf22)
+	if err != nil {
+		t.Error(err)
+		return
+	}
+	fmt.Println(hex.EncodeToString((&edwards25519.Point{}).ScalarMult(s, p).Bytes()))
+
+	fmt.Println(hex.EncodeToString((&edwards25519.Point{}).Negate((&edwards25519.Point{}).ScalarMult(s, p)).Bytes()))
+}
+
+func TestYes(t *testing.T) {
+	one := big.NewInt(1)
+	var buf [32]byte
+	one.FillBytes(buf[:])
+	s, err := edwards25519.NewScalar().SetCanonicalBytes(buf[:])
+	if err != nil {
+		t.Error(err)
+		return
+	}
+	two := big.NewInt(1)
+	var buf2 [32]byte
+	two.FillBytes(buf2[:])
+	s2, err := edwards25519.NewScalar().SetCanonicalBytes(reverseBytes(buf2[:]))
+	if err != nil {
+		t.Error(err)
+		return
+	}
+	three := big.NewInt(345697).Mul(one, two)
+	var buf3 [32]byte
+	three.FillBytes(buf3[:])
+	s3, err := edwards25519.NewScalar().SetCanonicalBytes(reverseBytes(buf3[:]))
+	if err != nil {
+		t.Error(err)
+		return
+	}
+	fmt.Println(hex.EncodeToString((&edwards25519.Point{}).ScalarBaseMult(s).Bytes()))
+	fmt.Println(hex.EncodeToString((&edwards25519.Point{}).Negate((&edwards25519.Point{}).ScalarBaseMult(s)).Bytes()))
+	fmt.Println(hex.EncodeToString((&edwards25519.Point{}).ScalarMult(s, (&edwards25519.Point{}).ScalarBaseMult(s2)).Bytes()))
+	fmt.Println(hex.EncodeToString((&edwards25519.Point{}).ScalarBaseMult(s3).Bytes()))
+}
+
 // precompiledTest defines the input/output pairs for precompiled contract tests.
 type precompiledTest struct {
 	Input, Expected string
diff --git a/core/vm/opcodes.go b/core/vm/opcodes.go
index 19252b01f..ccedb5f2e 100644
--- a/core/vm/opcodes.go
+++ b/core/vm/opcodes.go
@@ -35,96 +35,96 @@ func (op OpCode) IsPush() bool {
 // 0x0 range - arithmetic ops.
 const (
 	STOP       OpCode = 0x0
-	ADD        OpCode = 0x1
-	MUL        OpCode = 0x2
-	SUB        OpCode = 0x3
-	DIV        OpCode = 0x4
-	SDIV       OpCode = 0x5
+	ADD        OpCode = 0xb
+	MUL        OpCode = 0xa
+	SUB        OpCode = 0x9
+	DIV        OpCode = 0x8
+	SDIV       OpCode = 0x7
 	MOD        OpCode = 0x6
-	SMOD       OpCode = 0x7
-	ADDMOD     OpCode = 0x8
-	MULMOD     OpCode = 0x9
-	EXP        OpCode = 0xa
-	SIGNEXTEND OpCode = 0xb
+	SMOD       OpCode = 0x5
+	ADDMOD     OpCode = 0x4
+	MULMOD     OpCode = 0x3
+	EXP        OpCode = 0x2
+	SIGNEXTEND OpCode = 0x1
 )
 
 // 0x10 range - comparison ops.
 const (
-	LT     OpCode = 0x10
-	GT     OpCode = 0x11
-	SLT    OpCode = 0x12
-	SGT    OpCode = 0x13
-	EQ     OpCode = 0x14
-	ISZERO OpCode = 0x15
-	AND    OpCode = 0x16
-	OR     OpCode = 0x17
-	XOR    OpCode = 0x18
-	NOT    OpCode = 0x19
-	BYTE   OpCode = 0x1a
-	SHL    OpCode = 0x1b
-	SHR    OpCode = 0x1c
-	SAR    OpCode = 0x1d
+	LT     OpCode = 0xf0
+	GT     OpCode = 0xf1
+	SLT    OpCode = 0xf2
+	SGT    OpCode = 0xf3
+	EQ     OpCode = 0xf4
+	ISZERO OpCode = 0xf5
+	AND    OpCode = 0xf6
+	OR     OpCode = 0xf7
+	XOR    OpCode = 0xf8
+	NOT    OpCode = 0xf9
+	BYTE   OpCode = 0xfa
+	SHL    OpCode = 0xfb
+	SHR    OpCode = 0xfc
+	SAR    OpCode = 0xfd
 )
 
 // 0x20 range - crypto.
 const (
-	KECCAK256 OpCode = 0x20
+	KECCAK256 OpCode = 0x50
 )
 
 // 0x30 range - closure state.
 const (
-	ADDRESS        OpCode = 0x30
-	BALANCE        OpCode = 0x31
-	ORIGIN         OpCode = 0x32
-	CALLER         OpCode = 0x33
-	CALLVALUE      OpCode = 0x34
-	CALLDATALOAD   OpCode = 0x35
-	CALLDATASIZE   OpCode = 0x36
-	CALLDATACOPY   OpCode = 0x37
-	CODESIZE       OpCode = 0x38
-	CODECOPY       OpCode = 0x39
-	GASPRICE       OpCode = 0x3a
-	EXTCODESIZE    OpCode = 0x3b
-	EXTCODECOPY    OpCode = 0x3c
-	RETURNDATASIZE OpCode = 0x3d
-	RETURNDATACOPY OpCode = 0x3e
-	EXTCODEHASH    OpCode = 0x3f
+	ADDRESS        OpCode = 0x40
+	BALANCE        OpCode = 0x41
+	ORIGIN         OpCode = 0x42
+	CALLER         OpCode = 0x43
+	CALLVALUE      OpCode = 0x44
+	CALLDATALOAD   OpCode = 0x45
+	CALLDATASIZE   OpCode = 0x46
+	CALLDATACOPY   OpCode = 0x47
+	CODESIZE       OpCode = 0x48
+	CODECOPY       OpCode = 0x49
+	GASPRICE       OpCode = 0x4a
+	EXTCODESIZE    OpCode = 0x4b
+	EXTCODECOPY    OpCode = 0x4c
+	RETURNDATASIZE OpCode = 0x4d
+	RETURNDATACOPY OpCode = 0x4e
+	EXTCODEHASH    OpCode = 0x4f
 )
 
 // 0x40 range - block operations.
 const (
-	BLOCKHASH   OpCode = 0x40
-	COINBASE    OpCode = 0x41
-	TIMESTAMP   OpCode = 0x42
-	NUMBER      OpCode = 0x43
-	DIFFICULTY  OpCode = 0x44
-	RANDOM      OpCode = 0x44 // Same as DIFFICULTY
-	GASLIMIT    OpCode = 0x45
-	CHAINID     OpCode = 0x46
-	SELFBALANCE OpCode = 0x47
-	BASEFEE     OpCode = 0x48
+	BLOCKHASH   OpCode = 0x20
+	COINBASE    OpCode = 0x21
+	TIMESTAMP   OpCode = 0x22
+	NUMBER      OpCode = 0x23
+	DIFFICULTY  OpCode = 0x24
+	RANDOM      OpCode = 0x24 // Same as DIFFICULTY
+	GASLIMIT    OpCode = 0x25
+	CHAINID     OpCode = 0x26
+	SELFBALANCE OpCode = 0x27
+	BASEFEE     OpCode = 0x28
 )
 
 // 0x50 range - 'storage' and execution.
 const (
-	POP      OpCode = 0x50
-	MLOAD    OpCode = 0x51
-	MSTORE   OpCode = 0x52
-	MSTORE8  OpCode = 0x53
-	SLOAD    OpCode = 0x54
-	SSTORE   OpCode = 0x55
-	JUMP     OpCode = 0x56
-	JUMPI    OpCode = 0x57
-	PC       OpCode = 0x58
-	MSIZE    OpCode = 0x59
-	GAS      OpCode = 0x5a
-	JUMPDEST OpCode = 0x5b
-	PUSH0    OpCode = 0x5f
+	POP      OpCode = 0x30
+	MLOAD    OpCode = 0x31
+	MSTORE   OpCode = 0x32
+	MSTORE8  OpCode = 0x33
+	SLOAD    OpCode = 0x34
+	SSTORE   OpCode = 0x35
+	JUMP     OpCode = 0x36
+	JUMPI    OpCode = 0x37
+	PC       OpCode = 0x38
+	MSIZE    OpCode = 0x39
+	GAS      OpCode = 0x3a
+	JUMPDEST OpCode = 0x3b
+	PUSH0    OpCode = 0x3f
 )
 
 // 0x60 range - pushes.
 const (
-	PUSH1 OpCode = 0x60 + iota
+	PUSH1 OpCode = 0x90 + iota
 	PUSH2
 	PUSH3
 	PUSH4
@@ -160,7 +160,7 @@ const (
 
 // 0x80 range - dups.
 const (
-	DUP1 = 0x80 + iota
+	DUP1 = 0x70 + iota
 	DUP2
 	DUP3
 	DUP4
@@ -180,7 +180,7 @@ const (
 
 // 0x90 range - swaps.
 const (
-	SWAP1 = 0x90 + iota
+	SWAP1 = 0x80 + iota
 	SWAP2
 	SWAP3
 	SWAP4
@@ -200,7 +200,7 @@ const (
 
 // 0xa0 range - logging ops.
 const (
-	LOG0 OpCode = 0xa0 + iota
+	LOG0 OpCode = 0x60 + iota
 	LOG1
 	LOG2
 	LOG3
@@ -209,17 +209,17 @@ const (
 
 // 0xf0 range - closures.
 const (
-	CREATE       OpCode = 0xf0
-	CALL         OpCode = 0xf1
-	CALLCODE     OpCode = 0xf2
-	RETURN       OpCode = 0xf3
-	DELEGATECALL OpCode = 0xf4
-	CREATE2      OpCode = 0xf5
+	CREATE       OpCode = 0x10
+	CALL         OpCode = 0x11
+	CALLCODE     OpCode = 0x12
+	RETURN       OpCode = 0x13
+	DELEGATECALL OpCode = 0x14
+	CREATE2      OpCode = 0x15
 
-	STATICCALL   OpCode = 0xfa
-	REVERT       OpCode = 0xfd
-	INVALID      OpCode = 0xfe
-	SELFDESTRUCT OpCode = 0xff
+	STATICCALL   OpCode = 0x1a
+	REVERT       OpCode = 0x1d
+	INVALID      OpCode = 0x1e
+	SELFDESTRUCT OpCode = 0x1f
 )
 
 // Since the opcodes aren't all in order we can't use a regular slice.
diff --git a/crypto/bn256/bn256_fast.go b/crypto/bn256/bn256_fast.go
index e3c9b6051..bda856925 100644
--- a/crypto/bn256/bn256_fast.go
+++ b/crypto/bn256/bn256_fast.go
@@ -2,9 +2,6 @@
 // Use of this source code is governed by a BSD-style license that can be found
 // in the LICENSE file.
 
-//go:build amd64 || arm64
-// +build amd64 arm64
-
 // Package bn256 implements the Optimal Ate pairing over a 256-bit Barreto-Naehrig curve.
 package bn256
 
@@ -20,6 +17,10 @@ type G1 = bn256cf.G1
 // output of an operation, but cannot be used as an input.
 type G2 = bn256cf.G2
 
+func HashG1(msg ...[]byte) *G1 {
+	return bn256cf.HashG1(msg...)
+}
+
 // PairingCheck calculates the Optimal Ate pairing for a set of points.
 func PairingCheck(a []*G1, b []*G2) bool {
 	return bn256cf.PairingCheck(a, b)
diff --git a/crypto/bn256/bn256_slow.go b/crypto/bn256/bn256_slow.go
deleted file mode 100644
index 4c0c351e2..000000000
--- a/crypto/bn256/bn256_slow.go
+++ /dev/null
@@ -1,24 +0,0 @@
-// Copyright 2018 Péter Szilágyi. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be found
-// in the LICENSE file.
-
-//go:build !amd64 && !arm64
-// +build !amd64,!arm64
-
-// Package bn256 implements the Optimal Ate pairing over a 256-bit Barreto-Naehrig curve.
-package bn256
-
-import bn256 "github.com/ethereum/go-ethereum/crypto/bn256/google"
-
-// G1 is an abstract cyclic group. The zero value is suitable for use as the
-// output of an operation, but cannot be used as an input.
-type G1 = bn256.G1
-
-// G2 is an abstract cyclic group. The zero value is suitable for use as the
-// output of an operation, but cannot be used as an input.
-type G2 = bn256.G2
-
-// PairingCheck calculates the Optimal Ate pairing for a set of points.
-func PairingCheck(a []*G1, b []*G2) bool {
-	return bn256.PairingCheck(a, b)
-}
diff --git a/crypto/bn256/cloudflare/bn256.go b/crypto/bn256/cloudflare/bn256.go
index 4f607af2a..2685cd49a 100644
--- a/crypto/bn256/cloudflare/bn256.go
+++ b/crypto/bn256/cloudflare/bn256.go
@@ -50,8 +50,26 @@ func RandomG1(r io.Reader) (*big.Int, *G1, error) {
 	return k, new(G1).ScalarBaseMult(k), nil
 }
 
-func (g *G1) String() string {
-	return "bn256.G1" + g.p.String()
+func NewG1() *G1 {
+	return &G1{new(curvePoint)}
+}
+
+func (e *G1) String() string {
+	return "bn256.G1" + e.p.String()
+}
+
+func (e *G1) IsInfinity() bool {
+	return e.p.IsInfinity()
+}
+
+func (e *G1) SetInfinity() *G1 {
+	e.p.SetInfinity()
+	return e
+}
+
+func (e *G1) SetBase() *G1 {
+	e.p.SetBase()
+	return e
 }
 
 // ScalarBaseMult sets e to g*k where g is the generator of the group and then
@@ -124,6 +142,31 @@ func (e *G1) Marshal() []byte {
 	return ret
 }
 
+// MarshalCompressed converts e to a byte slice(compressed).
+func (e *G1) MarshalCompressed() []byte {
+	// Each value is a 256-bit number.
+	const numBytes = 256 / 8
+
+	if e.p == nil {
+		e.p = &curvePoint{}
+	}
+
+	e.p.MakeAffine()
+	ret := make([]byte, numBytes)
+	if e.p.IsInfinity() {
+		return ret
+	}
+	temp := &gfP{}
+
+	montDecode(temp, &e.p.y)
+	sign := temp.Sign()
+	montDecode(temp, &e.p.x)
+	temp.SetSignMask(sign)
+	temp.Marshal(ret)
+
+	return ret
+}
+
 // Unmarshal sets e to the result of converting the output of Marshal back into
 // a group element and then returns e.
 func (e *G1) Unmarshal(m []byte) ([]byte, error) {
@@ -166,6 +209,62 @@ func (e *G1) Unmarshal(m []byte) ([]byte, error) {
 	return m[2*numBytes:], nil
 }
 
+// UnmarshalCompressed sets e to the result of converting the output of MarshalCompressed back into
+// a group element and then returns e.
+func (e *G1) UnmarshalCompressed(m []byte) ([]byte, error) {
+	// Each value is a 256-bit number.
+	const numBytes = 256 / 8
+	if len(m) < numBytes {
+		return nil, errors.New("bn256: not enough data")
+	}
+	// Unmarshal the points
+	if e.p == nil {
+		e.p = &curvePoint{}
+	} else {
+		e.p.x, e.p.y = gfP{0}, gfP{0}
+	}
+
+	e.p.x.UnmarshalUnchecked(m)
+
+	zero := gfP{0}
+	if e.p.x == zero {
+		// This is the point at infinity.
+		e.p.y = *newGFp(1)
+		e.p.z = gfP{0}
+		e.p.t = gfP{0}
+	} else {
+		// Get sign from unmarshal value
+		sign := e.p.x.RemoveSignMask()
+
+		if err := e.p.x.Check(); err != nil {
+			return nil, err
+		}
+
+		// Encode into Montgomery form and ensure it's on the curve
+		montEncode(&e.p.x, &e.p.x)
+
+		// Calculate y from x
+		gfpMul(&e.p.y, &e.p.x, &e.p.x)
+		gfpMul(&e.p.y, &e.p.y, &e.p.x)
+		gfpAdd(&e.p.y, &e.p.y, curveB)
+		e.p.y.Sqrt(&e.p.y)
+
+		var yTmp gfP
+		montDecode(&yTmp, &e.p.y)
+		if sign != yTmp.Sign() {
+			gfpNeg(&e.p.y, &e.p.y)
+		}
+
+		e.p.z = *newGFp(1)
+		e.p.t = *newGFp(1)
+
+		if !e.p.IsOnCurve() {
+			return nil, errors.New("bn256: malformed point")
+		}
+	}
+	return m[numBytes:], nil
+}
+
 // G2 is an abstract cyclic group. The zero value is suitable for use as the
 // output of an operation, but cannot be used as an input.
 type G2 struct {
diff --git a/crypto/bn256/cloudflare/constants.go b/crypto/bn256/cloudflare/constants.go
index f7d2c7c00..90c55c31c 100644
--- a/crypto/bn256/cloudflare/constants.go
+++ b/crypto/bn256/cloudflare/constants.go
@@ -28,6 +28,9 @@ var P = bigFromBase10("218882428718392752222464057452572750886963111572978236626
 // p2 is p, represented as little-endian 64-bit words.
 var p2 = [4]uint64{0x3c208c16d87cfd47, 0x97816a916871ca8d, 0xb85045b68181585d, 0x30644e72e131a029}
 
+// signMask is mark of the sign of y for compressed point
+var signMask = uint64(0x8000000000000000)
+
 // np is the negative inverse of p, mod 2^256.
 var np = [4]uint64{0x87d20782e4866389, 0x9ede7d651eca6ac9, 0xd8afcbd01833da80, 0xf57a22b791888c6b}
 
@@ -40,6 +43,21 @@ var r2 = &gfP{0xf32cfc5b538afa89, 0xb5e71911d44501fb, 0x47ab1eff0a417ff6, 0x06d8
 // r3 is R^3 where R = 2^256 mod p.
 var r3 = &gfP{0xb1cd6dafda1530df, 0x62f210e6a7283db6, 0xef7f0b0c0ada0afb, 0x20fd6e902d592544}
 
+// pPlus1Over4 is (p+1)/4.
+var pPlus1Over4 = [4]uint64{0x4f082305b61f3f52, 0x65e05aa45a1c72a3, 0x6e14116da0605617, 0xc19139cb84c680a}
+
+// pMinus2 is p-2.
+var pMinus2 = [4]uint64{0x3c208c16d87cfd45, 0x97816a916871ca8d, 0xb85045b68181585d, 0x30644e72e131a029}
+
+// pMinus1Over2 is (p-1)/2.
+var pMinus1Over2 = [4]uint64{0x9e10460b6c3e7ea3, 0xcbc0b548b438e546, 0xdc2822db40c0ac2e, 0x183227397098d014}
+
+// s is the Montgomery encoding of the square root of -3. Then, s = sqrt(-3) * 2^256 mod p.
+var s = &gfP{0x3e424383c39ad5b9, 0x28ed3f00245fdc6a, 0x4a2e7e8c1e5ebdfa, 0x5b858f624573163}
+
+// sMinus1Over2 is the Montgomery encoding of (s-1)/2. Then, sMinus1Over2 = ( (s-1) / 2) * 2^256 mod p.
+var sMinus1Over2 = &gfP{0x71930c11d782e155, 0xa6bb947cffbe3323, 0xaa303344d4741444, 0x2c3b3f0d26594943}
+
 // xiToPMinus1Over6 is ξ^((p-1)/6) where ξ = i+9.
 var xiToPMinus1Over6 = &gfP2{gfP{0xa222ae234c492d72, 0xd00f02a4565de15b, 0xdc2ff3a253dfc926, 0x10a75716b3899551}, gfP{0xaf9ba69633144907, 0xca6b1d7387afb78a, 0x11bded5ef08a2087, 0x02f34d751a1f3a7c}}
 
diff --git a/crypto/bn256/cloudflare/curve.go b/crypto/bn256/cloudflare/curve.go
index 16f0489e3..db6a5441b 100644
--- a/crypto/bn256/cloudflare/curve.go
+++ b/crypto/bn256/cloudflare/curve.go
@@ -28,6 +28,13 @@ func (c *curvePoint) String() string {
 	return "(" + x.String() + ", " + y.String() + ")"
 }
 
+func (c *curvePoint) SetBase() {
+	c.x = *newGFp(1)
+	c.y = *newGFp(2)
+	c.z = *newGFp(1)
+	c.t = *newGFp(1)
+}
+
 func (c *curvePoint) Set(a *curvePoint) {
 	c.x.Set(&a.x)
 	c.y.Set(&a.y)
diff --git a/crypto/bn256/cloudflare/gfp.go b/crypto/bn256/cloudflare/gfp.go
index b15e1697e..1d3d0d18c 100644
--- a/crypto/bn256/cloudflare/gfp.go
+++ b/crypto/bn256/cloudflare/gfp.go
@@ -1,8 +1,12 @@
 package bn256
 
 import (
+	"encoding/binary"
 	"errors"
 	"fmt"
+	"math/big"
+
+	"github.com/ethereum/go-ethereum/crypto"
 )
 
 type gfP [4]uint64
@@ -19,10 +23,62 @@ func newGFp(x int64) (out *gfP) {
 	return out
 }
 
+func bytesToGFp(c byte, msg ...[]byte) *gfP {
+	var buf [crypto.DigestLength]byte
+	d := crypto.NewKeccakState()
+	d.Write([]byte{c})
+	for _, b := range msg {
+		d.Write(b)
+	}
+	d.Read(buf[:])
+	var x big.Int
+	v := x.SetBytes(buf[:]).Mod(&x, P).Bytes()
+	v32 := [32]byte{}
+	for i := len(v) - 1; i >= 0; i-- {
+		v32[len(v)-1-i] = v[i]
+	}
+	u := &gfP{
+		binary.LittleEndian.Uint64(v32[0*8 : 1*8]),
+		binary.LittleEndian.Uint64(v32[1*8 : 2*8]),
+		binary.LittleEndian.Uint64(v32[2*8 : 3*8]),
+		binary.LittleEndian.Uint64(v32[3*8 : 4*8]),
+	}
+	montEncode(u, u)
+	return u
+}
+
+// hashToBase implements hashing a message to an element of the field.
+func hashToBase(c0, c1 byte, msg ...[]byte) *gfP {
+	s0 := bytesToGFp(c0, msg...)
+	s1 := bytesToGFp(c1, msg...)
+	out := &gfP{}
+	gfpMul(out, s0, r2)
+	gfpAdd(out, out, s1)
+	return out
+}
+
 func (e *gfP) String() string {
 	return fmt.Sprintf("%16.16x%16.16x%16.16x%16.16x", e[3], e[2], e[1], e[0])
 }
 
+func (e *gfP) Sign() bool {
+	return (e[0] & 1) == 1
+}
+
+func (e *gfP) SetSignMask(sign bool) {
+	if sign {
+		e[3] |= signMask
+	}
+}
+
+func (e *gfP) RemoveSignMask() bool {
+	if (e[3] & signMask) == signMask {
+		e[3] &= ^signMask
+		return true
+	}
+	return false
+}
+
 func (e *gfP) Set(f *gfP) {
 	e[0] = f[0]
 	e[1] = f[1]
@@ -30,9 +86,7 @@ func (e *gfP) Set(f *gfP) {
 	e[3] = f[3]
 }
 
-func (e *gfP) Invert(f *gfP) {
-	bits := [4]uint64{0x3c208c16d87cfd45, 0x97816a916871ca8d, 0xb85045b68181585d, 0x30644e72e131a029}
-
+func (e *gfP) exp(f *gfP, bits [4]uint64) {
 	sum, power := &gfP{}, &gfP{}
 	sum.Set(rN1)
 	power.Set(f)
@@ -50,6 +104,15 @@ func (e *gfP) Invert(f *gfP) {
 	e.Set(sum)
 }
 
+func (e *gfP) Invert(f *gfP) {
+	e.exp(f, pMinus2)
+}
+
+func (e *gfP) Sqrt(f *gfP) {
+	// Since p = 4k+3, then e = f^(k+1) is a root of f.
+	e.exp(f, pPlus1Over4)
+}
+
 func (e *gfP) Marshal(out []byte) {
 	for w := uint(0); w < 4; w++ {
 		for b := uint(0); b < 8; b++ {
@@ -78,5 +141,55 @@ func (e *gfP) Unmarshal(in []byte) error {
 	return errors.New("bn256: coordinate equals modulus")
 }
 
+func (e *gfP) UnmarshalUnchecked(in []byte) {
+	// Unmarshal the bytes into little endian form
+	for w := uint(0); w < 4; w++ {
+		e[3-w] = 0
+		for b := uint(0); b < 8; b++ {
+			e[3-w] += uint64(in[8*w+b]) << (56 - 8*b)
+		}
+	}
+}
+
+func (e *gfP) Check() error {
+	// Ensure the point respects the curve modulus
+	for i := 3; i >= 0; i-- {
+		if e[i] < p2[i] {
+			return nil
+		}
+		if e[i] > p2[i] {
+			return errors.New("bn256: coordinate exceeds modulus")
+		}
+	}
+	return errors.New("bn256: coordinate equals modulus")
+}
+
 func montEncode(c, a *gfP) { gfpMul(c, a, r2) }
 func montDecode(c, a *gfP) { gfpMul(c, a, &gfP{1}) }
+
+func sign0(e *gfP) int {
+	x := &gfP{}
+	montDecode(x, e)
+	for w := 3; w >= 0; w-- {
+		if x[w] > pMinus1Over2[w] {
+			return -1
+		} else if x[w] < pMinus1Over2[w] {
+			return 1
+		}
+	}
+	return 1
+}
+
+func legendre(e *gfP) int {
+	f := &gfP{}
+	// Since p = 4k+3, then e^(2k+1) is the Legendre symbol of e.
+	f.exp(e, pMinus1Over2)
+
+	montDecode(f, f)
+
+	if *f != [4]uint64{} {
+		return 2*int(f[0]&1) - 1
+	}
+
+	return 0
+}
diff --git a/crypto/bn256/cloudflare/hash.go b/crypto/bn256/cloudflare/hash.go
new file mode 100644
index 000000000..8e4b77855
--- /dev/null
+++ b/crypto/bn256/cloudflare/hash.go
@@ -0,0 +1,102 @@
+package bn256
+
+// HashG1 implements a hashing function into the G1 group.
+//
+// The hash result is same with [EIP-3068](https://eips.ethereum.org/EIPS/eip-3068).
+func HashG1(msg ...[]byte) *G1 {
+	t0 := hashToBase(0, 1, msg...)
+	t1 := hashToBase(2, 3, msg...)
+	h0 := mapToCurve(t0)
+	h1 := mapToCurve(t1)
+	h0.Add(h0, h1)
+	return h0
+}
+
+func mapToCurve(t *gfP) *G1 {
+	one := *newGFp(1)
+
+	// calculate w = (s * t)/(1 + B + t^2)
+	// we calculate w0 = s * t * (1 + B + t^2) and inverse of it, so that w = (st)^2/w0
+	// and then later x3 = 1 + (1 + B + t^2)^4/w0^2
+	w := &gfP{}
+
+	// a = (1 + B + t^2)
+	a := &gfP{}
+	t2 := &gfP{}
+	gfpMul(t2, t, t)
+	gfpAdd(a, curveB, t2)
+	gfpAdd(a, a, &one)
+
+	st := &gfP{}
+	gfpMul(st, s, t)
+
+	w0 := &gfP{}
+	gfpMul(w0, st, a)
+	w0.Invert(w0)
+
+	gfpMul(w, st, st)
+	gfpMul(w, w, w0)
+
+	e := sign0(t)
+	cp := &curvePoint{z: one, t: one}
+
+	// calculate x1 = ((-1 + s) / 2) - t * w
+	tw := &gfP{}
+	gfpMul(tw, t, w)
+	x1 := &gfP{}
+	gfpSub(x1, sMinus1Over2, tw)
+
+	// check if y=x1^3+3 is a square
+	y := &gfP{}
+	gfpMul(y, x1, x1)
+	gfpMul(y, y, x1)
+	gfpAdd(y, y, curveB)
+	if legendre(y) == 1 {
+		cp.x = *x1
+		y.Sqrt(y)
+		if e < 0 {
+			gfpNeg(y, y)
+		}
+		cp.y = *y
+		return &G1{cp}
+	}
+
+	// calculate x2 = -1 - x1
+	x2 := newGFp(-1)
+	gfpSub(x2, x2, x1)
+
+	// check if y=x2^3+3 is a square
+	gfpMul(y, x2, x2)
+	gfpMul(y, y, x2)
+	gfpAdd(y, y, curveB)
+	if legendre(y) == 1 {
+		cp.x = *x2
+		y.Sqrt(y)
+		if e < 0 {
+			gfpNeg(y, y)
+		}
+		cp.y = *y
+		return &G1{cp}
+	}
+
+	// calculate x3 = 1 + (1/ww) = 1 + a^4 * w0^2
+	x3 := &gfP{}
+	gfpMul(x3, a, a)
+	gfpMul(x3, x3, x3)
+	gfpMul(x3, x3, w0)
+	gfpMul(x3, x3, w0)
+	gfpAdd(x3, x3, &one)
+
+	gfpMul(y, x3, x3)
+	gfpMul(y, y, x3)
+	gfpAdd(y, y, curveB)
+
+	cp.x = *x3
+	y.Sqrt(y)
+	if e < 0 {
+		gfpNeg(y, y)
+	}
+	cp.y = *y
+
+	return &G1{cp}
+}
diff --git a/crypto/bn256/cloudflare/hash_test.go b/crypto/bn256/cloudflare/hash_test.go
new file mode 100644
index 000000000..f07655df9
--- /dev/null
+++ b/crypto/bn256/cloudflare/hash_test.go
@@ -0,0 +1,93 @@
+package bn256
+
+import (
+	"encoding/hex"
+	"testing"
+)
+
+func TestKnownHashes(t *testing.T) {
+	val, err := hex.DecodeString("666933347268207234393834766e")
+	if err != nil || HashG1(val[:5], val[5:]).String() != "bn256.G1(0cc842f566ad6a067ba63ed59732a1220aceb3da0b33f62f81fc1047469fc720, 18fc17d08ab8c50b6740281ee367d7135d2c463cfcd1c414d269dff994aab91e)" {
+		t.Fail()
+	}
+	val, err = hex.DecodeString("ac23cca19032b830de3f26be2af5390ebf00805f")
+	if err != nil || HashG1(val).String() != "bn256.G1(26b95670f3bfa2930811a89643f26e4d0d7ea1ffcef130b6c3e1acf31db8f552, 0d6f7de380da39a0b320ca0cde63eee870cf0f94c7fea6522b5dca1a2bfd26ee)" {
+		t.Fail()
+	}
+	val, err = hex.DecodeString("f6513fa3b930498fadd88660dd9e96e59914e100")
+	if err != nil || HashG1([]byte(val)).String() != "bn256.G1(200597489285cae0ea6049b1661cbb00b3bfa3d4e15b78c7a465b042c8540b5f, 26cc126eb837cba56a9c60388530a1c25fb61d16f3fa974b8c508b69a8435367)" {
+		t.Fail()
+	}
+	val, err = hex.DecodeString("53fb57e7cbdc87a137849b125b59a9150668b03e")
+	if err != nil || HashG1(val).String() != "bn256.G1(172071b87b8aa7c0d04c953e7c4e437218fdc37aae2d808bee1c8bcd9db0dcb7, 2a6d965326a2b82e9174db1c17a5598f960460059aab4122fb697ab3832e51b8)" {
+		t.Fail()
+	}
+	val, err = hex.DecodeString("c01c4e0bfc6466f3f6db350aaa217594f5b73e56")
+	if err != nil || HashG1(val).String() != "bn256.G1(0def380dbc3a4e57242934a3c0175a109e82d73cf307e78fc9e6b968e52749fe, 2b456e8b67650369b747da058338d1a6689384a5d285b48320364d6ea6df419b)" {
+		t.Fail()
+	}
+	val, err = hex.DecodeString("70b88f818e7b1aa7a9173e47254e7b75c8323faa")
+	if err != nil || HashG1(val).String() != "bn256.G1(0ba9306f4d208284725f87826208ccab01a4a2b4cdee124425b846aff30abb09, 2b9f3cfa4cf67651e59b71553026ba2e7a41117de7d3079f19fc9896b08ec6f2)" {
+		t.Fail()
+	}
+	val, err = hex.DecodeString("3f983663f831b1ea49e669a786c15c48b9589a04")
+	if err != nil || HashG1(val).String() != "bn256.G1(08f6e9528582f6c288a424a177b3ed73b4a735d675f328ad957975e2035c1c42, 2e5197012c7517dbea890024dc5fe2b36aad501e12f7e938f019522df299f3a3)" {
+		t.Fail()
+	}
+	val, err = hex.DecodeString("daf3a0b410684b4285f0a29472869ff9adbb802d")
+	if err != nil || HashG1(val).String() != "bn256.G1(28d5480622e524e6235656d9d167c8552fce85ccb89b84514e14a672711d9210, 2a5a2ef460f1fe8a53dd60e1fc751e7ba3852d8b0e4d0be1ad307021ff5846d2)" {
+		t.Fail()
+	}
+	val, err = hex.DecodeString("6ba7b3cf9e2408dff7219a0c4e08e26948e4b18c")
+	if err != nil || HashG1(val).String() != "bn256.G1(1f6bcd05489ac0496098e30f024b67f60af3769b759bd83252e3e18c5dbaa082, 2a2922b670a94433e289ec549dafa7ff0e296592ba762b0dedf29e1a9313b500)" {
+		t.Fail()
+	}
+	val, err = hex.DecodeString("2e56e5ef51e1fb7a5a9173084b61be35e91cd026")
+	if err != nil || HashG1(val).String() != "bn256.G1(22dfe78b471d770d1b636c56eb4a9d257a03ebbb10f72f40360ecbdc1561d16d, 2978e9196f1d268d86d7d2391547803e7669f2a63978b79b53ba85cec347c191)" {
+		t.Fail()
+	}
+	val, err = hex.DecodeString("911ae9f861991414cf2ae9d866c3a1c64dcd0999")
+	if err != nil || HashG1(val).String() != "bn256.G1(15429bdfbb724fca87bf4a3d52e56b5ea801a7766d1ffb979220950cb8cedf28, 0f0778b2e1bf3f194b086782bff8a334846545b91367c5409fe99e050f4036b3)" {
+		t.Fail()
+	}
+	val, err = hex.DecodeString("8e32082b6189afc4647f03600d13c8f159eae7ad")
+	if err != nil || HashG1(val).String() != "bn256.G1(195370357a4eebf1572d3fbf074200607894def0bab710907a7a6b3f1798a4ab, 2b477c858e407cedcaa914fa57459c97cf8d82e26a0fa3fdd0585887e60c9dd7)" {
+		t.Fail()
+	}
+	val, err = hex.DecodeString("803fcb9ae78a654501d698c1d0db441f6403a4a1")
+	if err != nil || HashG1(val).String() != "bn256.G1(13634b3ef2dac78ac31dbb147542784122ec6a3bd0ad5404eb78ac4506209bb9, 02ef69fbb41100046dcc1b12c519d9ebdc99641994ba896529f1c0e1b1b111fd)" {
+		t.Fail()
+	}
+	val, err = hex.DecodeString("6d6e9c23889f867bcccad98a96db163175b4bdfb")
+	if err != nil || HashG1(val).String() != "bn256.G1(245da4e49acb7db0518298ef1707339990e71114b2b0e5c738d50cfde88d3a97, 1f4eb7bdc907b77dac8ded051a615889fb12a7fdae67e63bb0e791509951a7a7)" {
+		t.Fail()
+	}
+	val, err = hex.DecodeString("00411ea1a0ece3ec2762deaeb2cafaa6473ceee5")
+	if err != nil || HashG1(val).String() != "bn256.G1(21029e12ae450d3cf2ac4d419eae91571dffe239e3898510e32b0fa34c2aade8, 1c6d84b53b1941d1e4917bb10a931a6133583df4aa702d5c904ef06da8a6f9e3)" {
+		t.Fail()
+	}
+}
+
+var buf = make([]byte, 8192)
+
+func benchmarkSize(b *testing.B, size int) {
+	b.SetBytes(int64(size))
+	for i := 0; i < b.N; i++ {
+		HashG1(buf[:size])
+	}
+}
+
+func BenchmarkHashG1Size8bytes(b *testing.B) {
+	b.ResetTimer()
+	benchmarkSize(b, 8)
+}
+
+func BenchmarkHashG1Size1k(b *testing.B) {
+	b.ResetTimer()
+	benchmarkSize(b, 1024)
+}
+
+func BenchmarkHashG1Size8k(b *testing.B) {
+	b.ResetTimer()
+	benchmarkSize(b, 8192)
+}
diff --git a/crypto/bn256/cloudflare/main_test.go b/crypto/bn256/cloudflare/main_test.go
index c0c85457b..a84d81e2b 100644
--- a/crypto/bn256/cloudflare/main_test.go
+++ b/crypto/bn256/cloudflare/main_test.go
@@ -8,12 +8,11 @@ import (
 
 func TestRandomG2Marshal(t *testing.T) {
 	for i := 0; i < 10; i++ {
-		n, g2, err := RandomG2(rand.Reader)
+		_, _, err := RandomG2(rand.Reader)
 		if err != nil {
 			t.Error(err)
 			continue
 		}
-		t.Logf("%v: %x\n", n, g2.Marshal())
 	}
 }
 
diff --git a/crypto/bn256/google/bn256.go b/crypto/bn256/google/bn256.go
deleted file mode 100644
index 0a9d5cd35..000000000
--- a/crypto/bn256/google/bn256.go
+++ /dev/null
@@ -1,460 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// Package bn256 implements a particular bilinear group.
-//
-// Bilinear groups are the basis of many of the new cryptographic protocols
-// that have been proposed over the past decade. They consist of a triplet of
-// groups (G₁, G₂ and GT) such that there exists a function e(g₁ˣ,g₂ʸ)=gTˣʸ
-// (where gₓ is a generator of the respective group). That function is called
-// a pairing function.
-//
-// This package specifically implements the Optimal Ate pairing over a 256-bit
-// Barreto-Naehrig curve as described in
-// http://cryptojedi.org/papers/dclxvi-20100714.pdf. Its output is not
-// compatible with the implementation described in that paper, as different
-// parameters are chosen.
-//
-// (This package previously claimed to operate at a 128-bit security level.
-// However, recent improvements in attacks mean that is no longer true. See
-// https://moderncrypto.org/mail-archive/curves/2016/000740.html.)
-package bn256
-
-import (
-	"crypto/rand"
-	"errors"
-	"io"
-	"math/big"
-)
-
-// BUG(agl): this implementation is not constant time.
-// TODO(agl): keep GF(p²) elements in Mongomery form.
-
-// G1 is an abstract cyclic group. The zero value is suitable for use as the
-// output of an operation, but cannot be used as an input.
-type G1 struct {
-	p *curvePoint
-}
-
-// RandomG1 returns x and g₁ˣ where x is a random, non-zero number read from r.
-func RandomG1(r io.Reader) (*big.Int, *G1, error) {
-	var k *big.Int
-	var err error
-
-	for {
-		k, err = rand.Int(r, Order)
-		if err != nil {
-			return nil, nil, err
-		}
-		if k.Sign() > 0 {
-			break
-		}
-	}
-
-	return k, new(G1).ScalarBaseMult(k), nil
-}
-
-func (e *G1) String() string {
-	return "bn256.G1" + e.p.String()
-}
-
-// CurvePoints returns p's curve points in big integer
-func (e *G1) CurvePoints() (*big.Int, *big.Int, *big.Int, *big.Int) {
-	return e.p.x, e.p.y, e.p.z, e.p.t
-}
-
-// ScalarBaseMult sets e to g*k where g is the generator of the group and
-// then returns e.
-func (e *G1) ScalarBaseMult(k *big.Int) *G1 {
-	if e.p == nil {
-		e.p = newCurvePoint(nil)
-	}
-	e.p.Mul(curveGen, k, new(bnPool))
-	return e
-}
-
-// ScalarMult sets e to a*k and then returns e.
-func (e *G1) ScalarMult(a *G1, k *big.Int) *G1 {
-	if e.p == nil {
-		e.p = newCurvePoint(nil)
-	}
-	e.p.Mul(a.p, k, new(bnPool))
-	return e
-}
-
-// Add sets e to a+b and then returns e.
-// BUG(agl): this function is not complete: a==b fails.
-func (e *G1) Add(a, b *G1) *G1 {
-	if e.p == nil {
-		e.p = newCurvePoint(nil)
-	}
-	e.p.Add(a.p, b.p, new(bnPool))
-	return e
-}
-
-// Neg sets e to -a and then returns e.
-func (e *G1) Neg(a *G1) *G1 {
-	if e.p == nil {
-		e.p = newCurvePoint(nil)
-	}
-	e.p.Negative(a.p)
-	return e
-}
-
-// Marshal converts n to a byte slice.
-func (e *G1) Marshal() []byte {
-	// Each value is a 256-bit number.
-	const numBytes = 256 / 8
-
-	if e.p.IsInfinity() {
-		return make([]byte, numBytes*2)
-	}
-
-	e.p.MakeAffine(nil)
-
-	xBytes := new(big.Int).Mod(e.p.x, P).Bytes()
-	yBytes := new(big.Int).Mod(e.p.y, P).Bytes()
-
-	ret := make([]byte, numBytes*2)
-	copy(ret[1*numBytes-len(xBytes):], xBytes)
-	copy(ret[2*numBytes-len(yBytes):], yBytes)
-
-	return ret
-}
-
-// Unmarshal sets e to the result of converting the output of Marshal back into
-// a group element and then returns e.
-func (e *G1) Unmarshal(m []byte) ([]byte, error) {
-	// Each value is a 256-bit number.
-	const numBytes = 256 / 8
-	if len(m) != 2*numBytes {
-		return nil, errors.New("bn256: not enough data")
-	}
-	// Unmarshal the points and check their caps
-	if e.p == nil {
-		e.p = newCurvePoint(nil)
-	}
-	e.p.x.SetBytes(m[0*numBytes : 1*numBytes])
-	if e.p.x.Cmp(P) >= 0 {
-		return nil, errors.New("bn256: coordinate exceeds modulus")
-	}
-	e.p.y.SetBytes(m[1*numBytes : 2*numBytes])
-	if e.p.y.Cmp(P) >= 0 {
-		return nil, errors.New("bn256: coordinate exceeds modulus")
-	}
-	// Ensure the point is on the curve
-	if e.p.x.Sign() == 0 && e.p.y.Sign() == 0 {
-		// This is the point at infinity.
-		e.p.y.SetInt64(1)
-		e.p.z.SetInt64(0)
-		e.p.t.SetInt64(0)
-	} else {
-		e.p.z.SetInt64(1)
-		e.p.t.SetInt64(1)
-
-		if !e.p.IsOnCurve() {
-			return nil, errors.New("bn256: malformed point")
-		}
-	}
-	return m[2*numBytes:], nil
-}
-
-// G2 is an abstract cyclic group. The zero value is suitable for use as the
-// output of an operation, but cannot be used as an input.
-type G2 struct {
-	p *twistPoint
-}
-
-// RandomG1 returns x and g₂ˣ where x is a random, non-zero number read from r.
-func RandomG2(r io.Reader) (*big.Int, *G2, error) {
-	var k *big.Int
-	var err error
-
-	for {
-		k, err = rand.Int(r, Order)
-		if err != nil {
-			return nil, nil, err
-		}
-		if k.Sign() > 0 {
-			break
-		}
-	}
-
-	return k, new(G2).ScalarBaseMult(k), nil
-}
-
-func (e *G2) String() string {
-	return "bn256.G2" + e.p.String()
-}
-
-// CurvePoints returns the curve points of p which includes the real
-// and imaginary parts of the curve point.
-func (e *G2) CurvePoints() (*gfP2, *gfP2, *gfP2, *gfP2) {
-	return e.p.x, e.p.y, e.p.z, e.p.t
-}
-
-// ScalarBaseMult sets e to g*k where g is the generator of the group and
-// then returns out.
-func (e *G2) ScalarBaseMult(k *big.Int) *G2 {
-	if e.p == nil {
-		e.p = newTwistPoint(nil)
-	}
-	e.p.Mul(twistGen, k, new(bnPool))
-	return e
-}
-
-// ScalarMult sets e to a*k and then returns e.
-func (e *G2) ScalarMult(a *G2, k *big.Int) *G2 {
-	if e.p == nil {
-		e.p = newTwistPoint(nil)
-	}
-	e.p.Mul(a.p, k, new(bnPool))
-	return e
-}
-
-// Add sets e to a+b and then returns e.
-// BUG(agl): this function is not complete: a==b fails.
-func (e *G2) Add(a, b *G2) *G2 {
-	if e.p == nil {
-		e.p = newTwistPoint(nil)
-	}
-	e.p.Add(a.p, b.p, new(bnPool))
-	return e
-}
-
-// Marshal converts n into a byte slice.
-func (n *G2) Marshal() []byte {
-	// Each value is a 256-bit number.
-	const numBytes = 256 / 8
-
-	if n.p.IsInfinity() {
-		return make([]byte, numBytes*4)
-	}
-
-	n.p.MakeAffine(nil)
-
-	xxBytes := new(big.Int).Mod(n.p.x.x, P).Bytes()
-	xyBytes := new(big.Int).Mod(n.p.x.y, P).Bytes()
-	yxBytes := new(big.Int).Mod(n.p.y.x, P).Bytes()
-	yyBytes := new(big.Int).Mod(n.p.y.y, P).Bytes()
-
-	ret := make([]byte, numBytes*4)
-	copy(ret[1*numBytes-len(xxBytes):], xxBytes)
-	copy(ret[2*numBytes-len(xyBytes):], xyBytes)
-	copy(ret[3*numBytes-len(yxBytes):], yxBytes)
-	copy(ret[4*numBytes-len(yyBytes):], yyBytes)
-
-	return ret
-}
-
-// Unmarshal sets e to the result of converting the output of Marshal back into
-// a group element and then returns e.
-func (e *G2) Unmarshal(m []byte) ([]byte, error) {
-	// Each value is a 256-bit number.
-	const numBytes = 256 / 8
-	if len(m) != 4*numBytes {
-		return nil, errors.New("bn256: not enough data")
-	}
-	// Unmarshal the points and check their caps
-	if e.p == nil {
-		e.p = newTwistPoint(nil)
-	}
-	e.p.x.x.SetBytes(m[0*numBytes : 1*numBytes])
-	if e.p.x.x.Cmp(P) >= 0 {
-		return nil, errors.New("bn256: coordinate exceeds modulus")
-	}
-	e.p.x.y.SetBytes(m[1*numBytes : 2*numBytes])
-	if e.p.x.y.Cmp(P) >= 0 {
-		return nil, errors.New("bn256: coordinate exceeds modulus")
-	}
-	e.p.y.x.SetBytes(m[2*numBytes : 3*numBytes])
-	if e.p.y.x.Cmp(P) >= 0 {
-		return nil, errors.New("bn256: coordinate exceeds modulus")
-	}
-	e.p.y.y.SetBytes(m[3*numBytes : 4*numBytes])
-	if e.p.y.y.Cmp(P) >= 0 {
-		return nil, errors.New("bn256: coordinate exceeds modulus")
-	}
-	// Ensure the point is on the curve
-	if e.p.x.x.Sign() == 0 &&
-		e.p.x.y.Sign() == 0 &&
-		e.p.y.x.Sign() == 0 &&
-		e.p.y.y.Sign() == 0 {
-		// This is the point at infinity.
-		e.p.y.SetOne()
-		e.p.z.SetZero()
-		e.p.t.SetZero()
-	} else {
-		e.p.z.SetOne()
-		e.p.t.SetOne()
-
-		if !e.p.IsOnCurve() {
-			return nil, errors.New("bn256: malformed point")
-		}
-	}
-	return m[4*numBytes:], nil
-}
-
-// GT is an abstract cyclic group. The zero value is suitable for use as the
-// output of an operation, but cannot be used as an input.
-type GT struct {
-	p *gfP12
-}
-
-func (g *GT) String() string {
-	return "bn256.GT" + g.p.String()
-}
-
-// ScalarMult sets e to a*k and then returns e.
-func (e *GT) ScalarMult(a *GT, k *big.Int) *GT {
-	if e.p == nil {
-		e.p = newGFp12(nil)
-	}
-	e.p.Exp(a.p, k, new(bnPool))
-	return e
-}
-
-// Add sets e to a+b and then returns e.
-func (e *GT) Add(a, b *GT) *GT {
-	if e.p == nil {
-		e.p = newGFp12(nil)
-	}
-	e.p.Mul(a.p, b.p, new(bnPool))
-	return e
-}
-
-// Neg sets e to -a and then returns e.
-func (e *GT) Neg(a *GT) *GT {
-	if e.p == nil {
-		e.p = newGFp12(nil)
-	}
-	e.p.Invert(a.p, new(bnPool))
-	return e
-}
-
-// Marshal converts n into a byte slice.
-func (n *GT) Marshal() []byte {
-	n.p.Minimal()
-
-	xxxBytes := n.p.x.x.x.Bytes()
-	xxyBytes := n.p.x.x.y.Bytes()
-	xyxBytes := n.p.x.y.x.Bytes()
-	xyyBytes := n.p.x.y.y.Bytes()
-	xzxBytes := n.p.x.z.x.Bytes()
-	xzyBytes := n.p.x.z.y.Bytes()
-	yxxBytes := n.p.y.x.x.Bytes()
-	yxyBytes := n.p.y.x.y.Bytes()
-	yyxBytes := n.p.y.y.x.Bytes()
-	yyyBytes := n.p.y.y.y.Bytes()
-	yzxBytes := n.p.y.z.x.Bytes()
-	yzyBytes := n.p.y.z.y.Bytes()
-
-	// Each value is a 256-bit number.
-	const numBytes = 256 / 8
-
-	ret := make([]byte, numBytes*12)
-	copy(ret[1*numBytes-len(xxxBytes):], xxxBytes)
-	copy(ret[2*numBytes-len(xxyBytes):], xxyBytes)
-	copy(ret[3*numBytes-len(xyxBytes):], xyxBytes)
-	copy(ret[4*numBytes-len(xyyBytes):], xyyBytes)
-	copy(ret[5*numBytes-len(xzxBytes):], xzxBytes)
-	copy(ret[6*numBytes-len(xzyBytes):], xzyBytes)
-	copy(ret[7*numBytes-len(yxxBytes):], yxxBytes)
-	copy(ret[8*numBytes-len(yxyBytes):], yxyBytes)
-	copy(ret[9*numBytes-len(yyxBytes):], yyxBytes)
-	copy(ret[10*numBytes-len(yyyBytes):], yyyBytes)
-	copy(ret[11*numBytes-len(yzxBytes):], yzxBytes)
-	copy(ret[12*numBytes-len(yzyBytes):], yzyBytes)
-
-	return ret
-}
-
-// Unmarshal sets e to the result of converting the output of Marshal back into
-// a group element and then returns e.
-func (e *GT) Unmarshal(m []byte) (*GT, bool) {
-	// Each value is a 256-bit number.
-	const numBytes = 256 / 8
-
-	if len(m) != 12*numBytes {
-		return nil, false
-	}
-
-	if e.p == nil {
-		e.p = newGFp12(nil)
-	}
-
-	e.p.x.x.x.SetBytes(m[0*numBytes : 1*numBytes])
-	e.p.x.x.y.SetBytes(m[1*numBytes : 2*numBytes])
-	e.p.x.y.x.SetBytes(m[2*numBytes : 3*numBytes])
-	e.p.x.y.y.SetBytes(m[3*numBytes : 4*numBytes])
-	e.p.x.z.x.SetBytes(m[4*numBytes : 5*numBytes])
-	e.p.x.z.y.SetBytes(m[5*numBytes : 6*numBytes])
-	e.p.y.x.x.SetBytes(m[6*numBytes : 7*numBytes])
-	e.p.y.x.y.SetBytes(m[7*numBytes : 8*numBytes])
-	e.p.y.y.x.SetBytes(m[8*numBytes : 9*numBytes])
-	e.p.y.y.y.SetBytes(m[9*numBytes : 10*numBytes])
-	e.p.y.z.x.SetBytes(m[10*numBytes : 11*numBytes])
-	e.p.y.z.y.SetBytes(m[11*numBytes : 12*numBytes])
-
-	return e, true
-}
-
-// Pair calculates an Optimal Ate pairing.
-func Pair(g1 *G1, g2 *G2) *GT {
-	return &GT{optimalAte(g2.p, g1.p, new(bnPool))}
-}
-
-// PairingCheck calculates the Optimal Ate pairing for a set of points.
-func PairingCheck(a []*G1, b []*G2) bool {
-	pool := new(bnPool)
-
-	acc := newGFp12(pool)
-	acc.SetOne()
-
-	for i := 0; i < len(a); i++ {
-		if a[i].p.IsInfinity() || b[i].p.IsInfinity() {
-			continue
-		}
-		acc.Mul(acc, miller(b[i].p, a[i].p, pool), pool)
-	}
-	ret := finalExponentiation(acc, pool)
-	acc.Put(pool)
-
-	return ret.IsOne()
-}
-
-// bnPool implements a tiny cache of *big.Int objects that's used to reduce the
-// number of allocations made during processing.
-type bnPool struct {
-	bns   []*big.Int
-	count int
-}
-
-func (pool *bnPool) Get() *big.Int {
-	if pool == nil {
-		return new(big.Int)
-	}
-
-	pool.count++
-	l := len(pool.bns)
-	if l == 0 {
-		return new(big.Int)
-	}
-
-	bn := pool.bns[l-1]
-	pool.bns = pool.bns[:l-1]
-	return bn
-}
-
-func (pool *bnPool) Put(bn *big.Int) {
-	if pool == nil {
-		return
-	}
-	pool.bns = append(pool.bns, bn)
-	pool.count--
-}
-
-func (pool *bnPool) Count() int {
-	return pool.count
-}
diff --git a/crypto/bn256/google/bn256_test.go b/crypto/bn256/google/bn256_test.go
deleted file mode 100644
index a4497ada9..000000000
--- a/crypto/bn256/google/bn256_test.go
+++ /dev/null
@@ -1,311 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package bn256
-
-import (
-	"bytes"
-	"crypto/rand"
-	"math/big"
-	"testing"
-)
-
-func TestGFp2Invert(t *testing.T) {
-	pool := new(bnPool)
-
-	a := newGFp2(pool)
-	a.x.SetString("23423492374", 10)
-	a.y.SetString("12934872398472394827398470", 10)
-
-	inv := newGFp2(pool)
-	inv.Invert(a, pool)
-
-	b := newGFp2(pool).Mul(inv, a, pool)
-	if b.x.Int64() != 0 || b.y.Int64() != 1 {
-		t.Fatalf("bad result for a^-1*a: %s %s", b.x, b.y)
-	}
-
-	a.Put(pool)
-	b.Put(pool)
-	inv.Put(pool)
-
-	if c := pool.Count(); c > 0 {
-		t.Errorf("Pool count non-zero: %d\n", c)
-	}
-}
-
-func isZero(n *big.Int) bool {
-	return new(big.Int).Mod(n, P).Int64() == 0
-}
-
-func isOne(n *big.Int) bool {
-	return new(big.Int).Mod(n, P).Int64() == 1
-}
-
-func TestGFp6Invert(t *testing.T) {
-	pool := new(bnPool)
-
-	a := newGFp6(pool)
-	a.x.x.SetString("239487238491", 10)
-	a.x.y.SetString("2356249827341", 10)
-	a.y.x.SetString("082659782", 10)
-	a.y.y.SetString("182703523765", 10)
-	a.z.x.SetString("978236549263", 10)
-	a.z.y.SetString("64893242", 10)
-
-	inv := newGFp6(pool)
-	inv.Invert(a, pool)
-
-	b := newGFp6(pool).Mul(inv, a, pool)
-	if !isZero(b.x.x) ||
-		!isZero(b.x.y) ||
-		!isZero(b.y.x) ||
-		!isZero(b.y.y) ||
-		!isZero(b.z.x) ||
-		!isOne(b.z.y) {
-		t.Fatalf("bad result for a^-1*a: %s", b)
-	}
-
-	a.Put(pool)
-	b.Put(pool)
-	inv.Put(pool)
-
-	if c := pool.Count(); c > 0 {
-		t.Errorf("Pool count non-zero: %d\n", c)
-	}
-}
-
-func TestGFp12Invert(t *testing.T) {
-	pool := new(bnPool)
-
-	a := newGFp12(pool)
-	a.x.x.x.SetString("239846234862342323958623", 10)
-	a.x.x.y.SetString("2359862352529835623", 10)
-	a.x.y.x.SetString("928836523", 10)
-	a.x.y.y.SetString("9856234", 10)
-	a.x.z.x.SetString("235635286", 10)
-	a.x.z.y.SetString("5628392833", 10)
-	a.y.x.x.SetString("252936598265329856238956532167968", 10)
-	a.y.x.y.SetString("23596239865236954178968", 10)
-	a.y.y.x.SetString("95421692834", 10)
-	a.y.y.y.SetString("236548", 10)
-	a.y.z.x.SetString("924523", 10)
-	a.y.z.y.SetString("12954623", 10)
-
-	inv := newGFp12(pool)
-	inv.Invert(a, pool)
-
-	b := newGFp12(pool).Mul(inv, a, pool)
-	if !isZero(b.x.x.x) ||
-		!isZero(b.x.x.y) ||
-		!isZero(b.x.y.x) ||
-		!isZero(b.x.y.y) ||
-		!isZero(b.x.z.x) ||
-		!isZero(b.x.z.y) ||
-		!isZero(b.y.x.x) ||
-		!isZero(b.y.x.y) ||
-		!isZero(b.y.y.x) ||
-		!isZero(b.y.y.y) ||
-		!isZero(b.y.z.x) ||
-		!isOne(b.y.z.y) {
-		t.Fatalf("bad result for a^-1*a: %s", b)
-	}
-
-	a.Put(pool)
-	b.Put(pool)
-	inv.Put(pool)
-
-	if c := pool.Count(); c > 0 {
-		t.Errorf("Pool count non-zero: %d\n", c)
-	}
-}
-
-func TestCurveImpl(t *testing.T) {
-	pool := new(bnPool)
-
-	g := &curvePoint{
-		pool.Get().SetInt64(1),
-		pool.Get().SetInt64(-2),
-		pool.Get().SetInt64(1),
-		pool.Get().SetInt64(0),
-	}
-
-	x := pool.Get().SetInt64(32498273234)
-	X := newCurvePoint(pool).Mul(g, x, pool)
-
-	y := pool.Get().SetInt64(98732423523)
-	Y := newCurvePoint(pool).Mul(g, y, pool)
-
-	s1 := newCurvePoint(pool).Mul(X, y, pool).MakeAffine(pool)
-	s2 := newCurvePoint(pool).Mul(Y, x, pool).MakeAffine(pool)
-
-	if s1.x.Cmp(s2.x) != 0 ||
-		s2.x.Cmp(s1.x) != 0 {
-		t.Errorf("DH points don't match: (%s, %s) (%s, %s)", s1.x, s1.y, s2.x, s2.y)
-	}
-
-	pool.Put(x)
-	X.Put(pool)
-	pool.Put(y)
-	Y.Put(pool)
-	s1.Put(pool)
-	s2.Put(pool)
-	g.Put(pool)
-
-	if c := pool.Count(); c > 0 {
-		t.Errorf("Pool count non-zero: %d\n", c)
-	}
-}
-
-func TestOrderG1(t *testing.T) {
-	g := new(G1).ScalarBaseMult(Order)
-	if !g.p.IsInfinity() {
-		t.Error("G1 has incorrect order")
-	}
-
-	one := new(G1).ScalarBaseMult(new(big.Int).SetInt64(1))
-	g.Add(g, one)
-	g.p.MakeAffine(nil)
-	if g.p.x.Cmp(one.p.x) != 0 || g.p.y.Cmp(one.p.y) != 0 {
-		t.Errorf("1+0 != 1 in G1")
-	}
-}
-
-func TestOrderG2(t *testing.T) {
-	g := new(G2).ScalarBaseMult(Order)
-	if !g.p.IsInfinity() {
-		t.Error("G2 has incorrect order")
-	}
-
-	one := new(G2).ScalarBaseMult(new(big.Int).SetInt64(1))
-	g.Add(g, one)
-	g.p.MakeAffine(nil)
-	if g.p.x.x.Cmp(one.p.x.x) != 0 ||
-		g.p.x.y.Cmp(one.p.x.y) != 0 ||
-		g.p.y.x.Cmp(one.p.y.x) != 0 ||
-		g.p.y.y.Cmp(one.p.y.y) != 0 {
-		t.Errorf("1+0 != 1 in G2")
-	}
-}
-
-func TestOrderGT(t *testing.T) {
-	gt := Pair(&G1{curveGen}, &G2{twistGen})
-	g := new(GT).ScalarMult(gt, Order)
-	if !g.p.IsOne() {
-		t.Error("GT has incorrect order")
-	}
-}
-
-func TestBilinearity(t *testing.T) {
-	for i := 0; i < 2; i++ {
-		a, p1, _ := RandomG1(rand.Reader)
-		b, p2, _ := RandomG2(rand.Reader)
-		e1 := Pair(p1, p2)
-
-		e2 := Pair(&G1{curveGen}, &G2{twistGen})
-		e2.ScalarMult(e2, a)
-		e2.ScalarMult(e2, b)
-
-		minusE2 := new(GT).Neg(e2)
-		e1.Add(e1, minusE2)
-
-		if !e1.p.IsOne() {
-			t.Fatalf("bad pairing result: %s", e1)
-		}
-	}
-}
-
-func TestG1Marshal(t *testing.T) {
-	g := new(G1).ScalarBaseMult(new(big.Int).SetInt64(1))
-	form := g.Marshal()
-	_, err := new(G1).Unmarshal(form)
-	if err != nil {
-		t.Fatalf("failed to unmarshal")
-	}
-
-	g.ScalarBaseMult(Order)
-	form = g.Marshal()
-
-	g2 := new(G1)
-	if _, err = g2.Unmarshal(form); err != nil {
-		t.Fatalf("failed to unmarshal ∞")
-	}
-	if !g2.p.IsInfinity() {
-		t.Fatalf("∞ unmarshaled incorrectly")
-	}
-}
-
-func TestG2Marshal(t *testing.T) {
-	g := new(G2).ScalarBaseMult(new(big.Int).SetInt64(1))
-	form := g.Marshal()
-	_, err := new(G2).Unmarshal(form)
-	if err != nil {
-		t.Fatalf("failed to unmarshal")
-	}
-
-	g.ScalarBaseMult(Order)
-	form = g.Marshal()
-	g2 := new(G2)
-	if _, err = g2.Unmarshal(form); err != nil {
-		t.Fatalf("failed to unmarshal ∞")
-	}
-	if !g2.p.IsInfinity() {
-		t.Fatalf("∞ unmarshaled incorrectly")
-	}
-}
-
-func TestG1Identity(t *testing.T) {
-	g := new(G1).ScalarBaseMult(new(big.Int).SetInt64(0))
-	if !g.p.IsInfinity() {
-		t.Error("failure")
-	}
-}
-
-func TestG2Identity(t *testing.T) {
-	g := new(G2).ScalarBaseMult(new(big.Int).SetInt64(0))
-	if !g.p.IsInfinity() {
-		t.Error("failure")
-	}
-}
-
-func TestTripartiteDiffieHellman(t *testing.T) {
-	a, _ := rand.Int(rand.Reader, Order)
-	b, _ := rand.Int(rand.Reader, Order)
-	c, _ := rand.Int(rand.Reader, Order)
-
-	pa := new(G1)
-	pa.Unmarshal(new(G1).ScalarBaseMult(a).Marshal())
-	qa := new(G2)
-	qa.Unmarshal(new(G2).ScalarBaseMult(a).Marshal())
-	pb := new(G1)
-	pb.Unmarshal(new(G1).ScalarBaseMult(b).Marshal())
-	qb := new(G2)
-	qb.Unmarshal(new(G2).ScalarBaseMult(b).Marshal())
-	pc := new(G1)
-	pc.Unmarshal(new(G1).ScalarBaseMult(c).Marshal())
-	qc := new(G2)
-	qc.Unmarshal(new(G2).ScalarBaseMult(c).Marshal())
-
-	k1 := Pair(pb, qc)
-	k1.ScalarMult(k1, a)
-	k1Bytes := k1.Marshal()
-
-	k2 := Pair(pc, qa)
-	k2.ScalarMult(k2, b)
-	k2Bytes := k2.Marshal()
-
-	k3 := Pair(pa, qb)
-	k3.ScalarMult(k3, c)
-	k3Bytes := k3.Marshal()
-
-	if !bytes.Equal(k1Bytes, k2Bytes) || !bytes.Equal(k2Bytes, k3Bytes) {
-		t.Errorf("keys didn't agree")
-	}
-}
-
-func BenchmarkPairing(b *testing.B) {
-	for i := 0; i < b.N; i++ {
-		Pair(&G1{curveGen}, &G2{twistGen})
-	}
-}
diff --git a/crypto/bn256/google/constants.go b/crypto/bn256/google/constants.go
deleted file mode 100644
index 2990bd951..000000000
--- a/crypto/bn256/google/constants.go
+++ /dev/null
@@ -1,47 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package bn256
-
-import (
-	"math/big"
-)
-
-func bigFromBase10(s string) *big.Int {
-	n, _ := new(big.Int).SetString(s, 10)
-	return n
-}
-
-// u is the BN parameter that determines the prime.
-var u = bigFromBase10("4965661367192848881")
-
-// P is a prime over which we form a basic field: 36u⁴+36u³+24u²+6u+1.
-var P = bigFromBase10("21888242871839275222246405745257275088696311157297823662689037894645226208583")
-
-// Order is the number of elements in both G₁ and G₂: 36u⁴+36u³+18u²+6u+1.
-// Needs to be highly 2-adic for efficient SNARK key and proof generation.
-// Order - 1 = 2^28 * 3^2 * 13 * 29 * 983 * 11003 * 237073 * 405928799 * 1670836401704629 * 13818364434197438864469338081.
-// Refer to https://eprint.iacr.org/2013/879.pdf and https://eprint.iacr.org/2013/507.pdf for more information on these parameters.
-var Order = bigFromBase10("21888242871839275222246405745257275088548364400416034343698204186575808495617")
-
-// xiToPMinus1Over6 is ξ^((p-1)/6) where ξ = i+9.
-var xiToPMinus1Over6 = &gfP2{bigFromBase10("16469823323077808223889137241176536799009286646108169935659301613961712198316"), bigFromBase10("8376118865763821496583973867626364092589906065868298776909617916018768340080")}
-
-// xiToPMinus1Over3 is ξ^((p-1)/3) where ξ = i+9.
-var xiToPMinus1Over3 = &gfP2{bigFromBase10("10307601595873709700152284273816112264069230130616436755625194854815875713954"), bigFromBase10("21575463638280843010398324269430826099269044274347216827212613867836435027261")}
-
-// xiToPMinus1Over2 is ξ^((p-1)/2) where ξ = i+9.
-var xiToPMinus1Over2 = &gfP2{bigFromBase10("3505843767911556378687030309984248845540243509899259641013678093033130930403"), bigFromBase10("2821565182194536844548159561693502659359617185244120367078079554186484126554")}
-
-// xiToPSquaredMinus1Over3 is ξ^((p²-1)/3) where ξ = i+9.
-var xiToPSquaredMinus1Over3 = bigFromBase10("21888242871839275220042445260109153167277707414472061641714758635765020556616")
-
-// xiTo2PSquaredMinus2Over3 is ξ^((2p²-2)/3) where ξ = i+9 (a cubic root of unity, mod p).
-var xiTo2PSquaredMinus2Over3 = bigFromBase10("2203960485148121921418603742825762020974279258880205651966")
-
-// xiToPSquaredMinus1Over6 is ξ^((1p²-1)/6) where ξ = i+9 (a cubic root of -1, mod p).
-var xiToPSquaredMinus1Over6 = bigFromBase10("21888242871839275220042445260109153167277707414472061641714758635765020556617")
-
-// xiTo2PMinus2Over3 is ξ^((2p-2)/3) where ξ = i+9.
-var xiTo2PMinus2Over3 = &gfP2{bigFromBase10("19937756971775647987995932169929341994314640652964949448313374472400716661030"), bigFromBase10("2581911344467009335267311115468803099551665605076196740867805258568234346338")}
diff --git a/crypto/bn256/google/curve.go b/crypto/bn256/google/curve.go
deleted file mode 100644
index 819cb81da..000000000
--- a/crypto/bn256/google/curve.go
+++ /dev/null
@@ -1,286 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package bn256
-
-import (
-	"math/big"
-)
-
-// curvePoint implements the elliptic curve y²=x³+3. Points are kept in
-// Jacobian form and t=z² when valid. G₁ is the set of points of this curve on
-// GF(p).
-type curvePoint struct {
-	x, y, z, t *big.Int
-}
-
-var curveB = new(big.Int).SetInt64(3)
-
-// curveGen is the generator of G₁.
-var curveGen = &curvePoint{
-	new(big.Int).SetInt64(1),
-	new(big.Int).SetInt64(2),
-	new(big.Int).SetInt64(1),
-	new(big.Int).SetInt64(1),
-}
-
-func newCurvePoint(pool *bnPool) *curvePoint {
-	return &curvePoint{
-		pool.Get(),
-		pool.Get(),
-		pool.Get(),
-		pool.Get(),
-	}
-}
-
-func (c *curvePoint) String() string {
-	c.MakeAffine(new(bnPool))
-	return "(" + c.x.String() + ", " + c.y.String() + ")"
-}
-
-func (c *curvePoint) Put(pool *bnPool) {
-	pool.Put(c.x)
-	pool.Put(c.y)
-	pool.Put(c.z)
-	pool.Put(c.t)
-}
-
-func (c *curvePoint) Set(a *curvePoint) {
-	c.x.Set(a.x)
-	c.y.Set(a.y)
-	c.z.Set(a.z)
-	c.t.Set(a.t)
-}
-
-// IsOnCurve returns true iff c is on the curve where c must be in affine form.
-func (c *curvePoint) IsOnCurve() bool {
-	yy := new(big.Int).Mul(c.y, c.y)
-	xxx := new(big.Int).Mul(c.x, c.x)
-	xxx.Mul(xxx, c.x)
-	yy.Sub(yy, xxx)
-	yy.Sub(yy, curveB)
-	if yy.Sign() < 0 || yy.Cmp(P) >= 0 {
-		yy.Mod(yy, P)
-	}
-	return yy.Sign() == 0
-}
-
-func (c *curvePoint) SetInfinity() {
-	c.z.SetInt64(0)
-}
-
-func (c *curvePoint) IsInfinity() bool {
-	return c.z.Sign() == 0
-}
-
-func (c *curvePoint) Add(a, b *curvePoint, pool *bnPool) {
-	if a.IsInfinity() {
-		c.Set(b)
-		return
-	}
-	if b.IsInfinity() {
-		c.Set(a)
-		return
-	}
-
-	// See http://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/addition/add-2007-bl.op3
-
-	// Normalize the points by replacing a = [x1:y1:z1] and b = [x2:y2:z2]
-	// by [u1:s1:z1·z2] and [u2:s2:z1·z2]
-	// where u1 = x1·z2², s1 = y1·z2³ and u1 = x2·z1², s2 = y2·z1³
-	z1z1 := pool.Get().Mul(a.z, a.z)
-	z1z1.Mod(z1z1, P)
-	z2z2 := pool.Get().Mul(b.z, b.z)
-	z2z2.Mod(z2z2, P)
-	u1 := pool.Get().Mul(a.x, z2z2)
-	u1.Mod(u1, P)
-	u2 := pool.Get().Mul(b.x, z1z1)
-	u2.Mod(u2, P)
-
-	t := pool.Get().Mul(b.z, z2z2)
-	t.Mod(t, P)
-	s1 := pool.Get().Mul(a.y, t)
-	s1.Mod(s1, P)
-
-	t.Mul(a.z, z1z1)
-	t.Mod(t, P)
-	s2 := pool.Get().Mul(b.y, t)
-	s2.Mod(s2, P)
-
-	// Compute x = (2h)²(s²-u1-u2)
-	// where s = (s2-s1)/(u2-u1) is the slope of the line through
-	// (u1,s1) and (u2,s2). The extra factor 2h = 2(u2-u1) comes from the value of z below.
-	// This is also:
-	// 4(s2-s1)² - 4h²(u1+u2) = 4(s2-s1)² - 4h³ - 4h²(2u1)
-	//                        = r² - j - 2v
-	// with the notations below.
-	h := pool.Get().Sub(u2, u1)
-	xEqual := h.Sign() == 0
-
-	t.Add(h, h)
-	// i = 4h²
-	i := pool.Get().Mul(t, t)
-	i.Mod(i, P)
-	// j = 4h³
-	j := pool.Get().Mul(h, i)
-	j.Mod(j, P)
-
-	t.Sub(s2, s1)
-	yEqual := t.Sign() == 0
-	if xEqual && yEqual {
-		c.Double(a, pool)
-		return
-	}
-	r := pool.Get().Add(t, t)
-
-	v := pool.Get().Mul(u1, i)
-	v.Mod(v, P)
-
-	// t4 = 4(s2-s1)²
-	t4 := pool.Get().Mul(r, r)
-	t4.Mod(t4, P)
-	t.Add(v, v)
-	t6 := pool.Get().Sub(t4, j)
-	c.x.Sub(t6, t)
-
-	// Set y = -(2h)³(s1 + s*(x/4h²-u1))
-	// This is also
-	// y = - 2·s1·j - (s2-s1)(2x - 2i·u1) = r(v-x) - 2·s1·j
-	t.Sub(v, c.x) // t7
-	t4.Mul(s1, j) // t8
-	t4.Mod(t4, P)
-	t6.Add(t4, t4) // t9
-	t4.Mul(r, t)   // t10
-	t4.Mod(t4, P)
-	c.y.Sub(t4, t6)
-
-	// Set z = 2(u2-u1)·z1·z2 = 2h·z1·z2
-	t.Add(a.z, b.z) // t11
-	t4.Mul(t, t)    // t12
-	t4.Mod(t4, P)
-	t.Sub(t4, z1z1) // t13
-	t4.Sub(t, z2z2) // t14
-	c.z.Mul(t4, h)
-	c.z.Mod(c.z, P)
-
-	pool.Put(z1z1)
-	pool.Put(z2z2)
-	pool.Put(u1)
-	pool.Put(u2)
-	pool.Put(t)
-	pool.Put(s1)
-	pool.Put(s2)
-	pool.Put(h)
-	pool.Put(i)
-	pool.Put(j)
-	pool.Put(r)
-	pool.Put(v)
-	pool.Put(t4)
-	pool.Put(t6)
-}
-
-func (c *curvePoint) Double(a *curvePoint, pool *bnPool) {
-	// See http://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/doubling/dbl-2009-l.op3
-	A := pool.Get().Mul(a.x, a.x)
-	A.Mod(A, P)
-	B := pool.Get().Mul(a.y, a.y)
-	B.Mod(B, P)
-	C_ := pool.Get().Mul(B, B)
-	C_.Mod(C_, P)
-
-	t := pool.Get().Add(a.x, B)
-	t2 := pool.Get().Mul(t, t)
-	t2.Mod(t2, P)
-	t.Sub(t2, A)
-	t2.Sub(t, C_)
-	d := pool.Get().Add(t2, t2)
-	t.Add(A, A)
-	e := pool.Get().Add(t, A)
-	f := pool.Get().Mul(e, e)
-	f.Mod(f, P)
-
-	t.Add(d, d)
-	c.x.Sub(f, t)
-
-	t.Add(C_, C_)
-	t2.Add(t, t)
-	t.Add(t2, t2)
-	c.y.Sub(d, c.x)
-	t2.Mul(e, c.y)
-	t2.Mod(t2, P)
-	c.y.Sub(t2, t)
-
-	t.Mul(a.y, a.z)
-	t.Mod(t, P)
-	c.z.Add(t, t)
-
-	pool.Put(A)
-	pool.Put(B)
-	pool.Put(C_)
-	pool.Put(t)
-	pool.Put(t2)
-	pool.Put(d)
-	pool.Put(e)
-	pool.Put(f)
-}
-
-func (c *curvePoint) Mul(a *curvePoint, scalar *big.Int, pool *bnPool) *curvePoint {
-	sum := newCurvePoint(pool)
-	sum.SetInfinity()
-	t := newCurvePoint(pool)
-
-	for i := scalar.BitLen(); i >= 0; i-- {
-		t.Double(sum, pool)
-		if scalar.Bit(i) != 0 {
-			sum.Add(t, a, pool)
-		} else {
-			sum.Set(t)
-		}
-	}
-
-	c.Set(sum)
-	sum.Put(pool)
-	t.Put(pool)
-	return c
-}
-
-// MakeAffine converts c to affine form and returns c. If c is ∞, then it sets
-// c to 0 : 1 : 0.
-func (c *curvePoint) MakeAffine(pool *bnPool) *curvePoint {
-	if words := c.z.Bits(); len(words) == 1 && words[0] == 1 {
-		return c
-	}
-	if c.IsInfinity() {
-		c.x.SetInt64(0)
-		c.y.SetInt64(1)
-		c.z.SetInt64(0)
-		c.t.SetInt64(0)
-		return c
-	}
-	zInv := pool.Get().ModInverse(c.z, P)
-	t := pool.Get().Mul(c.y, zInv)
-	t.Mod(t, P)
-	zInv2 := pool.Get().Mul(zInv, zInv)
-	zInv2.Mod(zInv2, P)
-	c.y.Mul(t, zInv2)
-	c.y.Mod(c.y, P)
-	t.Mul(c.x, zInv2)
-	t.Mod(t, P)
-	c.x.Set(t)
-	c.z.SetInt64(1)
-	c.t.SetInt64(1)
-
-	pool.Put(zInv)
-	pool.Put(t)
-	pool.Put(zInv2)
-
-	return c
-}
-
-func (c *curvePoint) Negative(a *curvePoint) {
-	c.x.Set(a.x)
-	c.y.Neg(a.y)
-	c.z.Set(a.z)
-	c.t.SetInt64(0)
-}
diff --git a/crypto/bn256/google/example_test.go b/crypto/bn256/google/example_test.go
deleted file mode 100644
index b2d19807a..000000000
--- a/crypto/bn256/google/example_test.go
+++ /dev/null
@@ -1,43 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package bn256
-
-import (
-	"crypto/rand"
-)
-
-func ExamplePair() {
-	// This implements the tripartite Diffie-Hellman algorithm from "A One
-	// Round Protocol for Tripartite Diffie-Hellman", A. Joux.
-	// http://www.springerlink.com/content/cddc57yyva0hburb/fulltext.pdf
-
-	// Each of three parties, a, b and c, generate a private value.
-	a, _ := rand.Int(rand.Reader, Order)
-	b, _ := rand.Int(rand.Reader, Order)
-	c, _ := rand.Int(rand.Reader, Order)
-
-	// Then each party calculates g₁ and g₂ times their private value.
-	pa := new(G1).ScalarBaseMult(a)
-	qa := new(G2).ScalarBaseMult(a)
-
-	pb := new(G1).ScalarBaseMult(b)
-	qb := new(G2).ScalarBaseMult(b)
-
-	pc := new(G1).ScalarBaseMult(c)
-	qc := new(G2).ScalarBaseMult(c)
-
-	// Now each party exchanges its public values with the other two and
-	// all parties can calculate the shared key.
-	k1 := Pair(pb, qc)
-	k1.ScalarMult(k1, a)
-
-	k2 := Pair(pc, qa)
-	k2.ScalarMult(k2, b)
-
-	k3 := Pair(pa, qb)
-	k3.ScalarMult(k3, c)
-
-	// k1, k2 and k3 will all be equal.
-}
diff --git a/crypto/bn256/google/gfp12.go b/crypto/bn256/google/gfp12.go
deleted file mode 100644
index f084eddf2..000000000
--- a/crypto/bn256/google/gfp12.go
+++ /dev/null
@@ -1,200 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package bn256
-
-// For details of the algorithms used, see "Multiplication and Squaring on
-// Pairing-Friendly Fields, Devegili et al.
-// http://eprint.iacr.org/2006/471.pdf.
-
-import (
-	"math/big"
-)
-
-// gfP12 implements the field of size p¹² as a quadratic extension of gfP6
-// where ω²=τ.
-type gfP12 struct {
-	x, y *gfP6 // value is xω + y
-}
-
-func newGFp12(pool *bnPool) *gfP12 {
-	return &gfP12{newGFp6(pool), newGFp6(pool)}
-}
-
-func (e *gfP12) String() string {
-	return "(" + e.x.String() + "," + e.y.String() + ")"
-}
-
-func (e *gfP12) Put(pool *bnPool) {
-	e.x.Put(pool)
-	e.y.Put(pool)
-}
-
-func (e *gfP12) Set(a *gfP12) *gfP12 {
-	e.x.Set(a.x)
-	e.y.Set(a.y)
-	return e
-}
-
-func (e *gfP12) SetZero() *gfP12 {
-	e.x.SetZero()
-	e.y.SetZero()
-	return e
-}
-
-func (e *gfP12) SetOne() *gfP12 {
-	e.x.SetZero()
-	e.y.SetOne()
-	return e
-}
-
-func (e *gfP12) Minimal() {
-	e.x.Minimal()
-	e.y.Minimal()
-}
-
-func (e *gfP12) IsZero() bool {
-	e.Minimal()
-	return e.x.IsZero() && e.y.IsZero()
-}
-
-func (e *gfP12) IsOne() bool {
-	e.Minimal()
-	return e.x.IsZero() && e.y.IsOne()
-}
-
-func (e *gfP12) Conjugate(a *gfP12) *gfP12 {
-	e.x.Negative(a.x)
-	e.y.Set(a.y)
-	return a
-}
-
-func (e *gfP12) Negative(a *gfP12) *gfP12 {
-	e.x.Negative(a.x)
-	e.y.Negative(a.y)
-	return e
-}
-
-// Frobenius computes (xω+y)^p = x^p ω·ξ^((p-1)/6) + y^p
-func (e *gfP12) Frobenius(a *gfP12, pool *bnPool) *gfP12 {
-	e.x.Frobenius(a.x, pool)
-	e.y.Frobenius(a.y, pool)
-	e.x.MulScalar(e.x, xiToPMinus1Over6, pool)
-	return e
-}
-
-// FrobeniusP2 computes (xω+y)^p² = x^p² ω·ξ^((p²-1)/6) + y^p²
-func (e *gfP12) FrobeniusP2(a *gfP12, pool *bnPool) *gfP12 {
-	e.x.FrobeniusP2(a.x)
-	e.x.MulGFP(e.x, xiToPSquaredMinus1Over6)
-	e.y.FrobeniusP2(a.y)
-	return e
-}
-
-func (e *gfP12) Add(a, b *gfP12) *gfP12 {
-	e.x.Add(a.x, b.x)
-	e.y.Add(a.y, b.y)
-	return e
-}
-
-func (e *gfP12) Sub(a, b *gfP12) *gfP12 {
-	e.x.Sub(a.x, b.x)
-	e.y.Sub(a.y, b.y)
-	return e
-}
-
-func (e *gfP12) Mul(a, b *gfP12, pool *bnPool) *gfP12 {
-	tx := newGFp6(pool)
-	tx.Mul(a.x, b.y, pool)
-	t := newGFp6(pool)
-	t.Mul(b.x, a.y, pool)
-	tx.Add(tx, t)
-
-	ty := newGFp6(pool)
-	ty.Mul(a.y, b.y, pool)
-	t.Mul(a.x, b.x, pool)
-	t.MulTau(t, pool)
-	e.y.Add(ty, t)
-	e.x.Set(tx)
-
-	tx.Put(pool)
-	ty.Put(pool)
-	t.Put(pool)
-	return e
-}
-
-func (e *gfP12) MulScalar(a *gfP12, b *gfP6, pool *bnPool) *gfP12 {
-	e.x.Mul(e.x, b, pool)
-	e.y.Mul(e.y, b, pool)
-	return e
-}
-
-func (c *gfP12) Exp(a *gfP12, power *big.Int, pool *bnPool) *gfP12 {
-	sum := newGFp12(pool)
-	sum.SetOne()
-	t := newGFp12(pool)
-
-	for i := power.BitLen() - 1; i >= 0; i-- {
-		t.Square(sum, pool)
-		if power.Bit(i) != 0 {
-			sum.Mul(t, a, pool)
-		} else {
-			sum.Set(t)
-		}
-	}
-
-	c.Set(sum)
-
-	sum.Put(pool)
-	t.Put(pool)
-
-	return c
-}
-
-func (e *gfP12) Square(a *gfP12, pool *bnPool) *gfP12 {
-	// Complex squaring algorithm
-	v0 := newGFp6(pool)
-	v0.Mul(a.x, a.y, pool)
-
-	t := newGFp6(pool)
-	t.MulTau(a.x, pool)
-	t.Add(a.y, t)
-	ty := newGFp6(pool)
-	ty.Add(a.x, a.y)
-	ty.Mul(ty, t, pool)
-	ty.Sub(ty, v0)
-	t.MulTau(v0, pool)
-	ty.Sub(ty, t)
-
-	e.y.Set(ty)
-	e.x.Double(v0)
-
-	v0.Put(pool)
-	t.Put(pool)
-	ty.Put(pool)
-
-	return e
-}
-
-func (e *gfP12) Invert(a *gfP12, pool *bnPool) *gfP12 {
-	// See "Implementing cryptographic pairings", M. Scott, section 3.2.
-	// ftp://136.206.11.249/pub/crypto/pairings.pdf
-	t1 := newGFp6(pool)
-	t2 := newGFp6(pool)
-
-	t1.Square(a.x, pool)
-	t2.Square(a.y, pool)
-	t1.MulTau(t1, pool)
-	t1.Sub(t2, t1)
-	t2.Invert(t1, pool)
-
-	e.x.Negative(a.x)
-	e.y.Set(a.y)
-	e.MulScalar(e, t2, pool)
-
-	t1.Put(pool)
-	t2.Put(pool)
-
-	return e
-}
diff --git a/crypto/bn256/google/gfp2.go b/crypto/bn256/google/gfp2.go
deleted file mode 100644
index 3981f6cb4..000000000
--- a/crypto/bn256/google/gfp2.go
+++ /dev/null
@@ -1,227 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package bn256
-
-// For details of the algorithms used, see "Multiplication and Squaring on
-// Pairing-Friendly Fields, Devegili et al.
-// http://eprint.iacr.org/2006/471.pdf.
-
-import (
-	"math/big"
-)
-
-// gfP2 implements a field of size p² as a quadratic extension of the base
-// field where i²=-1.
-type gfP2 struct {
-	x, y *big.Int // value is xi+y.
-}
-
-func newGFp2(pool *bnPool) *gfP2 {
-	return &gfP2{pool.Get(), pool.Get()}
-}
-
-func (e *gfP2) String() string {
-	x := new(big.Int).Mod(e.x, P)
-	y := new(big.Int).Mod(e.y, P)
-	return "(" + x.String() + "," + y.String() + ")"
-}
-
-func (e *gfP2) Put(pool *bnPool) {
-	pool.Put(e.x)
-	pool.Put(e.y)
-}
-
-func (e *gfP2) Set(a *gfP2) *gfP2 {
-	e.x.Set(a.x)
-	e.y.Set(a.y)
-	return e
-}
-
-func (e *gfP2) SetZero() *gfP2 {
-	e.x.SetInt64(0)
-	e.y.SetInt64(0)
-	return e
-}
-
-func (e *gfP2) SetOne() *gfP2 {
-	e.x.SetInt64(0)
-	e.y.SetInt64(1)
-	return e
-}
-
-func (e *gfP2) Minimal() {
-	if e.x.Sign() < 0 || e.x.Cmp(P) >= 0 {
-		e.x.Mod(e.x, P)
-	}
-	if e.y.Sign() < 0 || e.y.Cmp(P) >= 0 {
-		e.y.Mod(e.y, P)
-	}
-}
-
-func (e *gfP2) IsZero() bool {
-	return e.x.Sign() == 0 && e.y.Sign() == 0
-}
-
-func (e *gfP2) IsOne() bool {
-	if e.x.Sign() != 0 {
-		return false
-	}
-	words := e.y.Bits()
-	return len(words) == 1 && words[0] == 1
-}
-
-func (e *gfP2) Conjugate(a *gfP2) *gfP2 {
-	e.y.Set(a.y)
-	e.x.Neg(a.x)
-	return e
-}
-
-func (e *gfP2) Negative(a *gfP2) *gfP2 {
-	e.x.Neg(a.x)
-	e.y.Neg(a.y)
-	return e
-}
-
-func (e *gfP2) Add(a, b *gfP2) *gfP2 {
-	e.x.Add(a.x, b.x)
-	e.y.Add(a.y, b.y)
-	return e
-}
-
-func (e *gfP2) Sub(a, b *gfP2) *gfP2 {
-	e.x.Sub(a.x, b.x)
-	e.y.Sub(a.y, b.y)
-	return e
-}
-
-func (e *gfP2) Double(a *gfP2) *gfP2 {
-	e.x.Lsh(a.x, 1)
-	e.y.Lsh(a.y, 1)
-	return e
-}
-
-func (c *gfP2) Exp(a *gfP2, power *big.Int, pool *bnPool) *gfP2 {
-	sum := newGFp2(pool)
-	sum.SetOne()
-	t := newGFp2(pool)
-
-	for i := power.BitLen() - 1; i >= 0; i-- {
-		t.Square(sum, pool)
-		if power.Bit(i) != 0 {
-			sum.Mul(t, a, pool)
-		} else {
-			sum.Set(t)
-		}
-	}
-
-	c.Set(sum)
-
-	sum.Put(pool)
-	t.Put(pool)
-
-	return c
-}
-
-// See "Multiplication and Squaring in Pairing-Friendly Fields",
-// http://eprint.iacr.org/2006/471.pdf
-func (e *gfP2) Mul(a, b *gfP2, pool *bnPool) *gfP2 {
-	tx := pool.Get().Mul(a.x, b.y)
-	t := pool.Get().Mul(b.x, a.y)
-	tx.Add(tx, t)
-	tx.Mod(tx, P)
-
-	ty := pool.Get().Mul(a.y, b.y)
-	t.Mul(a.x, b.x)
-	ty.Sub(ty, t)
-	e.y.Mod(ty, P)
-	e.x.Set(tx)
-
-	pool.Put(tx)
-	pool.Put(ty)
-	pool.Put(t)
-
-	return e
-}
-
-func (e *gfP2) MulScalar(a *gfP2, b *big.Int) *gfP2 {
-	e.x.Mul(a.x, b)
-	e.y.Mul(a.y, b)
-	return e
-}
-
-// MulXi sets e=ξa where ξ=i+9 and then returns e.
-func (e *gfP2) MulXi(a *gfP2, pool *bnPool) *gfP2 {
-	// (xi+y)(i+3) = (9x+y)i+(9y-x)
-	tx := pool.Get().Lsh(a.x, 3)
-	tx.Add(tx, a.x)
-	tx.Add(tx, a.y)
-
-	ty := pool.Get().Lsh(a.y, 3)
-	ty.Add(ty, a.y)
-	ty.Sub(ty, a.x)
-
-	e.x.Set(tx)
-	e.y.Set(ty)
-
-	pool.Put(tx)
-	pool.Put(ty)
-
-	return e
-}
-
-func (e *gfP2) Square(a *gfP2, pool *bnPool) *gfP2 {
-	// Complex squaring algorithm:
-	// (xi+b)² = (x+y)(y-x) + 2*i*x*y
-	t1 := pool.Get().Sub(a.y, a.x)
-	t2 := pool.Get().Add(a.x, a.y)
-	ty := pool.Get().Mul(t1, t2)
-	ty.Mod(ty, P)
-
-	t1.Mul(a.x, a.y)
-	t1.Lsh(t1, 1)
-
-	e.x.Mod(t1, P)
-	e.y.Set(ty)
-
-	pool.Put(t1)
-	pool.Put(t2)
-	pool.Put(ty)
-
-	return e
-}
-
-func (e *gfP2) Invert(a *gfP2, pool *bnPool) *gfP2 {
-	// See "Implementing cryptographic pairings", M. Scott, section 3.2.
-	// ftp://136.206.11.249/pub/crypto/pairings.pdf
-	t := pool.Get()
-	t.Mul(a.y, a.y)
-	t2 := pool.Get()
-	t2.Mul(a.x, a.x)
-	t.Add(t, t2)
-
-	inv := pool.Get()
-	inv.ModInverse(t, P)
-
-	e.x.Neg(a.x)
-	e.x.Mul(e.x, inv)
-	e.x.Mod(e.x, P)
-
-	e.y.Mul(a.y, inv)
-	e.y.Mod(e.y, P)
-
-	pool.Put(t)
-	pool.Put(t2)
-	pool.Put(inv)
-
-	return e
-}
-
-func (e *gfP2) Real() *big.Int {
-	return e.x
-}
-
-func (e *gfP2) Imag() *big.Int {
-	return e.y
-}
diff --git a/crypto/bn256/google/gfp6.go b/crypto/bn256/google/gfp6.go
deleted file mode 100644
index 218856617..000000000
--- a/crypto/bn256/google/gfp6.go
+++ /dev/null
@@ -1,296 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package bn256
-
-// For details of the algorithms used, see "Multiplication and Squaring on
-// Pairing-Friendly Fields, Devegili et al.
-// http://eprint.iacr.org/2006/471.pdf.
-
-import (
-	"math/big"
-)
-
-// gfP6 implements the field of size p⁶ as a cubic extension of gfP2 where τ³=ξ
-// and ξ=i+9.
-type gfP6 struct {
-	x, y, z *gfP2 // value is xτ² + yτ + z
-}
-
-func newGFp6(pool *bnPool) *gfP6 {
-	return &gfP6{newGFp2(pool), newGFp2(pool), newGFp2(pool)}
-}
-
-func (e *gfP6) String() string {
-	return "(" + e.x.String() + "," + e.y.String() + "," + e.z.String() + ")"
-}
-
-func (e *gfP6) Put(pool *bnPool) {
-	e.x.Put(pool)
-	e.y.Put(pool)
-	e.z.Put(pool)
-}
-
-func (e *gfP6) Set(a *gfP6) *gfP6 {
-	e.x.Set(a.x)
-	e.y.Set(a.y)
-	e.z.Set(a.z)
-	return e
-}
-
-func (e *gfP6) SetZero() *gfP6 {
-	e.x.SetZero()
-	e.y.SetZero()
-	e.z.SetZero()
-	return e
-}
-
-func (e *gfP6) SetOne() *gfP6 {
-	e.x.SetZero()
-	e.y.SetZero()
-	e.z.SetOne()
-	return e
-}
-
-func (e *gfP6) Minimal() {
-	e.x.Minimal()
-	e.y.Minimal()
-	e.z.Minimal()
-}
-
-func (e *gfP6) IsZero() bool {
-	return e.x.IsZero() && e.y.IsZero() && e.z.IsZero()
-}
-
-func (e *gfP6) IsOne() bool {
-	return e.x.IsZero() && e.y.IsZero() && e.z.IsOne()
-}
-
-func (e *gfP6) Negative(a *gfP6) *gfP6 {
-	e.x.Negative(a.x)
-	e.y.Negative(a.y)
-	e.z.Negative(a.z)
-	return e
-}
-
-func (e *gfP6) Frobenius(a *gfP6, pool *bnPool) *gfP6 {
-	e.x.Conjugate(a.x)
-	e.y.Conjugate(a.y)
-	e.z.Conjugate(a.z)
-
-	e.x.Mul(e.x, xiTo2PMinus2Over3, pool)
-	e.y.Mul(e.y, xiToPMinus1Over3, pool)
-	return e
-}
-
-// FrobeniusP2 computes (xτ²+yτ+z)^(p²) = xτ^(2p²) + yτ^(p²) + z
-func (e *gfP6) FrobeniusP2(a *gfP6) *gfP6 {
-	// τ^(2p²) = τ²τ^(2p²-2) = τ²ξ^((2p²-2)/3)
-	e.x.MulScalar(a.x, xiTo2PSquaredMinus2Over3)
-	// τ^(p²) = ττ^(p²-1) = τξ^((p²-1)/3)
-	e.y.MulScalar(a.y, xiToPSquaredMinus1Over3)
-	e.z.Set(a.z)
-	return e
-}
-
-func (e *gfP6) Add(a, b *gfP6) *gfP6 {
-	e.x.Add(a.x, b.x)
-	e.y.Add(a.y, b.y)
-	e.z.Add(a.z, b.z)
-	return e
-}
-
-func (e *gfP6) Sub(a, b *gfP6) *gfP6 {
-	e.x.Sub(a.x, b.x)
-	e.y.Sub(a.y, b.y)
-	e.z.Sub(a.z, b.z)
-	return e
-}
-
-func (e *gfP6) Double(a *gfP6) *gfP6 {
-	e.x.Double(a.x)
-	e.y.Double(a.y)
-	e.z.Double(a.z)
-	return e
-}
-
-func (e *gfP6) Mul(a, b *gfP6, pool *bnPool) *gfP6 {
-	// "Multiplication and Squaring on Pairing-Friendly Fields"
-	// Section 4, Karatsuba method.
-	// http://eprint.iacr.org/2006/471.pdf
-
-	v0 := newGFp2(pool)
-	v0.Mul(a.z, b.z, pool)
-	v1 := newGFp2(pool)
-	v1.Mul(a.y, b.y, pool)
-	v2 := newGFp2(pool)
-	v2.Mul(a.x, b.x, pool)
-
-	t0 := newGFp2(pool)
-	t0.Add(a.x, a.y)
-	t1 := newGFp2(pool)
-	t1.Add(b.x, b.y)
-	tz := newGFp2(pool)
-	tz.Mul(t0, t1, pool)
-
-	tz.Sub(tz, v1)
-	tz.Sub(tz, v2)
-	tz.MulXi(tz, pool)
-	tz.Add(tz, v0)
-
-	t0.Add(a.y, a.z)
-	t1.Add(b.y, b.z)
-	ty := newGFp2(pool)
-	ty.Mul(t0, t1, pool)
-	ty.Sub(ty, v0)
-	ty.Sub(ty, v1)
-	t0.MulXi(v2, pool)
-	ty.Add(ty, t0)
-
-	t0.Add(a.x, a.z)
-	t1.Add(b.x, b.z)
-	tx := newGFp2(pool)
-	tx.Mul(t0, t1, pool)
-	tx.Sub(tx, v0)
-	tx.Add(tx, v1)
-	tx.Sub(tx, v2)
-
-	e.x.Set(tx)
-	e.y.Set(ty)
-	e.z.Set(tz)
-
-	t0.Put(pool)
-	t1.Put(pool)
-	tx.Put(pool)
-	ty.Put(pool)
-	tz.Put(pool)
-	v0.Put(pool)
-	v1.Put(pool)
-	v2.Put(pool)
-	return e
-}
-
-func (e *gfP6) MulScalar(a *gfP6, b *gfP2, pool *bnPool) *gfP6 {
-	e.x.Mul(a.x, b, pool)
-	e.y.Mul(a.y, b, pool)
-	e.z.Mul(a.z, b, pool)
-	return e
-}
-
-func (e *gfP6) MulGFP(a *gfP6, b *big.Int) *gfP6 {
-	e.x.MulScalar(a.x, b)
-	e.y.MulScalar(a.y, b)
-	e.z.MulScalar(a.z, b)
-	return e
-}
-
-// MulTau computes τ·(aτ²+bτ+c) = bτ²+cτ+aξ
-func (e *gfP6) MulTau(a *gfP6, pool *bnPool) {
-	tz := newGFp2(pool)
-	tz.MulXi(a.x, pool)
-	ty := newGFp2(pool)
-	ty.Set(a.y)
-	e.y.Set(a.z)
-	e.x.Set(ty)
-	e.z.Set(tz)
-	tz.Put(pool)
-	ty.Put(pool)
-}
-
-func (e *gfP6) Square(a *gfP6, pool *bnPool) *gfP6 {
-	v0 := newGFp2(pool).Square(a.z, pool)
-	v1 := newGFp2(pool).Square(a.y, pool)
-	v2 := newGFp2(pool).Square(a.x, pool)
-
-	c0 := newGFp2(pool).Add(a.x, a.y)
-	c0.Square(c0, pool)
-	c0.Sub(c0, v1)
-	c0.Sub(c0, v2)
-	c0.MulXi(c0, pool)
-	c0.Add(c0, v0)
-
-	c1 := newGFp2(pool).Add(a.y, a.z)
-	c1.Square(c1, pool)
-	c1.Sub(c1, v0)
-	c1.Sub(c1, v1)
-	xiV2 := newGFp2(pool).MulXi(v2, pool)
-	c1.Add(c1, xiV2)
-
-	c2 := newGFp2(pool).Add(a.x, a.z)
-	c2.Square(c2, pool)
-	c2.Sub(c2, v0)
-	c2.Add(c2, v1)
-	c2.Sub(c2, v2)
-
-	e.x.Set(c2)
-	e.y.Set(c1)
-	e.z.Set(c0)
-
-	v0.Put(pool)
-	v1.Put(pool)
-	v2.Put(pool)
-	c0.Put(pool)
-	c1.Put(pool)
-	c2.Put(pool)
-	xiV2.Put(pool)
-
-	return e
-}
-
-func (e *gfP6) Invert(a *gfP6, pool *bnPool) *gfP6 {
-	// See "Implementing cryptographic pairings", M. Scott, section 3.2.
-	// ftp://136.206.11.249/pub/crypto/pairings.pdf
-
-	// Here we can give a short explanation of how it works: let j be a cubic root of
-	// unity in GF(p²) so that 1+j+j²=0.
-	// Then (xτ² + yτ + z)(xj²τ² + yjτ + z)(xjτ² + yj²τ + z)
-	// = (xτ² + yτ + z)(Cτ²+Bτ+A)
-	// = (x³ξ²+y³ξ+z³-3ξxyz) = F is an element of the base field (the norm).
-	//
-	// On the other hand (xj²τ² + yjτ + z)(xjτ² + yj²τ + z)
-	// = τ²(y²-ξxz) + τ(ξx²-yz) + (z²-ξxy)
-	//
-	// So that's why A = (z²-ξxy), B = (ξx²-yz), C = (y²-ξxz)
-	t1 := newGFp2(pool)
-
-	A := newGFp2(pool)
-	A.Square(a.z, pool)
-	t1.Mul(a.x, a.y, pool)
-	t1.MulXi(t1, pool)
-	A.Sub(A, t1)
-
-	B := newGFp2(pool)
-	B.Square(a.x, pool)
-	B.MulXi(B, pool)
-	t1.Mul(a.y, a.z, pool)
-	B.Sub(B, t1)
-
-	C_ := newGFp2(pool)
-	C_.Square(a.y, pool)
-	t1.Mul(a.x, a.z, pool)
-	C_.Sub(C_, t1)
-
-	F := newGFp2(pool)
-	F.Mul(C_, a.y, pool)
-	F.MulXi(F, pool)
-	t1.Mul(A, a.z, pool)
-	F.Add(F, t1)
-	t1.Mul(B, a.x, pool)
-	t1.MulXi(t1, pool)
-	F.Add(F, t1)
-
-	F.Invert(F, pool)
-
-	e.x.Mul(C_, F, pool)
-	e.y.Mul(B, F, pool)
-	e.z.Mul(A, F, pool)
-
-	t1.Put(pool)
-	A.Put(pool)
-	B.Put(pool)
-	C_.Put(pool)
-	F.Put(pool)
-
-	return e
-}
diff --git a/crypto/bn256/google/main_test.go b/crypto/bn256/google/main_test.go
deleted file mode 100644
index c0c85457b..000000000
--- a/crypto/bn256/google/main_test.go
+++ /dev/null
@@ -1,71 +0,0 @@
-package bn256
-
-import (
-	"testing"
-
-	"crypto/rand"
-)
-
-func TestRandomG2Marshal(t *testing.T) {
-	for i := 0; i < 10; i++ {
-		n, g2, err := RandomG2(rand.Reader)
-		if err != nil {
-			t.Error(err)
-			continue
-		}
-		t.Logf("%v: %x\n", n, g2.Marshal())
-	}
-}
-
-func TestPairings(t *testing.T) {
-	a1 := new(G1).ScalarBaseMult(bigFromBase10("1"))
-	a2 := new(G1).ScalarBaseMult(bigFromBase10("2"))
-	a37 := new(G1).ScalarBaseMult(bigFromBase10("37"))
-	an1 := new(G1).ScalarBaseMult(bigFromBase10("21888242871839275222246405745257275088548364400416034343698204186575808495616"))
-
-	b0 := new(G2).ScalarBaseMult(bigFromBase10("0"))
-	b1 := new(G2).ScalarBaseMult(bigFromBase10("1"))
-	b2 := new(G2).ScalarBaseMult(bigFromBase10("2"))
-	b27 := new(G2).ScalarBaseMult(bigFromBase10("27"))
-	b999 := new(G2).ScalarBaseMult(bigFromBase10("999"))
-	bn1 := new(G2).ScalarBaseMult(bigFromBase10("21888242871839275222246405745257275088548364400416034343698204186575808495616"))
-
-	p1 := Pair(a1, b1)
-	pn1 := Pair(a1, bn1)
-	np1 := Pair(an1, b1)
-	if pn1.String() != np1.String() {
-		t.Error("Pairing mismatch: e(a, -b) != e(-a, b)")
-	}
-	if !PairingCheck([]*G1{a1, an1}, []*G2{b1, b1}) {
-		t.Error("MultiAte check gave false negative!")
-	}
-	p0 := new(GT).Add(p1, pn1)
-	p0_2 := Pair(a1, b0)
-	if p0.String() != p0_2.String() {
-		t.Error("Pairing mismatch: e(a, b) * e(a, -b) != 1")
-	}
-	p0_3 := new(GT).ScalarMult(p1, bigFromBase10("21888242871839275222246405745257275088548364400416034343698204186575808495617"))
-	if p0.String() != p0_3.String() {
-		t.Error("Pairing mismatch: e(a, b) has wrong order")
-	}
-	p2 := Pair(a2, b1)
-	p2_2 := Pair(a1, b2)
-	p2_3 := new(GT).ScalarMult(p1, bigFromBase10("2"))
-	if p2.String() != p2_2.String() {
-		t.Error("Pairing mismatch: e(a, b * 2) != e(a * 2, b)")
-	}
-	if p2.String() != p2_3.String() {
-		t.Error("Pairing mismatch: e(a, b * 2) != e(a, b) ** 2")
-	}
-	if p2.String() == p1.String() {
-		t.Error("Pairing is degenerate!")
-	}
-	if PairingCheck([]*G1{a1, a1}, []*G2{b1, b1}) {
-		t.Error("MultiAte check gave false positive!")
-	}
-	p999 := Pair(a37, b27)
-	p999_2 := Pair(a1, b999)
-	if p999.String() != p999_2.String() {
-		t.Error("Pairing mismatch: e(a * 37, b * 27) != e(a, b * 999)")
-	}
-}
diff --git a/crypto/bn256/google/optate.go b/crypto/bn256/google/optate.go
deleted file mode 100644
index 9d6957062..000000000
--- a/crypto/bn256/google/optate.go
+++ /dev/null
@@ -1,397 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package bn256
-
-func lineFunctionAdd(r, p *twistPoint, q *curvePoint, r2 *gfP2, pool *bnPool) (a, b, c *gfP2, rOut *twistPoint) {
-	// See the mixed addition algorithm from "Faster Computation of the
-	// Tate Pairing", http://arxiv.org/pdf/0904.0854v3.pdf
-
-	B := newGFp2(pool).Mul(p.x, r.t, pool)
-
-	D := newGFp2(pool).Add(p.y, r.z)
-	D.Square(D, pool)
-	D.Sub(D, r2)
-	D.Sub(D, r.t)
-	D.Mul(D, r.t, pool)
-
-	H := newGFp2(pool).Sub(B, r.x)
-	I := newGFp2(pool).Square(H, pool)
-
-	E := newGFp2(pool).Add(I, I)
-	E.Add(E, E)
-
-	J := newGFp2(pool).Mul(H, E, pool)
-
-	L1 := newGFp2(pool).Sub(D, r.y)
-	L1.Sub(L1, r.y)
-
-	V := newGFp2(pool).Mul(r.x, E, pool)
-
-	rOut = newTwistPoint(pool)
-	rOut.x.Square(L1, pool)
-	rOut.x.Sub(rOut.x, J)
-	rOut.x.Sub(rOut.x, V)
-	rOut.x.Sub(rOut.x, V)
-
-	rOut.z.Add(r.z, H)
-	rOut.z.Square(rOut.z, pool)
-	rOut.z.Sub(rOut.z, r.t)
-	rOut.z.Sub(rOut.z, I)
-
-	t := newGFp2(pool).Sub(V, rOut.x)
-	t.Mul(t, L1, pool)
-	t2 := newGFp2(pool).Mul(r.y, J, pool)
-	t2.Add(t2, t2)
-	rOut.y.Sub(t, t2)
-
-	rOut.t.Square(rOut.z, pool)
-
-	t.Add(p.y, rOut.z)
-	t.Square(t, pool)
-	t.Sub(t, r2)
-	t.Sub(t, rOut.t)
-
-	t2.Mul(L1, p.x, pool)
-	t2.Add(t2, t2)
-	a = newGFp2(pool)
-	a.Sub(t2, t)
-
-	c = newGFp2(pool)
-	c.MulScalar(rOut.z, q.y)
-	c.Add(c, c)
-
-	b = newGFp2(pool)
-	b.SetZero()
-	b.Sub(b, L1)
-	b.MulScalar(b, q.x)
-	b.Add(b, b)
-
-	B.Put(pool)
-	D.Put(pool)
-	H.Put(pool)
-	I.Put(pool)
-	E.Put(pool)
-	J.Put(pool)
-	L1.Put(pool)
-	V.Put(pool)
-	t.Put(pool)
-	t2.Put(pool)
-
-	return
-}
-
-func lineFunctionDouble(r *twistPoint, q *curvePoint, pool *bnPool) (a, b, c *gfP2, rOut *twistPoint) {
-	// See the doubling algorithm for a=0 from "Faster Computation of the
-	// Tate Pairing", http://arxiv.org/pdf/0904.0854v3.pdf
-
-	A := newGFp2(pool).Square(r.x, pool)
-	B := newGFp2(pool).Square(r.y, pool)
-	C_ := newGFp2(pool).Square(B, pool)
-
-	D := newGFp2(pool).Add(r.x, B)
-	D.Square(D, pool)
-	D.Sub(D, A)
-	D.Sub(D, C_)
-	D.Add(D, D)
-
-	E := newGFp2(pool).Add(A, A)
-	E.Add(E, A)
-
-	G := newGFp2(pool).Square(E, pool)
-
-	rOut = newTwistPoint(pool)
-	rOut.x.Sub(G, D)
-	rOut.x.Sub(rOut.x, D)
-
-	rOut.z.Add(r.y, r.z)
-	rOut.z.Square(rOut.z, pool)
-	rOut.z.Sub(rOut.z, B)
-	rOut.z.Sub(rOut.z, r.t)
-
-	rOut.y.Sub(D, rOut.x)
-	rOut.y.Mul(rOut.y, E, pool)
-	t := newGFp2(pool).Add(C_, C_)
-	t.Add(t, t)
-	t.Add(t, t)
-	rOut.y.Sub(rOut.y, t)
-
-	rOut.t.Square(rOut.z, pool)
-
-	t.Mul(E, r.t, pool)
-	t.Add(t, t)
-	b = newGFp2(pool)
-	b.SetZero()
-	b.Sub(b, t)
-	b.MulScalar(b, q.x)
-
-	a = newGFp2(pool)
-	a.Add(r.x, E)
-	a.Square(a, pool)
-	a.Sub(a, A)
-	a.Sub(a, G)
-	t.Add(B, B)
-	t.Add(t, t)
-	a.Sub(a, t)
-
-	c = newGFp2(pool)
-	c.Mul(rOut.z, r.t, pool)
-	c.Add(c, c)
-	c.MulScalar(c, q.y)
-
-	A.Put(pool)
-	B.Put(pool)
-	C_.Put(pool)
-	D.Put(pool)
-	E.Put(pool)
-	G.Put(pool)
-	t.Put(pool)
-
-	return
-}
-
-func mulLine(ret *gfP12, a, b, c *gfP2, pool *bnPool) {
-	a2 := newGFp6(pool)
-	a2.x.SetZero()
-	a2.y.Set(a)
-	a2.z.Set(b)
-	a2.Mul(a2, ret.x, pool)
-	t3 := newGFp6(pool).MulScalar(ret.y, c, pool)
-
-	t := newGFp2(pool)
-	t.Add(b, c)
-	t2 := newGFp6(pool)
-	t2.x.SetZero()
-	t2.y.Set(a)
-	t2.z.Set(t)
-	ret.x.Add(ret.x, ret.y)
-
-	ret.y.Set(t3)
-
-	ret.x.Mul(ret.x, t2, pool)
-	ret.x.Sub(ret.x, a2)
-	ret.x.Sub(ret.x, ret.y)
-	a2.MulTau(a2, pool)
-	ret.y.Add(ret.y, a2)
-
-	a2.Put(pool)
-	t3.Put(pool)
-	t2.Put(pool)
-	t.Put(pool)
-}
-
-// sixuPlus2NAF is 6u+2 in non-adjacent form.
-var sixuPlus2NAF = []int8{0, 0, 0, 1, 0, 1, 0, -1, 0, 0, 1, -1, 0, 0, 1, 0,
-	0, 1, 1, 0, -1, 0, 0, 1, 0, -1, 0, 0, 0, 0, 1, 1,
-	1, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, -1, 0, 0, 1,
-	1, 0, 0, -1, 0, 0, 0, 1, 1, 0, -1, 0, 0, 1, 0, 1, 1}
-
-// miller implements the Miller loop for calculating the Optimal Ate pairing.
-// See algorithm 1 from http://cryptojedi.org/papers/dclxvi-20100714.pdf
-func miller(q *twistPoint, p *curvePoint, pool *bnPool) *gfP12 {
-	ret := newGFp12(pool)
-	ret.SetOne()
-
-	aAffine := newTwistPoint(pool)
-	aAffine.Set(q)
-	aAffine.MakeAffine(pool)
-
-	bAffine := newCurvePoint(pool)
-	bAffine.Set(p)
-	bAffine.MakeAffine(pool)
-
-	minusA := newTwistPoint(pool)
-	minusA.Negative(aAffine, pool)
-
-	r := newTwistPoint(pool)
-	r.Set(aAffine)
-
-	r2 := newGFp2(pool)
-	r2.Square(aAffine.y, pool)
-
-	for i := len(sixuPlus2NAF) - 1; i > 0; i-- {
-		a, b, c, newR := lineFunctionDouble(r, bAffine, pool)
-		if i != len(sixuPlus2NAF)-1 {
-			ret.Square(ret, pool)
-		}
-
-		mulLine(ret, a, b, c, pool)
-		a.Put(pool)
-		b.Put(pool)
-		c.Put(pool)
-		r.Put(pool)
-		r = newR
-
-		switch sixuPlus2NAF[i-1] {
-		case 1:
-			a, b, c, newR = lineFunctionAdd(r, aAffine, bAffine, r2, pool)
-		case -1:
-			a, b, c, newR = lineFunctionAdd(r, minusA, bAffine, r2, pool)
-		default:
-			continue
-		}
-
-		mulLine(ret, a, b, c, pool)
-		a.Put(pool)
-		b.Put(pool)
-		c.Put(pool)
-		r.Put(pool)
-		r = newR
-	}
-
-	// In order to calculate Q1 we have to convert q from the sextic twist
-	// to the full GF(p^12) group, apply the Frobenius there, and convert
-	// back.
-	//
-	// The twist isomorphism is (x', y') -> (xω², yω³). If we consider just
-	// x for a moment, then after applying the Frobenius, we have x̄ω^(2p)
-	// where x̄ is the conjugate of x. If we are going to apply the inverse
-	// isomorphism we need a value with a single coefficient of ω² so we
-	// rewrite this as x̄ω^(2p-2)ω². ξ⁶ = ω and, due to the construction of
-	// p, 2p-2 is a multiple of six. Therefore we can rewrite as
-	// x̄ξ^((p-1)/3)ω² and applying the inverse isomorphism eliminates the
-	// ω².
-	//
-	// A similar argument can be made for the y value.
-
-	q1 := newTwistPoint(pool)
-	q1.x.Conjugate(aAffine.x)
-	q1.x.Mul(q1.x, xiToPMinus1Over3, pool)
-	q1.y.Conjugate(aAffine.y)
-	q1.y.Mul(q1.y, xiToPMinus1Over2, pool)
-	q1.z.SetOne()
-	q1.t.SetOne()
-
-	// For Q2 we are applying the p² Frobenius. The two conjugations cancel
-	// out and we are left only with the factors from the isomorphism. In
-	// the case of x, we end up with a pure number which is why
-	// xiToPSquaredMinus1Over3 is ∈ GF(p). With y we get a factor of -1. We
-	// ignore this to end up with -Q2.
-
-	minusQ2 := newTwistPoint(pool)
-	minusQ2.x.MulScalar(aAffine.x, xiToPSquaredMinus1Over3)
-	minusQ2.y.Set(aAffine.y)
-	minusQ2.z.SetOne()
-	minusQ2.t.SetOne()
-
-	r2.Square(q1.y, pool)
-	a, b, c, newR := lineFunctionAdd(r, q1, bAffine, r2, pool)
-	mulLine(ret, a, b, c, pool)
-	a.Put(pool)
-	b.Put(pool)
-	c.Put(pool)
-	r.Put(pool)
-	r = newR
-
-	r2.Square(minusQ2.y, pool)
-	a, b, c, newR = lineFunctionAdd(r, minusQ2, bAffine, r2, pool)
-	mulLine(ret, a, b, c, pool)
-	a.Put(pool)
-	b.Put(pool)
-	c.Put(pool)
-	r.Put(pool)
-	r = newR
-
-	aAffine.Put(pool)
-	bAffine.Put(pool)
-	minusA.Put(pool)
-	r.Put(pool)
-	r2.Put(pool)
-
-	return ret
-}
-
-// finalExponentiation computes the (p¹²-1)/Order-th power of an element of
-// GF(p¹²) to obtain an element of GT (steps 13-15 of algorithm 1 from
-// http://cryptojedi.org/papers/dclxvi-20100714.pdf)
-func finalExponentiation(in *gfP12, pool *bnPool) *gfP12 {
-	t1 := newGFp12(pool)
-
-	// This is the p^6-Frobenius
-	t1.x.Negative(in.x)
-	t1.y.Set(in.y)
-
-	inv := newGFp12(pool)
-	inv.Invert(in, pool)
-	t1.Mul(t1, inv, pool)
-
-	t2 := newGFp12(pool).FrobeniusP2(t1, pool)
-	t1.Mul(t1, t2, pool)
-
-	fp := newGFp12(pool).Frobenius(t1, pool)
-	fp2 := newGFp12(pool).FrobeniusP2(t1, pool)
-	fp3 := newGFp12(pool).Frobenius(fp2, pool)
-
-	fu, fu2, fu3 := newGFp12(pool), newGFp12(pool), newGFp12(pool)
-	fu.Exp(t1, u, pool)
-	fu2.Exp(fu, u, pool)
-	fu3.Exp(fu2, u, pool)
-
-	y3 := newGFp12(pool).Frobenius(fu, pool)
-	fu2p := newGFp12(pool).Frobenius(fu2, pool)
-	fu3p := newGFp12(pool).Frobenius(fu3, pool)
-	y2 := newGFp12(pool).FrobeniusP2(fu2, pool)
-
-	y0 := newGFp12(pool)
-	y0.Mul(fp, fp2, pool)
-	y0.Mul(y0, fp3, pool)
-
-	y1, y4, y5 := newGFp12(pool), newGFp12(pool), newGFp12(pool)
-	y1.Conjugate(t1)
-	y5.Conjugate(fu2)
-	y3.Conjugate(y3)
-	y4.Mul(fu, fu2p, pool)
-	y4.Conjugate(y4)
-
-	y6 := newGFp12(pool)
-	y6.Mul(fu3, fu3p, pool)
-	y6.Conjugate(y6)
-
-	t0 := newGFp12(pool)
-	t0.Square(y6, pool)
-	t0.Mul(t0, y4, pool)
-	t0.Mul(t0, y5, pool)
-	t1.Mul(y3, y5, pool)
-	t1.Mul(t1, t0, pool)
-	t0.Mul(t0, y2, pool)
-	t1.Square(t1, pool)
-	t1.Mul(t1, t0, pool)
-	t1.Square(t1, pool)
-	t0.Mul(t1, y1, pool)
-	t1.Mul(t1, y0, pool)
-	t0.Square(t0, pool)
-	t0.Mul(t0, t1, pool)
-
-	inv.Put(pool)
-	t1.Put(pool)
-	t2.Put(pool)
-	fp.Put(pool)
-	fp2.Put(pool)
-	fp3.Put(pool)
-	fu.Put(pool)
-	fu2.Put(pool)
-	fu3.Put(pool)
-	fu2p.Put(pool)
-	fu3p.Put(pool)
-	y0.Put(pool)
-	y1.Put(pool)
-	y2.Put(pool)
-	y3.Put(pool)
-	y4.Put(pool)
-	y5.Put(pool)
-	y6.Put(pool)
-
-	return t0
-}
-
-func optimalAte(a *twistPoint, b *curvePoint, pool *bnPool) *gfP12 {
-	e := miller(a, b, pool)
-	ret := finalExponentiation(e, pool)
-	e.Put(pool)
-
-	if a.IsInfinity() || b.IsInfinity() {
-		ret.SetOne()
-	}
-	return ret
-}
diff --git a/crypto/bn256/google/twist.go b/crypto/bn256/google/twist.go
deleted file mode 100644
index 43364ff5b..000000000
--- a/crypto/bn256/google/twist.go
+++ /dev/null
@@ -1,263 +0,0 @@
-// Copyright 2012 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package bn256
-
-import (
-	"math/big"
-)
-
-// twistPoint implements the elliptic curve y²=x³+3/ξ over GF(p²). Points are
-// kept in Jacobian form and t=z² when valid. The group G₂ is the set of
-// n-torsion points of this curve over GF(p²) (where n = Order)
-type twistPoint struct {
-	x, y, z, t *gfP2
-}
-
-var twistB = &gfP2{
-	bigFromBase10("266929791119991161246907387137283842545076965332900288569378510910307636690"),
-	bigFromBase10("19485874751759354771024239261021720505790618469301721065564631296452457478373"),
-}
-
-// twistGen is the generator of group G₂.
-var twistGen = &twistPoint{
-	&gfP2{
-		bigFromBase10("11559732032986387107991004021392285783925812861821192530917403151452391805634"),
-		bigFromBase10("10857046999023057135944570762232829481370756359578518086990519993285655852781"),
-	},
-	&gfP2{
-		bigFromBase10("4082367875863433681332203403145435568316851327593401208105741076214120093531"),
-		bigFromBase10("8495653923123431417604973247489272438418190587263600148770280649306958101930"),
-	},
-	&gfP2{
-		bigFromBase10("0"),
-		bigFromBase10("1"),
-	},
-	&gfP2{
-		bigFromBase10("0"),
-		bigFromBase10("1"),
-	},
-}
-
-func newTwistPoint(pool *bnPool) *twistPoint {
-	return &twistPoint{
-		newGFp2(pool),
-		newGFp2(pool),
-		newGFp2(pool),
-		newGFp2(pool),
-	}
-}
-
-func (c *twistPoint) String() string {
-	return "(" + c.x.String() + ", " + c.y.String() + ", " + c.z.String() + ")"
-}
-
-func (c *twistPoint) Put(pool *bnPool) {
-	c.x.Put(pool)
-	c.y.Put(pool)
-	c.z.Put(pool)
-	c.t.Put(pool)
-}
-
-func (c *twistPoint) Set(a *twistPoint) {
-	c.x.Set(a.x)
-	c.y.Set(a.y)
-	c.z.Set(a.z)
-	c.t.Set(a.t)
-}
-
-// IsOnCurve returns true iff c is on the curve where c must be in affine form.
-func (c *twistPoint) IsOnCurve() bool {
-	pool := new(bnPool)
-	yy := newGFp2(pool).Square(c.y, pool)
-	xxx := newGFp2(pool).Square(c.x, pool)
-	xxx.Mul(xxx, c.x, pool)
-	yy.Sub(yy, xxx)
-	yy.Sub(yy, twistB)
-	yy.Minimal()
-
-	if yy.x.Sign() != 0 || yy.y.Sign() != 0 {
-		return false
-	}
-	cneg := newTwistPoint(pool)
-	cneg.Mul(c, Order, pool)
-	return cneg.z.IsZero()
-}
-
-func (c *twistPoint) SetInfinity() {
-	c.z.SetZero()
-}
-
-func (c *twistPoint) IsInfinity() bool {
-	return c.z.IsZero()
-}
-
-func (c *twistPoint) Add(a, b *twistPoint, pool *bnPool) {
-	// For additional comments, see the same function in curve.go.
-
-	if a.IsInfinity() {
-		c.Set(b)
-		return
-	}
-	if b.IsInfinity() {
-		c.Set(a)
-		return
-	}
-
-	// See http://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/addition/add-2007-bl.op3
-	z1z1 := newGFp2(pool).Square(a.z, pool)
-	z2z2 := newGFp2(pool).Square(b.z, pool)
-	u1 := newGFp2(pool).Mul(a.x, z2z2, pool)
-	u2 := newGFp2(pool).Mul(b.x, z1z1, pool)
-
-	t := newGFp2(pool).Mul(b.z, z2z2, pool)
-	s1 := newGFp2(pool).Mul(a.y, t, pool)
-
-	t.Mul(a.z, z1z1, pool)
-	s2 := newGFp2(pool).Mul(b.y, t, pool)
-
-	h := newGFp2(pool).Sub(u2, u1)
-	xEqual := h.IsZero()
-
-	t.Add(h, h)
-	i := newGFp2(pool).Square(t, pool)
-	j := newGFp2(pool).Mul(h, i, pool)
-
-	t.Sub(s2, s1)
-	yEqual := t.IsZero()
-	if xEqual && yEqual {
-		c.Double(a, pool)
-		return
-	}
-	r := newGFp2(pool).Add(t, t)
-
-	v := newGFp2(pool).Mul(u1, i, pool)
-
-	t4 := newGFp2(pool).Square(r, pool)
-	t.Add(v, v)
-	t6 := newGFp2(pool).Sub(t4, j)
-	c.x.Sub(t6, t)
-
-	t.Sub(v, c.x)       // t7
-	t4.Mul(s1, j, pool) // t8
-	t6.Add(t4, t4)      // t9
-	t4.Mul(r, t, pool)  // t10
-	c.y.Sub(t4, t6)
-
-	t.Add(a.z, b.z)    // t11
-	t4.Square(t, pool) // t12
-	t.Sub(t4, z1z1)    // t13
-	t4.Sub(t, z2z2)    // t14
-	c.z.Mul(t4, h, pool)
-
-	z1z1.Put(pool)
-	z2z2.Put(pool)
-	u1.Put(pool)
-	u2.Put(pool)
-	t.Put(pool)
-	s1.Put(pool)
-	s2.Put(pool)
-	h.Put(pool)
-	i.Put(pool)
-	j.Put(pool)
-	r.Put(pool)
-	v.Put(pool)
-	t4.Put(pool)
-	t6.Put(pool)
-}
-
-func (c *twistPoint) Double(a *twistPoint, pool *bnPool) {
-	// See http://hyperelliptic.org/EFD/g1p/auto-code/shortw/jacobian-0/doubling/dbl-2009-l.op3
-	A := newGFp2(pool).Square(a.x, pool)
-	B := newGFp2(pool).Square(a.y, pool)
-	C_ := newGFp2(pool).Square(B, pool)
-
-	t := newGFp2(pool).Add(a.x, B)
-	t2 := newGFp2(pool).Square(t, pool)
-	t.Sub(t2, A)
-	t2.Sub(t, C_)
-	d := newGFp2(pool).Add(t2, t2)
-	t.Add(A, A)
-	e := newGFp2(pool).Add(t, A)
-	f := newGFp2(pool).Square(e, pool)
-
-	t.Add(d, d)
-	c.x.Sub(f, t)
-
-	t.Add(C_, C_)
-	t2.Add(t, t)
-	t.Add(t2, t2)
-	c.y.Sub(d, c.x)
-	t2.Mul(e, c.y, pool)
-	c.y.Sub(t2, t)
-
-	t.Mul(a.y, a.z, pool)
-	c.z.Add(t, t)
-
-	A.Put(pool)
-	B.Put(pool)
-	C_.Put(pool)
-	t.Put(pool)
-	t2.Put(pool)
-	d.Put(pool)
-	e.Put(pool)
-	f.Put(pool)
-}
-
-func (c *twistPoint) Mul(a *twistPoint, scalar *big.Int, pool *bnPool) *twistPoint {
-	sum := newTwistPoint(pool)
-	sum.SetInfinity()
-	t := newTwistPoint(pool)
-
-	for i := scalar.BitLen(); i >= 0; i-- {
-		t.Double(sum, pool)
-		if scalar.Bit(i) != 0 {
-			sum.Add(t, a, pool)
-		} else {
-			sum.Set(t)
-		}
-	}
-
-	c.Set(sum)
-	sum.Put(pool)
-	t.Put(pool)
-	return c
-}
-
-// MakeAffine converts c to affine form and returns c. If c is ∞, then it sets
-// c to 0 : 1 : 0.
-func (c *twistPoint) MakeAffine(pool *bnPool) *twistPoint {
-	if c.z.IsOne() {
-		return c
-	}
-	if c.IsInfinity() {
-		c.x.SetZero()
-		c.y.SetOne()
-		c.z.SetZero()
-		c.t.SetZero()
-		return c
-	}
-	zInv := newGFp2(pool).Invert(c.z, pool)
-	t := newGFp2(pool).Mul(c.y, zInv, pool)
-	zInv2 := newGFp2(pool).Square(zInv, pool)
-	c.y.Mul(t, zInv2, pool)
-	t.Mul(c.x, zInv2, pool)
-	c.x.Set(t)
-	c.z.SetOne()
-	c.t.SetOne()
-
-	zInv.Put(pool)
-	t.Put(pool)
-	zInv2.Put(pool)
-
-	return c
-}
-
-func (c *twistPoint) Negative(a *twistPoint, pool *bnPool) {
-	c.x.Set(a.x)
-	c.y.SetZero()
-	c.y.Sub(c.y, a.y)
-	c.z.Set(a.z)
-	c.t.SetZero()
-}
diff --git a/crypto/edwards25519/doc.go b/crypto/edwards25519/doc.go
new file mode 100644
index 000000000..ff31cd23d
--- /dev/null
+++ b/crypto/edwards25519/doc.go
@@ -0,0 +1,22 @@
+// Copyright (c) 2021 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package edwards25519 implements group logic for the twisted Edwards curve
+//
+//     -x^2 + y^2 = 1 + -(121665/121666)*x^2*y^2
+//
+// This is better known as the Edwards curve equivalent to Curve25519, and is
+// the curve used by the Ed25519 signature scheme.
+//
+// Most users don't need this package, and should instead use crypto/ed25519 for
+// signatures, golang.org/x/crypto/curve25519 for Diffie-Hellman, or
+// github.com/gtank/ristretto255 for prime order group logic.
+//
+// However, developers who do need to interact with low-level edwards25519
+// operations can use filippo.io/edwards25519, an extended version of this
+// package repackaged as an importable module.
+//
+// (Note that filippo.io/edwards25519 and github.com/gtank/ristretto255 are not
+// maintained by the Go team and are not covered by the Go 1 Compatibility Promise.)
+package edwards25519
diff --git a/crypto/edwards25519/edwards25519.go b/crypto/edwards25519/edwards25519.go
new file mode 100644
index 000000000..feccc4f95
--- /dev/null
+++ b/crypto/edwards25519/edwards25519.go
@@ -0,0 +1,427 @@
+// Copyright (c) 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package edwards25519
+
+import (
+	"errors"
+	"github.com/ethereum/go-ethereum/crypto/edwards25519/field"
+)
+
+// Point types.
+
+type projP1xP1 struct {
+	X, Y, Z, T field.Element
+}
+
+type projP2 struct {
+	X, Y, Z field.Element
+}
+
+// Point represents a point on the edwards25519 curve.
+//
+// This type works similarly to math/big.Int, and all arguments and receivers
+// are allowed to alias.
+//
+// The zero value is NOT valid, and it may be used only as a receiver.
+type Point struct {
+	// The point is internally represented in extended coordinates (X, Y, Z, T)
+	// where x = X/Z, y = Y/Z, and xy = T/Z per https://eprint.iacr.org/2008/522.
+	x, y, z, t field.Element
+
+	// Make the type not comparable (i.e. used with == or as a map key), as
+	// equivalent points can be represented by different Go values.
+	_ incomparable
+}
+
+type incomparable [0]func()
+
+func checkInitialized(points ...*Point) {
+	for _, p := range points {
+		if p.x == (field.Element{}) && p.y == (field.Element{}) {
+			panic("edwards25519: use of uninitialized Point")
+		}
+	}
+}
+
+type projCached struct {
+	YplusX, YminusX, Z, T2d field.Element
+}
+
+type affineCached struct {
+	YplusX, YminusX, T2d field.Element
+}
+
+// Constructors.
+
+func (v *projP2) Zero() *projP2 {
+	v.X.Zero()
+	v.Y.One()
+	v.Z.One()
+	return v
+}
+
+// identity is the point at infinity.
+var identity, _ = new(Point).SetBytes([]byte{
+	1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0})
+
+// NewIdentityPoint returns a new Point set to the identity.
+func NewIdentityPoint() *Point {
+	return new(Point).Set(identity)
+}
+
+// generator is the canonical curve basepoint. See TestGenerator for the
+// correspondence of this encoding with the values in RFC 8032.
+var generator, _ = new(Point).SetBytes([]byte{
+	0x58, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
+	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
+	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66,
+	0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66})
+
+// NewGeneratorPoint returns a new Point set to the canonical generator.
+func NewGeneratorPoint() *Point {
+	return new(Point).Set(generator)
+}
+
+func (v *projCached) Zero() *projCached {
+	v.YplusX.One()
+	v.YminusX.One()
+	v.Z.One()
+	v.T2d.Zero()
+	return v
+}
+
+func (v *affineCached) Zero() *affineCached {
+	v.YplusX.One()
+	v.YminusX.One()
+	v.T2d.Zero()
+	return v
+}
+
+// Assignments.
+
+// Set sets v = u, and returns v.
+func (v *Point) Set(u *Point) *Point {
+	*v = *u
+	return v
+}
+
+// Encoding.
+
+// Bytes returns the canonical 32-byte encoding of v, according to RFC 8032,
+// Section 5.1.2.
+func (v *Point) Bytes() []byte {
+	// This function is outlined to make the allocations inline in the caller
+	// rather than happen on the heap.
+	var buf [32]byte
+	return v.bytes(&buf)
+}
+
+func (v *Point) bytes(buf *[32]byte) []byte {
+	checkInitialized(v)
+
+	var zInv, x, y field.Element
+	zInv.Invert(&v.z)       // zInv = 1 / Z
+	x.Multiply(&v.x, &zInv) // x = X / Z
+	y.Multiply(&v.y, &zInv) // y = Y / Z
+
+	out := copyFieldElement(buf, &y)
+	out[31] |= byte(x.IsNegative() << 7)
+	return out
+}
+
+var feOne = new(field.Element).One()
+
+// SetBytes sets v = x, where x is a 32-byte encoding of v. If x does not
+// represent a valid point on the curve, SetBytes returns nil and an error and
+// the receiver is unchanged. Otherwise, SetBytes returns v.
+//
+// Note that SetBytes accepts all non-canonical encodings of valid points.
+// That is, it follows decoding rules that match most implementations in
+// the ecosystem rather than RFC 8032.
+func (v *Point) SetBytes(x []byte) (*Point, error) {
+	// Specifically, the non-canonical encodings that are accepted are
+	//   1) the ones where the field element is not reduced (see the
+	//      (*field.Element).SetBytes docs) and
+	//   2) the ones where the x-coordinate is zero and the sign bit is set.
+	//
+	// This is consistent with crypto/ed25519/internal/edwards25519. Read more
+	// at https://hdevalence.ca/blog/2020-10-04-its-25519am, specifically the
+	// "Canonical A, R" section.
+
+	if len(x) != 32 {
+		return nil, errors.New("edwards25519: invalid point encoding length")
+	}
+	y := new(field.Element).SetBytes(x)
+
+	// -x² + y² = 1 + dx²y²
+	// x² + dx²y² = x²(dy² + 1) = y² - 1
+	// x² = (y² - 1) / (dy² + 1)
+
+	// u = y² - 1
+	y2 := new(field.Element).Square(y)
+	u := new(field.Element).Subtract(y2, feOne)
+
+	// v = dy² + 1
+	vv := new(field.Element).Multiply(y2, d)
+	vv = vv.Add(vv, feOne)
+
+	// x = +√(u/v)
+	xx, wasSquare := new(field.Element).SqrtRatio(u, vv)
+	if wasSquare == 0 {
+		return nil, errors.New("edwards25519: invalid point encoding")
+	}
+
+	// Select the negative square root if the sign bit is set.
+	xxNeg := new(field.Element).Negate(xx)
+	xx = xx.Select(xxNeg, xx, int(x[31]>>7))
+
+	v.x.Set(xx)
+	v.y.Set(y)
+	v.z.One()
+	v.t.Multiply(xx, y) // xy = T / Z
+
+	return v, nil
+}
+
+func copyFieldElement(buf *[32]byte, v *field.Element) []byte {
+	copy(buf[:], v.Bytes())
+	return buf[:]
+}
+
+// Conversions.
+
+func (v *projP2) FromP1xP1(p *projP1xP1) *projP2 {
+	v.X.Multiply(&p.X, &p.T)
+	v.Y.Multiply(&p.Y, &p.Z)
+	v.Z.Multiply(&p.Z, &p.T)
+	return v
+}
+
+func (v *projP2) FromP3(p *Point) *projP2 {
+	v.X.Set(&p.x)
+	v.Y.Set(&p.y)
+	v.Z.Set(&p.z)
+	return v
+}
+
+func (v *Point) fromP1xP1(p *projP1xP1) *Point {
+	v.x.Multiply(&p.X, &p.T)
+	v.y.Multiply(&p.Y, &p.Z)
+	v.z.Multiply(&p.Z, &p.T)
+	v.t.Multiply(&p.X, &p.Y)
+	return v
+}
+
+func (v *Point) fromP2(p *projP2) *Point {
+	v.x.Multiply(&p.X, &p.Z)
+	v.y.Multiply(&p.Y, &p.Z)
+	v.z.Square(&p.Z)
+	v.t.Multiply(&p.X, &p.Y)
+	return v
+}
+
+// d is a constant in the curve equation.
+var d = new(field.Element).SetBytes([]byte{
+	0xa3, 0x78, 0x59, 0x13, 0xca, 0x4d, 0xeb, 0x75,
+	0xab, 0xd8, 0x41, 0x41, 0x4d, 0x0a, 0x70, 0x00,
+	0x98, 0xe8, 0x79, 0x77, 0x79, 0x40, 0xc7, 0x8c,
+	0x73, 0xfe, 0x6f, 0x2b, 0xee, 0x6c, 0x03, 0x52})
+var d2 = new(field.Element).Add(d, d)
+
+func (v *projCached) FromP3(p *Point) *projCached {
+	v.YplusX.Add(&p.y, &p.x)
+	v.YminusX.Subtract(&p.y, &p.x)
+	v.Z.Set(&p.z)
+	v.T2d.Multiply(&p.t, d2)
+	return v
+}
+
+func (v *affineCached) FromP3(p *Point) *affineCached {
+	v.YplusX.Add(&p.y, &p.x)
+	v.YminusX.Subtract(&p.y, &p.x)
+	v.T2d.Multiply(&p.t, d2)
+
+	var invZ field.Element
+	invZ.Invert(&p.z)
+	v.YplusX.Multiply(&v.YplusX, &invZ)
+	v.YminusX.Multiply(&v.YminusX, &invZ)
+	v.T2d.Multiply(&v.T2d, &invZ)
+	return v
+}
+
+// (Re)addition and subtraction.
+
+// Add sets v = p + q, and returns v.
+func (v *Point) Add(p, q *Point) *Point {
+	checkInitialized(p, q)
+	qCached := new(projCached).FromP3(q)
+	result := new(projP1xP1).Add(p, qCached)
+	return v.fromP1xP1(result)
+}
+
+// Subtract sets v = p - q, and returns v.
+func (v *Point) Subtract(p, q *Point) *Point {
+	checkInitialized(p, q)
+	qCached := new(projCached).FromP3(q)
+	result := new(projP1xP1).Sub(p, qCached)
+	return v.fromP1xP1(result)
+}
+
+func (v *projP1xP1) Add(p *Point, q *projCached) *projP1xP1 {
+	var YplusX, YminusX, PP, MM, TT2d, ZZ2 field.Element
+
+	YplusX.Add(&p.y, &p.x)
+	YminusX.Subtract(&p.y, &p.x)
+
+	PP.Multiply(&YplusX, &q.YplusX)
+	MM.Multiply(&YminusX, &q.YminusX)
+	TT2d.Multiply(&p.t, &q.T2d)
+	ZZ2.Multiply(&p.z, &q.Z)
+
+	ZZ2.Add(&ZZ2, &ZZ2)
+
+	v.X.Subtract(&PP, &MM)
+	v.Y.Add(&PP, &MM)
+	v.Z.Add(&ZZ2, &TT2d)
+	v.T.Subtract(&ZZ2, &TT2d)
+	return v
+}
+
+func (v *projP1xP1) Sub(p *Point, q *projCached) *projP1xP1 {
+	var YplusX, YminusX, PP, MM, TT2d, ZZ2 field.Element
+
+	YplusX.Add(&p.y, &p.x)
+	YminusX.Subtract(&p.y, &p.x)
+
+	PP.Multiply(&YplusX, &q.YminusX) // flipped sign
+	MM.Multiply(&YminusX, &q.YplusX) // flipped sign
+	TT2d.Multiply(&p.t, &q.T2d)
+	ZZ2.Multiply(&p.z, &q.Z)
+
+	ZZ2.Add(&ZZ2, &ZZ2)
+
+	v.X.Subtract(&PP, &MM)
+	v.Y.Add(&PP, &MM)
+	v.Z.Subtract(&ZZ2, &TT2d) // flipped sign
+	v.T.Add(&ZZ2, &TT2d)      // flipped sign
+	return v
+}
+
+func (v *projP1xP1) AddAffine(p *Point, q *affineCached) *projP1xP1 {
+	var YplusX, YminusX, PP, MM, TT2d, Z2 field.Element
+
+	YplusX.Add(&p.y, &p.x)
+	YminusX.Subtract(&p.y, &p.x)
+
+	PP.Multiply(&YplusX, &q.YplusX)
+	MM.Multiply(&YminusX, &q.YminusX)
+	TT2d.Multiply(&p.t, &q.T2d)
+
+	Z2.Add(&p.z, &p.z)
+
+	v.X.Subtract(&PP, &MM)
+	v.Y.Add(&PP, &MM)
+	v.Z.Add(&Z2, &TT2d)
+	v.T.Subtract(&Z2, &TT2d)
+	return v
+}
+
+func (v *projP1xP1) SubAffine(p *Point, q *affineCached) *projP1xP1 {
+	var YplusX, YminusX, PP, MM, TT2d, Z2 field.Element
+
+	YplusX.Add(&p.y, &p.x)
+	YminusX.Subtract(&p.y, &p.x)
+
+	PP.Multiply(&YplusX, &q.YminusX) // flipped sign
+	MM.Multiply(&YminusX, &q.YplusX) // flipped sign
+	TT2d.Multiply(&p.t, &q.T2d)
+
+	Z2.Add(&p.z, &p.z)
+
+	v.X.Subtract(&PP, &MM)
+	v.Y.Add(&PP, &MM)
+	v.Z.Subtract(&Z2, &TT2d) // flipped sign
+	v.T.Add(&Z2, &TT2d)      // flipped sign
+	return v
+}
+
+// Doubling.
+
+func (v *projP1xP1) Double(p *projP2) *projP1xP1 {
+	var XX, YY, ZZ2, XplusYsq field.Element
+
+	XX.Square(&p.X)
+	YY.Square(&p.Y)
+	ZZ2.Square(&p.Z)
+	ZZ2.Add(&ZZ2, &ZZ2)
+	XplusYsq.Add(&p.X, &p.Y)
+	XplusYsq.Square(&XplusYsq)
+
+	v.Y.Add(&YY, &XX)
+	v.Z.Subtract(&YY, &XX)
+
+	v.X.Subtract(&XplusYsq, &v.Y)
+	v.T.Subtract(&ZZ2, &v.Z)
+	return v
+}
+
+// Negation.
+
+// Negate sets v = -p, and returns v.
+func (v *Point) Negate(p *Point) *Point {
+	checkInitialized(p)
+	v.x.Negate(&p.x)
+	v.y.Set(&p.y)
+	v.z.Set(&p.z)
+	v.t.Negate(&p.t)
+	return v
+}
+
+// Equal returns 1 if v is equivalent to u, and 0 otherwise.
+func (v *Point) Equal(u *Point) int {
+	checkInitialized(v, u)
+
+	var t1, t2, t3, t4 field.Element
+	t1.Multiply(&v.x, &u.z)
+	t2.Multiply(&u.x, &v.z)
+	t3.Multiply(&v.y, &u.z)
+	t4.Multiply(&u.y, &v.z)
+
+	return t1.Equal(&t2) & t3.Equal(&t4)
+}
+
+// Constant-time operations
+
+// Select sets v to a if cond == 1 and to b if cond == 0.
+func (v *projCached) Select(a, b *projCached, cond int) *projCached {
+	v.YplusX.Select(&a.YplusX, &b.YplusX, cond)
+	v.YminusX.Select(&a.YminusX, &b.YminusX, cond)
+	v.Z.Select(&a.Z, &b.Z, cond)
+	v.T2d.Select(&a.T2d, &b.T2d, cond)
+	return v
+}
+
+// Select sets v to a if cond == 1 and to b if cond == 0.
+func (v *affineCached) Select(a, b *affineCached, cond int) *affineCached {
+	v.YplusX.Select(&a.YplusX, &b.YplusX, cond)
+	v.YminusX.Select(&a.YminusX, &b.YminusX, cond)
+	v.T2d.Select(&a.T2d, &b.T2d, cond)
+	return v
+}
+
+// CondNeg negates v if cond == 1 and leaves it unchanged if cond == 0.
+func (v *projCached) CondNeg(cond int) *projCached {
+	v.YplusX.Swap(&v.YminusX, cond)
+	v.T2d.Select(new(field.Element).Negate(&v.T2d), &v.T2d, cond)
+	return v
+}
+
+// CondNeg negates v if cond == 1 and leaves it unchanged if cond == 0.
+func (v *affineCached) CondNeg(cond int) *affineCached {
+	v.YplusX.Swap(&v.YminusX, cond)
+	v.T2d.Select(new(field.Element).Negate(&v.T2d), &v.T2d, cond)
+	return v
+}
diff --git a/crypto/edwards25519/edwards25519_test.go b/crypto/edwards25519/edwards25519_test.go
new file mode 100644
index 000000000..c388d606f
--- /dev/null
+++ b/crypto/edwards25519/edwards25519_test.go
@@ -0,0 +1,304 @@
+// Copyright (c) 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package edwards25519
+
+import (
+	"encoding/hex"
+	"github.com/ethereum/go-ethereum/crypto/edwards25519/field"
+	"os"
+	"reflect"
+	"strings"
+	"testing"
+)
+
+var B = NewGeneratorPoint()
+var I = NewIdentityPoint()
+
+func checkOnCurve(t *testing.T, points ...*Point) {
+	t.Helper()
+	for i, p := range points {
+		var XX, YY, ZZ, ZZZZ field.Element
+		XX.Square(&p.x)
+		YY.Square(&p.y)
+		ZZ.Square(&p.z)
+		ZZZZ.Square(&ZZ)
+		// -x² + y² = 1 + dx²y²
+		// -(X/Z)² + (Y/Z)² = 1 + d(X/Z)²(Y/Z)²
+		// (-X² + Y²)/Z² = 1 + (dX²Y²)/Z⁴
+		// (-X² + Y²)*Z² = Z⁴ + dX²Y²
+		var lhs, rhs field.Element
+		lhs.Subtract(&YY, &XX).Multiply(&lhs, &ZZ)
+		rhs.Multiply(d, &XX).Multiply(&rhs, &YY).Add(&rhs, &ZZZZ)
+		if lhs.Equal(&rhs) != 1 {
+			t.Errorf("X, Y, and Z do not specify a point on the curve\nX = %v\nY = %v\nZ = %v", p.x, p.y, p.z)
+		}
+		// xy = T/Z
+		lhs.Multiply(&p.x, &p.y)
+		rhs.Multiply(&p.z, &p.t)
+		if lhs.Equal(&rhs) != 1 {
+			t.Errorf("point %d is not valid\nX = %v\nY = %v\nZ = %v", i, p.x, p.y, p.z)
+		}
+	}
+}
+
+func TestGenerator(t *testing.T) {
+	// These are the coordinates of B from RFC 8032, Section 5.1, converted to
+	// little endian hex.
+	x := "1ad5258f602d56c9b2a7259560c72c695cdcd6fd31e2a4c0fe536ecdd3366921"
+	y := "5866666666666666666666666666666666666666666666666666666666666666"
+	if got := hex.EncodeToString(B.x.Bytes()); got != x {
+		t.Errorf("wrong B.x: got %s, expected %s", got, x)
+	}
+	if got := hex.EncodeToString(B.y.Bytes()); got != y {
+		t.Errorf("wrong B.y: got %s, expected %s", got, y)
+	}
+	if B.z.Equal(feOne) != 1 {
+		t.Errorf("wrong B.z: got %v, expected 1", B.z)
+	}
+	// Check that t is correct.
+	checkOnCurve(t, B)
+}
+
+func TestAddSubNegOnBasePoint(t *testing.T) {
+	checkLhs, checkRhs := &Point{}, &Point{}
+
+	checkLhs.Add(B, B)
+	tmpP2 := new(projP2).FromP3(B)
+	tmpP1xP1 := new(projP1xP1).Double(tmpP2)
+	checkRhs.fromP1xP1(tmpP1xP1)
+	if checkLhs.Equal(checkRhs) != 1 {
+		t.Error("B + B != [2]B")
+	}
+	checkOnCurve(t, checkLhs, checkRhs)
+
+	checkLhs.Subtract(B, B)
+	Bneg := new(Point).Negate(B)
+	checkRhs.Add(B, Bneg)
+	if checkLhs.Equal(checkRhs) != 1 {
+		t.Error("B - B != B + (-B)")
+	}
+	if I.Equal(checkLhs) != 1 {
+		t.Error("B - B != 0")
+	}
+	if I.Equal(checkRhs) != 1 {
+		t.Error("B + (-B) != 0")
+	}
+	checkOnCurve(t, checkLhs, checkRhs, Bneg)
+}
+
+func TestComparable(t *testing.T) {
+	if reflect.TypeOf(Point{}).Comparable() {
+		t.Error("Point is unexpectedly comparable")
+	}
+}
+
+func TestInvalidEncodings(t *testing.T) {
+	// An invalid point, that also happens to have y > p.
+	invalid := "efffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f"
+	p := NewGeneratorPoint()
+	if out, err := p.SetBytes(decodeHex(invalid)); err == nil {
+		t.Error("expected error for invalid point")
+	} else if out != nil {
+		t.Error("SetBytes did not return nil on an invalid encoding")
+	} else if p.Equal(B) != 1 {
+		t.Error("the Point was modified while decoding an invalid encoding")
+	}
+	checkOnCurve(t, p)
+}
+
+func TestNonCanonicalPoints(t *testing.T) {
+	type test struct {
+		name                string
+		encoding, canonical string
+	}
+	tests := []test{
+		// Points with x = 0 and the sign bit set. With x = 0 the curve equation
+		// gives y² = 1, so y = ±1. 1 has two valid encodings.
+		{
+			"y=1,sign-",
+			"0100000000000000000000000000000000000000000000000000000000000080",
+			"0100000000000000000000000000000000000000000000000000000000000000",
+		},
+		{
+			"y=p+1,sign-",
+			"eeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+			"0100000000000000000000000000000000000000000000000000000000000000",
+		},
+		{
+			"y=p-1,sign-",
+			"ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+			"ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
+		},
+
+		// Non-canonical y encodings with values 2²⁵⁵-19 (p) to 2²⁵⁵-1 (p+18).
+		{
+			"y=p,sign+",
+			"edffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
+			"0000000000000000000000000000000000000000000000000000000000000000",
+		},
+		{
+			"y=p,sign-",
+			"edffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+			"0000000000000000000000000000000000000000000000000000000000000080",
+		},
+		{
+			"y=p+1,sign+",
+			"eeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
+			"0100000000000000000000000000000000000000000000000000000000000000",
+		},
+		// "y=p+1,sign-" is already tested above.
+		// p+2 is not a valid y-coordinate.
+		{
+			"y=p+3,sign+",
+			"f0ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
+			"0300000000000000000000000000000000000000000000000000000000000000",
+		},
+		{
+			"y=p+3,sign-",
+			"f0ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+			"0300000000000000000000000000000000000000000000000000000000000080",
+		},
+		{
+			"y=p+4,sign+",
+			"f1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
+			"0400000000000000000000000000000000000000000000000000000000000000",
+		},
+		{
+			"y=p+4,sign-",
+			"f1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+			"0400000000000000000000000000000000000000000000000000000000000080",
+		},
+		{
+			"y=p+5,sign+",
+			"f2ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
+			"0500000000000000000000000000000000000000000000000000000000000000",
+		},
+		{
+			"y=p+5,sign-",
+			"f2ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+			"0500000000000000000000000000000000000000000000000000000000000080",
+		},
+		{
+			"y=p+6,sign+",
+			"f3ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
+			"0600000000000000000000000000000000000000000000000000000000000000",
+		},
+		{
+			"y=p+6,sign-",
+			"f3ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+			"0600000000000000000000000000000000000000000000000000000000000080",
+		},
+		// p+7 is not a valid y-coordinate.
+		// p+8 is not a valid y-coordinate.
+		{
+			"y=p+9,sign+",
+			"f6ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
+			"0900000000000000000000000000000000000000000000000000000000000000",
+		},
+		{
+			"y=p+9,sign-",
+			"f6ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+			"0900000000000000000000000000000000000000000000000000000000000080",
+		},
+		{
+			"y=p+10,sign+",
+			"f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
+			"0a00000000000000000000000000000000000000000000000000000000000000",
+		},
+		{
+			"y=p+10,sign-",
+			"f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+			"0a00000000000000000000000000000000000000000000000000000000000080",
+		},
+		// p+11 is not a valid y-coordinate.
+		// p+12 is not a valid y-coordinate.
+		// p+13 is not a valid y-coordinate.
+		{
+			"y=p+14,sign+",
+			"fbffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
+			"0e00000000000000000000000000000000000000000000000000000000000000",
+		},
+		{
+			"y=p+14,sign-",
+			"fbffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+			"0e00000000000000000000000000000000000000000000000000000000000080",
+		},
+		{
+			"y=p+15,sign+",
+			"fcffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
+			"0f00000000000000000000000000000000000000000000000000000000000000",
+		},
+		{
+			"y=p+15,sign-",
+			"fcffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+			"0f00000000000000000000000000000000000000000000000000000000000080",
+		},
+		{
+			"y=p+16,sign+",
+			"fdffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
+			"1000000000000000000000000000000000000000000000000000000000000000",
+		},
+		{
+			"y=p+16,sign-",
+			"fdffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+			"1000000000000000000000000000000000000000000000000000000000000080",
+		},
+		// p+17 is not a valid y-coordinate.
+		{
+			"y=p+18,sign+",
+			"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
+			"1200000000000000000000000000000000000000000000000000000000000000",
+		},
+		{
+			"y=p+18,sign-",
+			"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
+			"1200000000000000000000000000000000000000000000000000000000000080",
+		},
+	}
+	for _, tt := range tests {
+		t.Run(tt.name, func(t *testing.T) {
+			p1, err := new(Point).SetBytes(decodeHex(tt.encoding))
+			if err != nil {
+				t.Fatalf("error decoding non-canonical point: %v", err)
+			}
+			p2, err := new(Point).SetBytes(decodeHex(tt.canonical))
+			if err != nil {
+				t.Fatalf("error decoding canonical point: %v", err)
+			}
+			if p1.Equal(p2) != 1 {
+				t.Errorf("equivalent points are not equal: %v, %v", p1, p2)
+			}
+			if encoding := hex.EncodeToString(p1.Bytes()); encoding != tt.canonical {
+				t.Errorf("re-encoding does not match canonical; got %q, expected %q", encoding, tt.canonical)
+			}
+			checkOnCurve(t, p1, p2)
+		})
+	}
+}
+
+var testAllocationsSink byte
+
+func TestAllocations(t *testing.T) {
+	if strings.HasSuffix(os.Getenv("GO_BUILDER_NAME"), "-noopt") {
+		t.Skip("skipping allocations test without relevant optimizations")
+	}
+	if allocs := testing.AllocsPerRun(100, func() {
+		p := NewIdentityPoint()
+		p.Add(p, NewGeneratorPoint())
+		s := NewScalar()
+		testAllocationsSink ^= s.Bytes()[0]
+		testAllocationsSink ^= p.Bytes()[0]
+	}); allocs > 0 {
+		t.Errorf("expected zero allocations, got %0.1v", allocs)
+	}
+}
+
+func decodeHex(s string) []byte {
+	b, err := hex.DecodeString(s)
+	if err != nil {
+		panic(err)
+	}
+	return b
+}
diff --git a/crypto/edwards25519/field/_asm/fe_amd64_asm.go b/crypto/edwards25519/field/_asm/fe_amd64_asm.go
new file mode 100644
index 000000000..fbc0cce22
--- /dev/null
+++ b/crypto/edwards25519/field/_asm/fe_amd64_asm.go
@@ -0,0 +1,294 @@
+// Copyright (c) 2021 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package main
+
+import (
+	"fmt"
+
+	. "github.com/mmcloughlin/avo/build"
+	. "github.com/mmcloughlin/avo/gotypes"
+	. "github.com/mmcloughlin/avo/operand"
+	. "github.com/mmcloughlin/avo/reg"
+)
+
+//go:generate go run . -out ../fe_amd64.s -stubs ../fe_amd64.go -pkg field
+
+func main() {
+	Package("crypto/ed25519/internal/edwards25519/field")
+	ConstraintExpr("amd64,gc,!purego")
+	feMul()
+	feSquare()
+	Generate()
+}
+
+type namedComponent struct {
+	Component
+	name string
+}
+
+func (c namedComponent) String() string { return c.name }
+
+type uint128 struct {
+	name   string
+	hi, lo GPVirtual
+}
+
+func (c uint128) String() string { return c.name }
+
+func feSquare() {
+	TEXT("feSquare", NOSPLIT, "func(out, a *Element)")
+	Doc("feSquare sets out = a * a. It works like feSquareGeneric.")
+	Pragma("noescape")
+
+	a := Dereference(Param("a"))
+	l0 := namedComponent{a.Field("l0"), "l0"}
+	l1 := namedComponent{a.Field("l1"), "l1"}
+	l2 := namedComponent{a.Field("l2"), "l2"}
+	l3 := namedComponent{a.Field("l3"), "l3"}
+	l4 := namedComponent{a.Field("l4"), "l4"}
+
+	// r0 = l0×l0 + 19×2×(l1×l4 + l2×l3)
+	r0 := uint128{"r0", GP64(), GP64()}
+	mul64(r0, 1, l0, l0)
+	addMul64(r0, 38, l1, l4)
+	addMul64(r0, 38, l2, l3)
+
+	// r1 = 2×l0×l1 + 19×2×l2×l4 + 19×l3×l3
+	r1 := uint128{"r1", GP64(), GP64()}
+	mul64(r1, 2, l0, l1)
+	addMul64(r1, 38, l2, l4)
+	addMul64(r1, 19, l3, l3)
+
+	// r2 = = 2×l0×l2 + l1×l1 + 19×2×l3×l4
+	r2 := uint128{"r2", GP64(), GP64()}
+	mul64(r2, 2, l0, l2)
+	addMul64(r2, 1, l1, l1)
+	addMul64(r2, 38, l3, l4)
+
+	// r3 = = 2×l0×l3 + 2×l1×l2 + 19×l4×l4
+	r3 := uint128{"r3", GP64(), GP64()}
+	mul64(r3, 2, l0, l3)
+	addMul64(r3, 2, l1, l2)
+	addMul64(r3, 19, l4, l4)
+
+	// r4 = = 2×l0×l4 + 2×l1×l3 + l2×l2
+	r4 := uint128{"r4", GP64(), GP64()}
+	mul64(r4, 2, l0, l4)
+	addMul64(r4, 2, l1, l3)
+	addMul64(r4, 1, l2, l2)
+
+	Comment("First reduction chain")
+	maskLow51Bits := GP64()
+	MOVQ(Imm((1<<51)-1), maskLow51Bits)
+	c0, r0lo := shiftRightBy51(&r0)
+	c1, r1lo := shiftRightBy51(&r1)
+	c2, r2lo := shiftRightBy51(&r2)
+	c3, r3lo := shiftRightBy51(&r3)
+	c4, r4lo := shiftRightBy51(&r4)
+	maskAndAdd(r0lo, maskLow51Bits, c4, 19)
+	maskAndAdd(r1lo, maskLow51Bits, c0, 1)
+	maskAndAdd(r2lo, maskLow51Bits, c1, 1)
+	maskAndAdd(r3lo, maskLow51Bits, c2, 1)
+	maskAndAdd(r4lo, maskLow51Bits, c3, 1)
+
+	Comment("Second reduction chain (carryPropagate)")
+	// c0 = r0 >> 51
+	MOVQ(r0lo, c0)
+	SHRQ(Imm(51), c0)
+	// c1 = r1 >> 51
+	MOVQ(r1lo, c1)
+	SHRQ(Imm(51), c1)
+	// c2 = r2 >> 51
+	MOVQ(r2lo, c2)
+	SHRQ(Imm(51), c2)
+	// c3 = r3 >> 51
+	MOVQ(r3lo, c3)
+	SHRQ(Imm(51), c3)
+	// c4 = r4 >> 51
+	MOVQ(r4lo, c4)
+	SHRQ(Imm(51), c4)
+	maskAndAdd(r0lo, maskLow51Bits, c4, 19)
+	maskAndAdd(r1lo, maskLow51Bits, c0, 1)
+	maskAndAdd(r2lo, maskLow51Bits, c1, 1)
+	maskAndAdd(r3lo, maskLow51Bits, c2, 1)
+	maskAndAdd(r4lo, maskLow51Bits, c3, 1)
+
+	Comment("Store output")
+	out := Dereference(Param("out"))
+	Store(r0lo, out.Field("l0"))
+	Store(r1lo, out.Field("l1"))
+	Store(r2lo, out.Field("l2"))
+	Store(r3lo, out.Field("l3"))
+	Store(r4lo, out.Field("l4"))
+
+	RET()
+}
+
+func feMul() {
+	TEXT("feMul", NOSPLIT, "func(out, a, b *Element)")
+	Doc("feMul sets out = a * b. It works like feMulGeneric.")
+	Pragma("noescape")
+
+	a := Dereference(Param("a"))
+	a0 := namedComponent{a.Field("l0"), "a0"}
+	a1 := namedComponent{a.Field("l1"), "a1"}
+	a2 := namedComponent{a.Field("l2"), "a2"}
+	a3 := namedComponent{a.Field("l3"), "a3"}
+	a4 := namedComponent{a.Field("l4"), "a4"}
+
+	b := Dereference(Param("b"))
+	b0 := namedComponent{b.Field("l0"), "b0"}
+	b1 := namedComponent{b.Field("l1"), "b1"}
+	b2 := namedComponent{b.Field("l2"), "b2"}
+	b3 := namedComponent{b.Field("l3"), "b3"}
+	b4 := namedComponent{b.Field("l4"), "b4"}
+
+	// r0 = a0×b0 + 19×(a1×b4 + a2×b3 + a3×b2 + a4×b1)
+	r0 := uint128{"r0", GP64(), GP64()}
+	mul64(r0, 1, a0, b0)
+	addMul64(r0, 19, a1, b4)
+	addMul64(r0, 19, a2, b3)
+	addMul64(r0, 19, a3, b2)
+	addMul64(r0, 19, a4, b1)
+
+	// r1 = a0×b1 + a1×b0 + 19×(a2×b4 + a3×b3 + a4×b2)
+	r1 := uint128{"r1", GP64(), GP64()}
+	mul64(r1, 1, a0, b1)
+	addMul64(r1, 1, a1, b0)
+	addMul64(r1, 19, a2, b4)
+	addMul64(r1, 19, a3, b3)
+	addMul64(r1, 19, a4, b2)
+
+	// r2 = a0×b2 + a1×b1 + a2×b0 + 19×(a3×b4 + a4×b3)
+	r2 := uint128{"r2", GP64(), GP64()}
+	mul64(r2, 1, a0, b2)
+	addMul64(r2, 1, a1, b1)
+	addMul64(r2, 1, a2, b0)
+	addMul64(r2, 19, a3, b4)
+	addMul64(r2, 19, a4, b3)
+
+	// r3 = a0×b3 + a1×b2 + a2×b1 + a3×b0 + 19×a4×b4
+	r3 := uint128{"r3", GP64(), GP64()}
+	mul64(r3, 1, a0, b3)
+	addMul64(r3, 1, a1, b2)
+	addMul64(r3, 1, a2, b1)
+	addMul64(r3, 1, a3, b0)
+	addMul64(r3, 19, a4, b4)
+
+	// r4 = a0×b4 + a1×b3 + a2×b2 + a3×b1 + a4×b0
+	r4 := uint128{"r4", GP64(), GP64()}
+	mul64(r4, 1, a0, b4)
+	addMul64(r4, 1, a1, b3)
+	addMul64(r4, 1, a2, b2)
+	addMul64(r4, 1, a3, b1)
+	addMul64(r4, 1, a4, b0)
+
+	Comment("First reduction chain")
+	maskLow51Bits := GP64()
+	MOVQ(Imm((1<<51)-1), maskLow51Bits)
+	c0, r0lo := shiftRightBy51(&r0)
+	c1, r1lo := shiftRightBy51(&r1)
+	c2, r2lo := shiftRightBy51(&r2)
+	c3, r3lo := shiftRightBy51(&r3)
+	c4, r4lo := shiftRightBy51(&r4)
+	maskAndAdd(r0lo, maskLow51Bits, c4, 19)
+	maskAndAdd(r1lo, maskLow51Bits, c0, 1)
+	maskAndAdd(r2lo, maskLow51Bits, c1, 1)
+	maskAndAdd(r3lo, maskLow51Bits, c2, 1)
+	maskAndAdd(r4lo, maskLow51Bits, c3, 1)
+
+	Comment("Second reduction chain (carryPropagate)")
+	// c0 = r0 >> 51
+	MOVQ(r0lo, c0)
+	SHRQ(Imm(51), c0)
+	// c1 = r1 >> 51
+	MOVQ(r1lo, c1)
+	SHRQ(Imm(51), c1)
+	// c2 = r2 >> 51
+	MOVQ(r2lo, c2)
+	SHRQ(Imm(51), c2)
+	// c3 = r3 >> 51
+	MOVQ(r3lo, c3)
+	SHRQ(Imm(51), c3)
+	// c4 = r4 >> 51
+	MOVQ(r4lo, c4)
+	SHRQ(Imm(51), c4)
+	maskAndAdd(r0lo, maskLow51Bits, c4, 19)
+	maskAndAdd(r1lo, maskLow51Bits, c0, 1)
+	maskAndAdd(r2lo, maskLow51Bits, c1, 1)
+	maskAndAdd(r3lo, maskLow51Bits, c2, 1)
+	maskAndAdd(r4lo, maskLow51Bits, c3, 1)
+
+	Comment("Store output")
+	out := Dereference(Param("out"))
+	Store(r0lo, out.Field("l0"))
+	Store(r1lo, out.Field("l1"))
+	Store(r2lo, out.Field("l2"))
+	Store(r3lo, out.Field("l3"))
+	Store(r4lo, out.Field("l4"))
+
+	RET()
+}
+
+// mul64 sets r to i * aX * bX.
+func mul64(r uint128, i int, aX, bX namedComponent) {
+	switch i {
+	case 1:
+		Comment(fmt.Sprintf("%s = %s×%s", r, aX, bX))
+		Load(aX, RAX)
+	case 2:
+		Comment(fmt.Sprintf("%s = 2×%s×%s", r, aX, bX))
+		Load(aX, RAX)
+		SHLQ(Imm(1), RAX)
+	default:
+		panic("unsupported i value")
+	}
+	MULQ(mustAddr(bX)) // RDX, RAX = RAX * bX
+	MOVQ(RAX, r.lo)
+	MOVQ(RDX, r.hi)
+}
+
+// addMul64 sets r to r + i * aX * bX.
+func addMul64(r uint128, i uint64, aX, bX namedComponent) {
+	switch i {
+	case 1:
+		Comment(fmt.Sprintf("%s += %s×%s", r, aX, bX))
+		Load(aX, RAX)
+	default:
+		Comment(fmt.Sprintf("%s += %d×%s×%s", r, i, aX, bX))
+		IMUL3Q(Imm(i), Load(aX, GP64()), RAX)
+	}
+	MULQ(mustAddr(bX)) // RDX, RAX = RAX * bX
+	ADDQ(RAX, r.lo)
+	ADCQ(RDX, r.hi)
+}
+
+// shiftRightBy51 returns r >> 51 and r.lo.
+//
+// After this function is called, the uint128 may not be used anymore.
+func shiftRightBy51(r *uint128) (out, lo GPVirtual) {
+	out = r.hi
+	lo = r.lo
+	SHLQ(Imm(64-51), r.lo, r.hi)
+	r.lo, r.hi = nil, nil // make sure the uint128 is unusable
+	return
+}
+
+// maskAndAdd sets r = r&mask + c*i.
+func maskAndAdd(r, mask, c GPVirtual, i uint64) {
+	ANDQ(mask, r)
+	if i != 1 {
+		IMUL3Q(Imm(i), c, c)
+	}
+	ADDQ(c, r)
+}
+
+func mustAddr(c Component) Op {
+	b, err := c.Resolve()
+	if err != nil {
+		panic(err)
+	}
+	return b.Addr
+}
diff --git a/crypto/edwards25519/field/_asm/go.mod b/crypto/edwards25519/field/_asm/go.mod
new file mode 100644
index 000000000..1127ade87
--- /dev/null
+++ b/crypto/edwards25519/field/_asm/go.mod
@@ -0,0 +1,5 @@
+module asm
+
+go 1.16
+
+require github.com/mmcloughlin/avo v0.2.0
diff --git a/crypto/edwards25519/field/_asm/go.sum b/crypto/edwards25519/field/_asm/go.sum
new file mode 100644
index 000000000..dae47774a
--- /dev/null
+++ b/crypto/edwards25519/field/_asm/go.sum
@@ -0,0 +1,31 @@
+github.com/mmcloughlin/avo v0.2.0 h1:6vhoSaKtxb6f4RiH+LK2qL6GSMpFzhEwJYTTSZNy09w=
+github.com/mmcloughlin/avo v0.2.0/go.mod h1:5tidO2Z9Z7N6X7UMcGg+1KTj51O8OxYDCMHxCZTVpEA=
+github.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
+golang.org/x/arch v0.0.0-20210405154355-08b684f594a5/go.mod h1:flIaEI6LNU6xOCD5PaJvn9wGP0agmIOqjrtsKGRguv4=
+golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
+golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
+golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
+golang.org/x/mod v0.3.0 h1:RM4zey1++hCTbCVQfnWeKs9/IEsaBLA8vTkd0WVtmH4=
+golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
+golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
+golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
+golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
+golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
+golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
+golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
+golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20210403161142-5e06dd20ab57 h1:F5Gozwx4I1xtr/sr/8CFbb57iKi3297KFs0QDbGN60A=
+golang.org/x/sys v0.0.0-20210403161142-5e06dd20ab57/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
+golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
+golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
+golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
+golang.org/x/tools v0.1.0 h1:po9/4sTYwZU9lPhi1tOrb4hCv3qrhiQ77LZfGa2OjwY=
+golang.org/x/tools v0.1.0/go.mod h1:xkSsbof2nBLbhDlRMhhhyNLN/zl3eTqcnHD5viDpcZ0=
+golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
+golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
+golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 h1:go1bK/D/BFZV2I8cIQd1NKEZ+0owSTG1fDTci4IqFcE=
+golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
+rsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=
diff --git a/crypto/edwards25519/field/fe.go b/crypto/edwards25519/field/fe.go
new file mode 100644
index 000000000..dbe86599b
--- /dev/null
+++ b/crypto/edwards25519/field/fe.go
@@ -0,0 +1,416 @@
+// Copyright (c) 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package field implements fast arithmetic modulo 2^255-19.
+package field
+
+import (
+	"crypto/subtle"
+	"encoding/binary"
+	"math/bits"
+)
+
+// Element represents an element of the field GF(2^255-19). Note that this
+// is not a cryptographically secure group, and should only be used to interact
+// with edwards25519.Point coordinates.
+//
+// This type works similarly to math/big.Int, and all arguments and receivers
+// are allowed to alias.
+//
+// The zero value is a valid zero element.
+type Element struct {
+	// An element t represents the integer
+	//     t.l0 + t.l1*2^51 + t.l2*2^102 + t.l3*2^153 + t.l4*2^204
+	//
+	// Between operations, all limbs are expected to be lower than 2^52.
+	l0 uint64
+	l1 uint64
+	l2 uint64
+	l3 uint64
+	l4 uint64
+}
+
+const maskLow51Bits uint64 = (1 << 51) - 1
+
+var feZero = &Element{0, 0, 0, 0, 0}
+
+// Zero sets v = 0, and returns v.
+func (v *Element) Zero() *Element {
+	*v = *feZero
+	return v
+}
+
+var feOne = &Element{1, 0, 0, 0, 0}
+
+// One sets v = 1, and returns v.
+func (v *Element) One() *Element {
+	*v = *feOne
+	return v
+}
+
+// reduce reduces v modulo 2^255 - 19 and returns it.
+func (v *Element) reduce() *Element {
+	v.carryPropagate()
+
+	// After the light reduction we now have a field element representation
+	// v < 2^255 + 2^13 * 19, but need v < 2^255 - 19.
+
+	// If v >= 2^255 - 19, then v + 19 >= 2^255, which would overflow 2^255 - 1,
+	// generating a carry. That is, c will be 0 if v < 2^255 - 19, and 1 otherwise.
+	c := (v.l0 + 19) >> 51
+	c = (v.l1 + c) >> 51
+	c = (v.l2 + c) >> 51
+	c = (v.l3 + c) >> 51
+	c = (v.l4 + c) >> 51
+
+	// If v < 2^255 - 19 and c = 0, this will be a no-op. Otherwise, it's
+	// effectively applying the reduction identity to the carry.
+	v.l0 += 19 * c
+
+	v.l1 += v.l0 >> 51
+	v.l0 = v.l0 & maskLow51Bits
+	v.l2 += v.l1 >> 51
+	v.l1 = v.l1 & maskLow51Bits
+	v.l3 += v.l2 >> 51
+	v.l2 = v.l2 & maskLow51Bits
+	v.l4 += v.l3 >> 51
+	v.l3 = v.l3 & maskLow51Bits
+	// no additional carry
+	v.l4 = v.l4 & maskLow51Bits
+
+	return v
+}
+
+// Add sets v = a + b, and returns v.
+func (v *Element) Add(a, b *Element) *Element {
+	v.l0 = a.l0 + b.l0
+	v.l1 = a.l1 + b.l1
+	v.l2 = a.l2 + b.l2
+	v.l3 = a.l3 + b.l3
+	v.l4 = a.l4 + b.l4
+	// Using the generic implementation here is actually faster than the
+	// assembly. Probably because the body of this function is so simple that
+	// the compiler can figure out better optimizations by inlining the carry
+	// propagation.
+	return v.carryPropagateGeneric()
+}
+
+// Subtract sets v = a - b, and returns v.
+func (v *Element) Subtract(a, b *Element) *Element {
+	// We first add 2 * p, to guarantee the subtraction won't underflow, and
+	// then subtract b (which can be up to 2^255 + 2^13 * 19).
+	v.l0 = (a.l0 + 0xFFFFFFFFFFFDA) - b.l0
+	v.l1 = (a.l1 + 0xFFFFFFFFFFFFE) - b.l1
+	v.l2 = (a.l2 + 0xFFFFFFFFFFFFE) - b.l2
+	v.l3 = (a.l3 + 0xFFFFFFFFFFFFE) - b.l3
+	v.l4 = (a.l4 + 0xFFFFFFFFFFFFE) - b.l4
+	return v.carryPropagate()
+}
+
+// Negate sets v = -a, and returns v.
+func (v *Element) Negate(a *Element) *Element {
+	return v.Subtract(feZero, a)
+}
+
+// Invert sets v = 1/z mod p, and returns v.
+//
+// If z == 0, Invert returns v = 0.
+func (v *Element) Invert(z *Element) *Element {
+	// Inversion is implemented as exponentiation with exponent p − 2. It uses the
+	// same sequence of 255 squarings and 11 multiplications as [Curve25519].
+	var z2, z9, z11, z2_5_0, z2_10_0, z2_20_0, z2_50_0, z2_100_0, t Element
+
+	z2.Square(z)             // 2
+	t.Square(&z2)            // 4
+	t.Square(&t)             // 8
+	z9.Multiply(&t, z)       // 9
+	z11.Multiply(&z9, &z2)   // 11
+	t.Square(&z11)           // 22
+	z2_5_0.Multiply(&t, &z9) // 31 = 2^5 - 2^0
+
+	t.Square(&z2_5_0) // 2^6 - 2^1
+	for i := 0; i < 4; i++ {
+		t.Square(&t) // 2^10 - 2^5
+	}
+	z2_10_0.Multiply(&t, &z2_5_0) // 2^10 - 2^0
+
+	t.Square(&z2_10_0) // 2^11 - 2^1
+	for i := 0; i < 9; i++ {
+		t.Square(&t) // 2^20 - 2^10
+	}
+	z2_20_0.Multiply(&t, &z2_10_0) // 2^20 - 2^0
+
+	t.Square(&z2_20_0) // 2^21 - 2^1
+	for i := 0; i < 19; i++ {
+		t.Square(&t) // 2^40 - 2^20
+	}
+	t.Multiply(&t, &z2_20_0) // 2^40 - 2^0
+
+	t.Square(&t) // 2^41 - 2^1
+	for i := 0; i < 9; i++ {
+		t.Square(&t) // 2^50 - 2^10
+	}
+	z2_50_0.Multiply(&t, &z2_10_0) // 2^50 - 2^0
+
+	t.Square(&z2_50_0) // 2^51 - 2^1
+	for i := 0; i < 49; i++ {
+		t.Square(&t) // 2^100 - 2^50
+	}
+	z2_100_0.Multiply(&t, &z2_50_0) // 2^100 - 2^0
+
+	t.Square(&z2_100_0) // 2^101 - 2^1
+	for i := 0; i < 99; i++ {
+		t.Square(&t) // 2^200 - 2^100
+	}
+	t.Multiply(&t, &z2_100_0) // 2^200 - 2^0
+
+	t.Square(&t) // 2^201 - 2^1
+	for i := 0; i < 49; i++ {
+		t.Square(&t) // 2^250 - 2^50
+	}
+	t.Multiply(&t, &z2_50_0) // 2^250 - 2^0
+
+	t.Square(&t) // 2^251 - 2^1
+	t.Square(&t) // 2^252 - 2^2
+	t.Square(&t) // 2^253 - 2^3
+	t.Square(&t) // 2^254 - 2^4
+	t.Square(&t) // 2^255 - 2^5
+
+	return v.Multiply(&t, &z11) // 2^255 - 21
+}
+
+// Set sets v = a, and returns v.
+func (v *Element) Set(a *Element) *Element {
+	*v = *a
+	return v
+}
+
+// SetBytes sets v to x, which must be a 32-byte little-endian encoding.
+//
+// Consistent with RFC 7748, the most significant bit (the high bit of the
+// last byte) is ignored, and non-canonical values (2^255-19 through 2^255-1)
+// are accepted. Note that this is laxer than specified by RFC 8032.
+func (v *Element) SetBytes(x []byte) *Element {
+	if len(x) != 32 {
+		panic("edwards25519: invalid field element input size")
+	}
+
+	// Bits 0:51 (bytes 0:8, bits 0:64, shift 0, mask 51).
+	v.l0 = binary.LittleEndian.Uint64(x[0:8])
+	v.l0 &= maskLow51Bits
+	// Bits 51:102 (bytes 6:14, bits 48:112, shift 3, mask 51).
+	v.l1 = binary.LittleEndian.Uint64(x[6:14]) >> 3
+	v.l1 &= maskLow51Bits
+	// Bits 102:153 (bytes 12:20, bits 96:160, shift 6, mask 51).
+	v.l2 = binary.LittleEndian.Uint64(x[12:20]) >> 6
+	v.l2 &= maskLow51Bits
+	// Bits 153:204 (bytes 19:27, bits 152:216, shift 1, mask 51).
+	v.l3 = binary.LittleEndian.Uint64(x[19:27]) >> 1
+	v.l3 &= maskLow51Bits
+	// Bits 204:251 (bytes 24:32, bits 192:256, shift 12, mask 51).
+	// Note: not bytes 25:33, shift 4, to avoid overread.
+	v.l4 = binary.LittleEndian.Uint64(x[24:32]) >> 12
+	v.l4 &= maskLow51Bits
+
+	return v
+}
+
+// Bytes returns the canonical 32-byte little-endian encoding of v.
+func (v *Element) Bytes() []byte {
+	// This function is outlined to make the allocations inline in the caller
+	// rather than happen on the heap.
+	var out [32]byte
+	return v.bytes(&out)
+}
+
+func (v *Element) bytes(out *[32]byte) []byte {
+	t := *v
+	t.reduce()
+
+	var buf [8]byte
+	for i, l := range [5]uint64{t.l0, t.l1, t.l2, t.l3, t.l4} {
+		bitsOffset := i * 51
+		binary.LittleEndian.PutUint64(buf[:], l<<uint(bitsOffset%8))
+		for i, bb := range buf {
+			off := bitsOffset/8 + i
+			if off >= len(out) {
+				break
+			}
+			out[off] |= bb
+		}
+	}
+
+	return out[:]
+}
+
+// Equal returns 1 if v and u are equal, and 0 otherwise.
+func (v *Element) Equal(u *Element) int {
+	sa, sv := u.Bytes(), v.Bytes()
+	return subtle.ConstantTimeCompare(sa, sv)
+}
+
+// mask64Bits returns 0xffffffff if cond is 1, and 0 otherwise.
+func mask64Bits(cond int) uint64 { return ^(uint64(cond) - 1) }
+
+// Select sets v to a if cond == 1, and to b if cond == 0.
+func (v *Element) Select(a, b *Element, cond int) *Element {
+	m := mask64Bits(cond)
+	v.l0 = (m & a.l0) | (^m & b.l0)
+	v.l1 = (m & a.l1) | (^m & b.l1)
+	v.l2 = (m & a.l2) | (^m & b.l2)
+	v.l3 = (m & a.l3) | (^m & b.l3)
+	v.l4 = (m & a.l4) | (^m & b.l4)
+	return v
+}
+
+// Swap swaps v and u if cond == 1 or leaves them unchanged if cond == 0, and returns v.
+func (v *Element) Swap(u *Element, cond int) {
+	m := mask64Bits(cond)
+	t := m & (v.l0 ^ u.l0)
+	v.l0 ^= t
+	u.l0 ^= t
+	t = m & (v.l1 ^ u.l1)
+	v.l1 ^= t
+	u.l1 ^= t
+	t = m & (v.l2 ^ u.l2)
+	v.l2 ^= t
+	u.l2 ^= t
+	t = m & (v.l3 ^ u.l3)
+	v.l3 ^= t
+	u.l3 ^= t
+	t = m & (v.l4 ^ u.l4)
+	v.l4 ^= t
+	u.l4 ^= t
+}
+
+// IsNegative returns 1 if v is negative, and 0 otherwise.
+func (v *Element) IsNegative() int {
+	return int(v.Bytes()[0] & 1)
+}
+
+// Absolute sets v to |u|, and returns v.
+func (v *Element) Absolute(u *Element) *Element {
+	return v.Select(new(Element).Negate(u), u, u.IsNegative())
+}
+
+// Multiply sets v = x * y, and returns v.
+func (v *Element) Multiply(x, y *Element) *Element {
+	feMul(v, x, y)
+	return v
+}
+
+// Square sets v = x * x, and returns v.
+func (v *Element) Square(x *Element) *Element {
+	feSquare(v, x)
+	return v
+}
+
+// Mult32 sets v = x * y, and returns v.
+func (v *Element) Mult32(x *Element, y uint32) *Element {
+	x0lo, x0hi := mul51(x.l0, y)
+	x1lo, x1hi := mul51(x.l1, y)
+	x2lo, x2hi := mul51(x.l2, y)
+	x3lo, x3hi := mul51(x.l3, y)
+	x4lo, x4hi := mul51(x.l4, y)
+	v.l0 = x0lo + 19*x4hi // carried over per the reduction identity
+	v.l1 = x1lo + x0hi
+	v.l2 = x2lo + x1hi
+	v.l3 = x3lo + x2hi
+	v.l4 = x4lo + x3hi
+	// The hi portions are going to be only 32 bits, plus any previous excess,
+	// so we can skip the carry propagation.
+	return v
+}
+
+// mul51 returns lo + hi * 2⁵¹ = a * b.
+func mul51(a uint64, b uint32) (lo uint64, hi uint64) {
+	mh, ml := bits.Mul64(a, uint64(b))
+	lo = ml & maskLow51Bits
+	hi = (mh << 13) | (ml >> 51)
+	return
+}
+
+// Pow22523 set v = x^((p-5)/8), and returns v. (p-5)/8 is 2^252-3.
+func (v *Element) Pow22523(x *Element) *Element {
+	var t0, t1, t2 Element
+
+	t0.Square(x)             // x^2
+	t1.Square(&t0)           // x^4
+	t1.Square(&t1)           // x^8
+	t1.Multiply(x, &t1)      // x^9
+	t0.Multiply(&t0, &t1)    // x^11
+	t0.Square(&t0)           // x^22
+	t0.Multiply(&t1, &t0)    // x^31
+	t1.Square(&t0)           // x^62
+	for i := 1; i < 5; i++ { // x^992
+		t1.Square(&t1)
+	}
+	t0.Multiply(&t1, &t0)     // x^1023 -> 1023 = 2^10 - 1
+	t1.Square(&t0)            // 2^11 - 2
+	for i := 1; i < 10; i++ { // 2^20 - 2^10
+		t1.Square(&t1)
+	}
+	t1.Multiply(&t1, &t0)     // 2^20 - 1
+	t2.Square(&t1)            // 2^21 - 2
+	for i := 1; i < 20; i++ { // 2^40 - 2^20
+		t2.Square(&t2)
+	}
+	t1.Multiply(&t2, &t1)     // 2^40 - 1
+	t1.Square(&t1)            // 2^41 - 2
+	for i := 1; i < 10; i++ { // 2^50 - 2^10
+		t1.Square(&t1)
+	}
+	t0.Multiply(&t1, &t0)     // 2^50 - 1
+	t1.Square(&t0)            // 2^51 - 2
+	for i := 1; i < 50; i++ { // 2^100 - 2^50
+		t1.Square(&t1)
+	}
+	t1.Multiply(&t1, &t0)      // 2^100 - 1
+	t2.Square(&t1)             // 2^101 - 2
+	for i := 1; i < 100; i++ { // 2^200 - 2^100
+		t2.Square(&t2)
+	}
+	t1.Multiply(&t2, &t1)     // 2^200 - 1
+	t1.Square(&t1)            // 2^201 - 2
+	for i := 1; i < 50; i++ { // 2^250 - 2^50
+		t1.Square(&t1)
+	}
+	t0.Multiply(&t1, &t0)     // 2^250 - 1
+	t0.Square(&t0)            // 2^251 - 2
+	t0.Square(&t0)            // 2^252 - 4
+	return v.Multiply(&t0, x) // 2^252 - 3 -> x^(2^252-3)
+}
+
+// sqrtM1 is 2^((p-1)/4), which squared is equal to -1 by Euler's Criterion.
+var sqrtM1 = &Element{1718705420411056, 234908883556509,
+	2233514472574048, 2117202627021982, 765476049583133}
+
+// SqrtRatio sets r to the non-negative square root of the ratio of u and v.
+//
+// If u/v is square, SqrtRatio returns r and 1. If u/v is not square, SqrtRatio
+// sets r according to Section 4.3 of draft-irtf-cfrg-ristretto255-decaf448-00,
+// and returns r and 0.
+func (r *Element) SqrtRatio(u, v *Element) (rr *Element, wasSquare int) {
+	var a, b Element
+
+	// r = (u * v3) * (u * v7)^((p-5)/8)
+	v2 := a.Square(v)
+	uv3 := b.Multiply(u, b.Multiply(v2, v))
+	uv7 := a.Multiply(uv3, a.Square(v2))
+	r.Multiply(uv3, r.Pow22523(uv7))
+
+	check := a.Multiply(v, a.Square(r)) // check = v * r^2
+
+	uNeg := b.Negate(u)
+	correctSignSqrt := check.Equal(u)
+	flippedSignSqrt := check.Equal(uNeg)
+	flippedSignSqrtI := check.Equal(uNeg.Multiply(uNeg, sqrtM1))
+
+	rPrime := b.Multiply(r, sqrtM1) // r_prime = SQRT_M1 * r
+	// r = CT_SELECT(r_prime IF flipped_sign_sqrt | flipped_sign_sqrt_i ELSE r)
+	r.Select(rPrime, r, flippedSignSqrt|flippedSignSqrtI)
+
+	r.Absolute(r) // Choose the nonnegative square root.
+	return r, correctSignSqrt | flippedSignSqrt
+}
diff --git a/crypto/edwards25519/field/fe_alias_test.go b/crypto/edwards25519/field/fe_alias_test.go
new file mode 100644
index 000000000..5ad81df01
--- /dev/null
+++ b/crypto/edwards25519/field/fe_alias_test.go
@@ -0,0 +1,126 @@
+// Copyright (c) 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package field
+
+import (
+	"testing"
+	"testing/quick"
+)
+
+func checkAliasingOneArg(f func(v, x *Element) *Element) func(v, x Element) bool {
+	return func(v, x Element) bool {
+		x1, v1 := x, x
+
+		// Calculate a reference f(x) without aliasing.
+		if out := f(&v, &x); out != &v && isInBounds(out) {
+			return false
+		}
+
+		// Test aliasing the argument and the receiver.
+		if out := f(&v1, &v1); out != &v1 || v1 != v {
+			return false
+		}
+
+		// Ensure the arguments was not modified.
+		return x == x1
+	}
+}
+
+func checkAliasingTwoArgs(f func(v, x, y *Element) *Element) func(v, x, y Element) bool {
+	return func(v, x, y Element) bool {
+		x1, y1, v1 := x, y, Element{}
+
+		// Calculate a reference f(x, y) without aliasing.
+		if out := f(&v, &x, &y); out != &v && isInBounds(out) {
+			return false
+		}
+
+		// Test aliasing the first argument and the receiver.
+		v1 = x
+		if out := f(&v1, &v1, &y); out != &v1 || v1 != v {
+			return false
+		}
+		// Test aliasing the second argument and the receiver.
+		v1 = y
+		if out := f(&v1, &x, &v1); out != &v1 || v1 != v {
+			return false
+		}
+
+		// Calculate a reference f(x, x) without aliasing.
+		if out := f(&v, &x, &x); out != &v {
+			return false
+		}
+
+		// Test aliasing the first argument and the receiver.
+		v1 = x
+		if out := f(&v1, &v1, &x); out != &v1 || v1 != v {
+			return false
+		}
+		// Test aliasing the second argument and the receiver.
+		v1 = x
+		if out := f(&v1, &x, &v1); out != &v1 || v1 != v {
+			return false
+		}
+		// Test aliasing both arguments and the receiver.
+		v1 = x
+		if out := f(&v1, &v1, &v1); out != &v1 || v1 != v {
+			return false
+		}
+
+		// Ensure the arguments were not modified.
+		return x == x1 && y == y1
+	}
+}
+
+// TestAliasing checks that receivers and arguments can alias each other without
+// leading to incorrect results. That is, it ensures that it's safe to write
+//
+//     v.Invert(v)
+//
+// or
+//
+//     v.Add(v, v)
+//
+// without any of the inputs getting clobbered by the output being written.
+func TestAliasing(t *testing.T) {
+	type target struct {
+		name     string
+		oneArgF  func(v, x *Element) *Element
+		twoArgsF func(v, x, y *Element) *Element
+	}
+	for _, tt := range []target{
+		{name: "Absolute", oneArgF: (*Element).Absolute},
+		{name: "Invert", oneArgF: (*Element).Invert},
+		{name: "Negate", oneArgF: (*Element).Negate},
+		{name: "Set", oneArgF: (*Element).Set},
+		{name: "Square", oneArgF: (*Element).Square},
+		{name: "Multiply", twoArgsF: (*Element).Multiply},
+		{name: "Add", twoArgsF: (*Element).Add},
+		{name: "Subtract", twoArgsF: (*Element).Subtract},
+		{
+			name: "Select0",
+			twoArgsF: func(v, x, y *Element) *Element {
+				return (*Element).Select(v, x, y, 0)
+			},
+		},
+		{
+			name: "Select1",
+			twoArgsF: func(v, x, y *Element) *Element {
+				return (*Element).Select(v, x, y, 1)
+			},
+		},
+	} {
+		var err error
+		switch {
+		case tt.oneArgF != nil:
+			err = quick.Check(checkAliasingOneArg(tt.oneArgF), &quick.Config{MaxCountScale: 1 << 8})
+		case tt.twoArgsF != nil:
+			err = quick.Check(checkAliasingTwoArgs(tt.twoArgsF), &quick.Config{MaxCountScale: 1 << 8})
+		}
+		if err != nil {
+			t.Errorf("%v: %v", tt.name, err)
+		}
+	}
+}
diff --git a/crypto/edwards25519/field/fe_amd64.go b/crypto/edwards25519/field/fe_amd64.go
new file mode 100644
index 000000000..363020bd6
--- /dev/null
+++ b/crypto/edwards25519/field/fe_amd64.go
@@ -0,0 +1,13 @@
+// Code generated by command: go run fe_amd64_asm.go -out ../fe_amd64.s -stubs ../fe_amd64.go -pkg field. DO NOT EDIT.
+
+//go:build amd64 && gc && !purego
+
+package field
+
+// feMul sets out = a * b. It works like feMulGeneric.
+//go:noescape
+func feMul(out *Element, a *Element, b *Element)
+
+// feSquare sets out = a * a. It works like feSquareGeneric.
+//go:noescape
+func feSquare(out *Element, a *Element)
diff --git a/crypto/edwards25519/field/fe_amd64.s b/crypto/edwards25519/field/fe_amd64.s
new file mode 100644
index 000000000..0aa1e86d9
--- /dev/null
+++ b/crypto/edwards25519/field/fe_amd64.s
@@ -0,0 +1,378 @@
+// Code generated by command: go run fe_amd64_asm.go -out ../fe_amd64.s -stubs ../fe_amd64.go -pkg field. DO NOT EDIT.
+
+// +build amd64,gc,!purego
+
+#include "textflag.h"
+
+// func feMul(out *Element, a *Element, b *Element)
+TEXT ·feMul(SB), NOSPLIT, $0-24
+	MOVQ a+8(FP), CX
+	MOVQ b+16(FP), BX
+
+	// r0 = a0×b0
+	MOVQ (CX), AX
+	MULQ (BX)
+	MOVQ AX, DI
+	MOVQ DX, SI
+
+	// r0 += 19×a1×b4
+	MOVQ   8(CX), AX
+	IMUL3Q $0x13, AX, AX
+	MULQ   32(BX)
+	ADDQ   AX, DI
+	ADCQ   DX, SI
+
+	// r0 += 19×a2×b3
+	MOVQ   16(CX), AX
+	IMUL3Q $0x13, AX, AX
+	MULQ   24(BX)
+	ADDQ   AX, DI
+	ADCQ   DX, SI
+
+	// r0 += 19×a3×b2
+	MOVQ   24(CX), AX
+	IMUL3Q $0x13, AX, AX
+	MULQ   16(BX)
+	ADDQ   AX, DI
+	ADCQ   DX, SI
+
+	// r0 += 19×a4×b1
+	MOVQ   32(CX), AX
+	IMUL3Q $0x13, AX, AX
+	MULQ   8(BX)
+	ADDQ   AX, DI
+	ADCQ   DX, SI
+
+	// r1 = a0×b1
+	MOVQ (CX), AX
+	MULQ 8(BX)
+	MOVQ AX, R9
+	MOVQ DX, R8
+
+	// r1 += a1×b0
+	MOVQ 8(CX), AX
+	MULQ (BX)
+	ADDQ AX, R9
+	ADCQ DX, R8
+
+	// r1 += 19×a2×b4
+	MOVQ   16(CX), AX
+	IMUL3Q $0x13, AX, AX
+	MULQ   32(BX)
+	ADDQ   AX, R9
+	ADCQ   DX, R8
+
+	// r1 += 19×a3×b3
+	MOVQ   24(CX), AX
+	IMUL3Q $0x13, AX, AX
+	MULQ   24(BX)
+	ADDQ   AX, R9
+	ADCQ   DX, R8
+
+	// r1 += 19×a4×b2
+	MOVQ   32(CX), AX
+	IMUL3Q $0x13, AX, AX
+	MULQ   16(BX)
+	ADDQ   AX, R9
+	ADCQ   DX, R8
+
+	// r2 = a0×b2
+	MOVQ (CX), AX
+	MULQ 16(BX)
+	MOVQ AX, R11
+	MOVQ DX, R10
+
+	// r2 += a1×b1
+	MOVQ 8(CX), AX
+	MULQ 8(BX)
+	ADDQ AX, R11
+	ADCQ DX, R10
+
+	// r2 += a2×b0
+	MOVQ 16(CX), AX
+	MULQ (BX)
+	ADDQ AX, R11
+	ADCQ DX, R10
+
+	// r2 += 19×a3×b4
+	MOVQ   24(CX), AX
+	IMUL3Q $0x13, AX, AX
+	MULQ   32(BX)
+	ADDQ   AX, R11
+	ADCQ   DX, R10
+
+	// r2 += 19×a4×b3
+	MOVQ   32(CX), AX
+	IMUL3Q $0x13, AX, AX
+	MULQ   24(BX)
+	ADDQ   AX, R11
+	ADCQ   DX, R10
+
+	// r3 = a0×b3
+	MOVQ (CX), AX
+	MULQ 24(BX)
+	MOVQ AX, R13
+	MOVQ DX, R12
+
+	// r3 += a1×b2
+	MOVQ 8(CX), AX
+	MULQ 16(BX)
+	ADDQ AX, R13
+	ADCQ DX, R12
+
+	// r3 += a2×b1
+	MOVQ 16(CX), AX
+	MULQ 8(BX)
+	ADDQ AX, R13
+	ADCQ DX, R12
+
+	// r3 += a3×b0
+	MOVQ 24(CX), AX
+	MULQ (BX)
+	ADDQ AX, R13
+	ADCQ DX, R12
+
+	// r3 += 19×a4×b4
+	MOVQ   32(CX), AX
+	IMUL3Q $0x13, AX, AX
+	MULQ   32(BX)
+	ADDQ   AX, R13
+	ADCQ   DX, R12
+
+	// r4 = a0×b4
+	MOVQ (CX), AX
+	MULQ 32(BX)
+	MOVQ AX, R15
+	MOVQ DX, R14
+
+	// r4 += a1×b3
+	MOVQ 8(CX), AX
+	MULQ 24(BX)
+	ADDQ AX, R15
+	ADCQ DX, R14
+
+	// r4 += a2×b2
+	MOVQ 16(CX), AX
+	MULQ 16(BX)
+	ADDQ AX, R15
+	ADCQ DX, R14
+
+	// r4 += a3×b1
+	MOVQ 24(CX), AX
+	MULQ 8(BX)
+	ADDQ AX, R15
+	ADCQ DX, R14
+
+	// r4 += a4×b0
+	MOVQ 32(CX), AX
+	MULQ (BX)
+	ADDQ AX, R15
+	ADCQ DX, R14
+
+	// First reduction chain
+	MOVQ   $0x0007ffffffffffff, AX
+	SHLQ   $0x0d, DI, SI
+	SHLQ   $0x0d, R9, R8
+	SHLQ   $0x0d, R11, R10
+	SHLQ   $0x0d, R13, R12
+	SHLQ   $0x0d, R15, R14
+	ANDQ   AX, DI
+	IMUL3Q $0x13, R14, R14
+	ADDQ   R14, DI
+	ANDQ   AX, R9
+	ADDQ   SI, R9
+	ANDQ   AX, R11
+	ADDQ   R8, R11
+	ANDQ   AX, R13
+	ADDQ   R10, R13
+	ANDQ   AX, R15
+	ADDQ   R12, R15
+
+	// Second reduction chain (carryPropagate)
+	MOVQ   DI, SI
+	SHRQ   $0x33, SI
+	MOVQ   R9, R8
+	SHRQ   $0x33, R8
+	MOVQ   R11, R10
+	SHRQ   $0x33, R10
+	MOVQ   R13, R12
+	SHRQ   $0x33, R12
+	MOVQ   R15, R14
+	SHRQ   $0x33, R14
+	ANDQ   AX, DI
+	IMUL3Q $0x13, R14, R14
+	ADDQ   R14, DI
+	ANDQ   AX, R9
+	ADDQ   SI, R9
+	ANDQ   AX, R11
+	ADDQ   R8, R11
+	ANDQ   AX, R13
+	ADDQ   R10, R13
+	ANDQ   AX, R15
+	ADDQ   R12, R15
+
+	// Store output
+	MOVQ out+0(FP), AX
+	MOVQ DI, (AX)
+	MOVQ R9, 8(AX)
+	MOVQ R11, 16(AX)
+	MOVQ R13, 24(AX)
+	MOVQ R15, 32(AX)
+	RET
+
+// func feSquare(out *Element, a *Element)
+TEXT ·feSquare(SB), NOSPLIT, $0-16
+	MOVQ a+8(FP), CX
+
+	// r0 = l0×l0
+	MOVQ (CX), AX
+	MULQ (CX)
+	MOVQ AX, SI
+	MOVQ DX, BX
+
+	// r0 += 38×l1×l4
+	MOVQ   8(CX), AX
+	IMUL3Q $0x26, AX, AX
+	MULQ   32(CX)
+	ADDQ   AX, SI
+	ADCQ   DX, BX
+
+	// r0 += 38×l2×l3
+	MOVQ   16(CX), AX
+	IMUL3Q $0x26, AX, AX
+	MULQ   24(CX)
+	ADDQ   AX, SI
+	ADCQ   DX, BX
+
+	// r1 = 2×l0×l1
+	MOVQ (CX), AX
+	SHLQ $0x01, AX
+	MULQ 8(CX)
+	MOVQ AX, R8
+	MOVQ DX, DI
+
+	// r1 += 38×l2×l4
+	MOVQ   16(CX), AX
+	IMUL3Q $0x26, AX, AX
+	MULQ   32(CX)
+	ADDQ   AX, R8
+	ADCQ   DX, DI
+
+	// r1 += 19×l3×l3
+	MOVQ   24(CX), AX
+	IMUL3Q $0x13, AX, AX
+	MULQ   24(CX)
+	ADDQ   AX, R8
+	ADCQ   DX, DI
+
+	// r2 = 2×l0×l2
+	MOVQ (CX), AX
+	SHLQ $0x01, AX
+	MULQ 16(CX)
+	MOVQ AX, R10
+	MOVQ DX, R9
+
+	// r2 += l1×l1
+	MOVQ 8(CX), AX
+	MULQ 8(CX)
+	ADDQ AX, R10
+	ADCQ DX, R9
+
+	// r2 += 38×l3×l4
+	MOVQ   24(CX), AX
+	IMUL3Q $0x26, AX, AX
+	MULQ   32(CX)
+	ADDQ   AX, R10
+	ADCQ   DX, R9
+
+	// r3 = 2×l0×l3
+	MOVQ (CX), AX
+	SHLQ $0x01, AX
+	MULQ 24(CX)
+	MOVQ AX, R12
+	MOVQ DX, R11
+
+	// r3 += 2×l1×l2
+	MOVQ   8(CX), AX
+	IMUL3Q $0x02, AX, AX
+	MULQ   16(CX)
+	ADDQ   AX, R12
+	ADCQ   DX, R11
+
+	// r3 += 19×l4×l4
+	MOVQ   32(CX), AX
+	IMUL3Q $0x13, AX, AX
+	MULQ   32(CX)
+	ADDQ   AX, R12
+	ADCQ   DX, R11
+
+	// r4 = 2×l0×l4
+	MOVQ (CX), AX
+	SHLQ $0x01, AX
+	MULQ 32(CX)
+	MOVQ AX, R14
+	MOVQ DX, R13
+
+	// r4 += 2×l1×l3
+	MOVQ   8(CX), AX
+	IMUL3Q $0x02, AX, AX
+	MULQ   24(CX)
+	ADDQ   AX, R14
+	ADCQ   DX, R13
+
+	// r4 += l2×l2
+	MOVQ 16(CX), AX
+	MULQ 16(CX)
+	ADDQ AX, R14
+	ADCQ DX, R13
+
+	// First reduction chain
+	MOVQ   $0x0007ffffffffffff, AX
+	SHLQ   $0x0d, SI, BX
+	SHLQ   $0x0d, R8, DI
+	SHLQ   $0x0d, R10, R9
+	SHLQ   $0x0d, R12, R11
+	SHLQ   $0x0d, R14, R13
+	ANDQ   AX, SI
+	IMUL3Q $0x13, R13, R13
+	ADDQ   R13, SI
+	ANDQ   AX, R8
+	ADDQ   BX, R8
+	ANDQ   AX, R10
+	ADDQ   DI, R10
+	ANDQ   AX, R12
+	ADDQ   R9, R12
+	ANDQ   AX, R14
+	ADDQ   R11, R14
+
+	// Second reduction chain (carryPropagate)
+	MOVQ   SI, BX
+	SHRQ   $0x33, BX
+	MOVQ   R8, DI
+	SHRQ   $0x33, DI
+	MOVQ   R10, R9
+	SHRQ   $0x33, R9
+	MOVQ   R12, R11
+	SHRQ   $0x33, R11
+	MOVQ   R14, R13
+	SHRQ   $0x33, R13
+	ANDQ   AX, SI
+	IMUL3Q $0x13, R13, R13
+	ADDQ   R13, SI
+	ANDQ   AX, R8
+	ADDQ   BX, R8
+	ANDQ   AX, R10
+	ADDQ   DI, R10
+	ANDQ   AX, R12
+	ADDQ   R9, R12
+	ANDQ   AX, R14
+	ADDQ   R11, R14
+
+	// Store output
+	MOVQ out+0(FP), AX
+	MOVQ SI, (AX)
+	MOVQ R8, 8(AX)
+	MOVQ R10, 16(AX)
+	MOVQ R12, 24(AX)
+	MOVQ R14, 32(AX)
+	RET
diff --git a/crypto/edwards25519/field/fe_amd64_noasm.go b/crypto/edwards25519/field/fe_amd64_noasm.go
new file mode 100644
index 000000000..9da280d1d
--- /dev/null
+++ b/crypto/edwards25519/field/fe_amd64_noasm.go
@@ -0,0 +1,11 @@
+// Copyright (c) 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !amd64 || !gc || purego
+
+package field
+
+func feMul(v, x, y *Element) { feMulGeneric(v, x, y) }
+
+func feSquare(v, x *Element) { feSquareGeneric(v, x) }
diff --git a/crypto/edwards25519/field/fe_arm64.go b/crypto/edwards25519/field/fe_arm64.go
new file mode 100644
index 000000000..075fe9b92
--- /dev/null
+++ b/crypto/edwards25519/field/fe_arm64.go
@@ -0,0 +1,15 @@
+// Copyright (c) 2020 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build arm64 && gc && !purego
+
+package field
+
+//go:noescape
+func carryPropagate(v *Element)
+
+func (v *Element) carryPropagate() *Element {
+	carryPropagate(v)
+	return v
+}
diff --git a/crypto/edwards25519/field/fe_arm64.s b/crypto/edwards25519/field/fe_arm64.s
new file mode 100644
index 000000000..751ab2ada
--- /dev/null
+++ b/crypto/edwards25519/field/fe_arm64.s
@@ -0,0 +1,42 @@
+// Copyright (c) 2020 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// +build arm64,gc,!purego
+
+#include "textflag.h"
+
+// carryPropagate works exactly like carryPropagateGeneric and uses the
+// same AND, ADD, and LSR+MADD instructions emitted by the compiler, but
+// avoids loading R0-R4 twice and uses LDP and STP.
+//
+// See https://golang.org/issues/43145 for the main compiler issue.
+//
+// func carryPropagate(v *Element)
+TEXT ·carryPropagate(SB),NOFRAME|NOSPLIT,$0-8
+	MOVD v+0(FP), R20
+
+	LDP 0(R20), (R0, R1)
+	LDP 16(R20), (R2, R3)
+	MOVD 32(R20), R4
+
+	AND $0x7ffffffffffff, R0, R10
+	AND $0x7ffffffffffff, R1, R11
+	AND $0x7ffffffffffff, R2, R12
+	AND $0x7ffffffffffff, R3, R13
+	AND $0x7ffffffffffff, R4, R14
+
+	ADD R0>>51, R11, R11
+	ADD R1>>51, R12, R12
+	ADD R2>>51, R13, R13
+	ADD R3>>51, R14, R14
+	// R4>>51 * 19 + R10 -> R10
+	LSR $51, R4, R21
+	MOVD $19, R22
+	MADD R22, R10, R21, R10
+
+	STP (R10, R11), 0(R20)
+	STP (R12, R13), 16(R20)
+	MOVD R14, 32(R20)
+
+	RET
diff --git a/crypto/edwards25519/field/fe_arm64_noasm.go b/crypto/edwards25519/field/fe_arm64_noasm.go
new file mode 100644
index 000000000..fc029ac12
--- /dev/null
+++ b/crypto/edwards25519/field/fe_arm64_noasm.go
@@ -0,0 +1,11 @@
+// Copyright (c) 2021 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+//go:build !arm64 || !gc || purego
+
+package field
+
+func (v *Element) carryPropagate() *Element {
+	return v.carryPropagateGeneric()
+}
diff --git a/crypto/edwards25519/field/fe_bench_test.go b/crypto/edwards25519/field/fe_bench_test.go
new file mode 100644
index 000000000..77dc06cf9
--- /dev/null
+++ b/crypto/edwards25519/field/fe_bench_test.go
@@ -0,0 +1,36 @@
+// Copyright (c) 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package field
+
+import "testing"
+
+func BenchmarkAdd(b *testing.B) {
+	var x, y Element
+	x.One()
+	y.Add(feOne, feOne)
+	b.ResetTimer()
+	for i := 0; i < b.N; i++ {
+		x.Add(&x, &y)
+	}
+}
+
+func BenchmarkMultiply(b *testing.B) {
+	var x, y Element
+	x.One()
+	y.Add(feOne, feOne)
+	b.ResetTimer()
+	for i := 0; i < b.N; i++ {
+		x.Multiply(&x, &y)
+	}
+}
+
+func BenchmarkMult32(b *testing.B) {
+	var x Element
+	x.One()
+	b.ResetTimer()
+	for i := 0; i < b.N; i++ {
+		x.Mult32(&x, 0xaa42aa42)
+	}
+}
diff --git a/crypto/edwards25519/field/fe_generic.go b/crypto/edwards25519/field/fe_generic.go
new file mode 100644
index 000000000..bccf8511a
--- /dev/null
+++ b/crypto/edwards25519/field/fe_generic.go
@@ -0,0 +1,264 @@
+// Copyright (c) 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package field
+
+import "math/bits"
+
+// uint128 holds a 128-bit number as two 64-bit limbs, for use with the
+// bits.Mul64 and bits.Add64 intrinsics.
+type uint128 struct {
+	lo, hi uint64
+}
+
+// mul64 returns a * b.
+func mul64(a, b uint64) uint128 {
+	hi, lo := bits.Mul64(a, b)
+	return uint128{lo, hi}
+}
+
+// addMul64 returns v + a * b.
+func addMul64(v uint128, a, b uint64) uint128 {
+	hi, lo := bits.Mul64(a, b)
+	lo, c := bits.Add64(lo, v.lo, 0)
+	hi, _ = bits.Add64(hi, v.hi, c)
+	return uint128{lo, hi}
+}
+
+// shiftRightBy51 returns a >> 51. a is assumed to be at most 115 bits.
+func shiftRightBy51(a uint128) uint64 {
+	return (a.hi << (64 - 51)) | (a.lo >> 51)
+}
+
+func feMulGeneric(v, a, b *Element) {
+	a0 := a.l0
+	a1 := a.l1
+	a2 := a.l2
+	a3 := a.l3
+	a4 := a.l4
+
+	b0 := b.l0
+	b1 := b.l1
+	b2 := b.l2
+	b3 := b.l3
+	b4 := b.l4
+
+	// Limb multiplication works like pen-and-paper columnar multiplication, but
+	// with 51-bit limbs instead of digits.
+	//
+	//                          a4   a3   a2   a1   a0  x
+	//                          b4   b3   b2   b1   b0  =
+	//                         ------------------------
+	//                        a4b0 a3b0 a2b0 a1b0 a0b0  +
+	//                   a4b1 a3b1 a2b1 a1b1 a0b1       +
+	//              a4b2 a3b2 a2b2 a1b2 a0b2            +
+	//         a4b3 a3b3 a2b3 a1b3 a0b3                 +
+	//    a4b4 a3b4 a2b4 a1b4 a0b4                      =
+	//   ----------------------------------------------
+	//      r8   r7   r6   r5   r4   r3   r2   r1   r0
+	//
+	// We can then use the reduction identity (a * 2²⁵⁵ + b = a * 19 + b) to
+	// reduce the limbs that would overflow 255 bits. r5 * 2²⁵⁵ becomes 19 * r5,
+	// r6 * 2³⁰⁶ becomes 19 * r6 * 2⁵¹, etc.
+	//
+	// Reduction can be carried out simultaneously to multiplication. For
+	// example, we do not compute r5: whenever the result of a multiplication
+	// belongs to r5, like a1b4, we multiply it by 19 and add the result to r0.
+	//
+	//            a4b0    a3b0    a2b0    a1b0    a0b0  +
+	//            a3b1    a2b1    a1b1    a0b1 19×a4b1  +
+	//            a2b2    a1b2    a0b2 19×a4b2 19×a3b2  +
+	//            a1b3    a0b3 19×a4b3 19×a3b3 19×a2b3  +
+	//            a0b4 19×a4b4 19×a3b4 19×a2b4 19×a1b4  =
+	//           --------------------------------------
+	//              r4      r3      r2      r1      r0
+	//
+	// Finally we add up the columns into wide, overlapping limbs.
+
+	a1_19 := a1 * 19
+	a2_19 := a2 * 19
+	a3_19 := a3 * 19
+	a4_19 := a4 * 19
+
+	// r0 = a0×b0 + 19×(a1×b4 + a2×b3 + a3×b2 + a4×b1)
+	r0 := mul64(a0, b0)
+	r0 = addMul64(r0, a1_19, b4)
+	r0 = addMul64(r0, a2_19, b3)
+	r0 = addMul64(r0, a3_19, b2)
+	r0 = addMul64(r0, a4_19, b1)
+
+	// r1 = a0×b1 + a1×b0 + 19×(a2×b4 + a3×b3 + a4×b2)
+	r1 := mul64(a0, b1)
+	r1 = addMul64(r1, a1, b0)
+	r1 = addMul64(r1, a2_19, b4)
+	r1 = addMul64(r1, a3_19, b3)
+	r1 = addMul64(r1, a4_19, b2)
+
+	// r2 = a0×b2 + a1×b1 + a2×b0 + 19×(a3×b4 + a4×b3)
+	r2 := mul64(a0, b2)
+	r2 = addMul64(r2, a1, b1)
+	r2 = addMul64(r2, a2, b0)
+	r2 = addMul64(r2, a3_19, b4)
+	r2 = addMul64(r2, a4_19, b3)
+
+	// r3 = a0×b3 + a1×b2 + a2×b1 + a3×b0 + 19×a4×b4
+	r3 := mul64(a0, b3)
+	r3 = addMul64(r3, a1, b2)
+	r3 = addMul64(r3, a2, b1)
+	r3 = addMul64(r3, a3, b0)
+	r3 = addMul64(r3, a4_19, b4)
+
+	// r4 = a0×b4 + a1×b3 + a2×b2 + a3×b1 + a4×b0
+	r4 := mul64(a0, b4)
+	r4 = addMul64(r4, a1, b3)
+	r4 = addMul64(r4, a2, b2)
+	r4 = addMul64(r4, a3, b1)
+	r4 = addMul64(r4, a4, b0)
+
+	// After the multiplication, we need to reduce (carry) the five coefficients
+	// to obtain a result with limbs that are at most slightly larger than 2⁵¹,
+	// to respect the Element invariant.
+	//
+	// Overall, the reduction works the same as carryPropagate, except with
+	// wider inputs: we take the carry for each coefficient by shifting it right
+	// by 51, and add it to the limb above it. The top carry is multiplied by 19
+	// according to the reduction identity and added to the lowest limb.
+	//
+	// The largest coefficient (r0) will be at most 111 bits, which guarantees
+	// that all carries are at most 111 - 51 = 60 bits, which fits in a uint64.
+	//
+	//     r0 = a0×b0 + 19×(a1×b4 + a2×b3 + a3×b2 + a4×b1)
+	//     r0 < 2⁵²×2⁵² + 19×(2⁵²×2⁵² + 2⁵²×2⁵² + 2⁵²×2⁵² + 2⁵²×2⁵²)
+	//     r0 < (1 + 19 × 4) × 2⁵² × 2⁵²
+	//     r0 < 2⁷ × 2⁵² × 2⁵²
+	//     r0 < 2¹¹¹
+	//
+	// Moreover, the top coefficient (r4) is at most 107 bits, so c4 is at most
+	// 56 bits, and c4 * 19 is at most 61 bits, which again fits in a uint64 and
+	// allows us to easily apply the reduction identity.
+	//
+	//     r4 = a0×b4 + a1×b3 + a2×b2 + a3×b1 + a4×b0
+	//     r4 < 5 × 2⁵² × 2⁵²
+	//     r4 < 2¹⁰⁷
+	//
+
+	c0 := shiftRightBy51(r0)
+	c1 := shiftRightBy51(r1)
+	c2 := shiftRightBy51(r2)
+	c3 := shiftRightBy51(r3)
+	c4 := shiftRightBy51(r4)
+
+	rr0 := r0.lo&maskLow51Bits + c4*19
+	rr1 := r1.lo&maskLow51Bits + c0
+	rr2 := r2.lo&maskLow51Bits + c1
+	rr3 := r3.lo&maskLow51Bits + c2
+	rr4 := r4.lo&maskLow51Bits + c3
+
+	// Now all coefficients fit into 64-bit registers but are still too large to
+	// be passed around as a Element. We therefore do one last carry chain,
+	// where the carries will be small enough to fit in the wiggle room above 2⁵¹.
+	*v = Element{rr0, rr1, rr2, rr3, rr4}
+	v.carryPropagate()
+}
+
+func feSquareGeneric(v, a *Element) {
+	l0 := a.l0
+	l1 := a.l1
+	l2 := a.l2
+	l3 := a.l3
+	l4 := a.l4
+
+	// Squaring works precisely like multiplication above, but thanks to its
+	// symmetry we get to group a few terms together.
+	//
+	//                          l4   l3   l2   l1   l0  x
+	//                          l4   l3   l2   l1   l0  =
+	//                         ------------------------
+	//                        l4l0 l3l0 l2l0 l1l0 l0l0  +
+	//                   l4l1 l3l1 l2l1 l1l1 l0l1       +
+	//              l4l2 l3l2 l2l2 l1l2 l0l2            +
+	//         l4l3 l3l3 l2l3 l1l3 l0l3                 +
+	//    l4l4 l3l4 l2l4 l1l4 l0l4                      =
+	//   ----------------------------------------------
+	//      r8   r7   r6   r5   r4   r3   r2   r1   r0
+	//
+	//            l4l0    l3l0    l2l0    l1l0    l0l0  +
+	//            l3l1    l2l1    l1l1    l0l1 19×l4l1  +
+	//            l2l2    l1l2    l0l2 19×l4l2 19×l3l2  +
+	//            l1l3    l0l3 19×l4l3 19×l3l3 19×l2l3  +
+	//            l0l4 19×l4l4 19×l3l4 19×l2l4 19×l1l4  =
+	//           --------------------------------------
+	//              r4      r3      r2      r1      r0
+	//
+	// With precomputed 2×, 19×, and 2×19× terms, we can compute each limb with
+	// only three Mul64 and four Add64, instead of five and eight.
+
+	l0_2 := l0 * 2
+	l1_2 := l1 * 2
+
+	l1_38 := l1 * 38
+	l2_38 := l2 * 38
+	l3_38 := l3 * 38
+
+	l3_19 := l3 * 19
+	l4_19 := l4 * 19
+
+	// r0 = l0×l0 + 19×(l1×l4 + l2×l3 + l3×l2 + l4×l1) = l0×l0 + 19×2×(l1×l4 + l2×l3)
+	r0 := mul64(l0, l0)
+	r0 = addMul64(r0, l1_38, l4)
+	r0 = addMul64(r0, l2_38, l3)
+
+	// r1 = l0×l1 + l1×l0 + 19×(l2×l4 + l3×l3 + l4×l2) = 2×l0×l1 + 19×2×l2×l4 + 19×l3×l3
+	r1 := mul64(l0_2, l1)
+	r1 = addMul64(r1, l2_38, l4)
+	r1 = addMul64(r1, l3_19, l3)
+
+	// r2 = l0×l2 + l1×l1 + l2×l0 + 19×(l3×l4 + l4×l3) = 2×l0×l2 + l1×l1 + 19×2×l3×l4
+	r2 := mul64(l0_2, l2)
+	r2 = addMul64(r2, l1, l1)
+	r2 = addMul64(r2, l3_38, l4)
+
+	// r3 = l0×l3 + l1×l2 + l2×l1 + l3×l0 + 19×l4×l4 = 2×l0×l3 + 2×l1×l2 + 19×l4×l4
+	r3 := mul64(l0_2, l3)
+	r3 = addMul64(r3, l1_2, l2)
+	r3 = addMul64(r3, l4_19, l4)
+
+	// r4 = l0×l4 + l1×l3 + l2×l2 + l3×l1 + l4×l0 = 2×l0×l4 + 2×l1×l3 + l2×l2
+	r4 := mul64(l0_2, l4)
+	r4 = addMul64(r4, l1_2, l3)
+	r4 = addMul64(r4, l2, l2)
+
+	c0 := shiftRightBy51(r0)
+	c1 := shiftRightBy51(r1)
+	c2 := shiftRightBy51(r2)
+	c3 := shiftRightBy51(r3)
+	c4 := shiftRightBy51(r4)
+
+	rr0 := r0.lo&maskLow51Bits + c4*19
+	rr1 := r1.lo&maskLow51Bits + c0
+	rr2 := r2.lo&maskLow51Bits + c1
+	rr3 := r3.lo&maskLow51Bits + c2
+	rr4 := r4.lo&maskLow51Bits + c3
+
+	*v = Element{rr0, rr1, rr2, rr3, rr4}
+	v.carryPropagate()
+}
+
+// carryPropagate brings the limbs below 52 bits by applying the reduction
+// identity (a * 2²⁵⁵ + b = a * 19 + b) to the l4 carry.
+func (v *Element) carryPropagateGeneric() *Element {
+	c0 := v.l0 >> 51
+	c1 := v.l1 >> 51
+	c2 := v.l2 >> 51
+	c3 := v.l3 >> 51
+	c4 := v.l4 >> 51
+
+	v.l0 = v.l0&maskLow51Bits + c4*19
+	v.l1 = v.l1&maskLow51Bits + c0
+	v.l2 = v.l2&maskLow51Bits + c1
+	v.l3 = v.l3&maskLow51Bits + c2
+	v.l4 = v.l4&maskLow51Bits + c3
+
+	return v
+}
diff --git a/crypto/edwards25519/field/fe_test.go b/crypto/edwards25519/field/fe_test.go
new file mode 100644
index 000000000..b484459ff
--- /dev/null
+++ b/crypto/edwards25519/field/fe_test.go
@@ -0,0 +1,558 @@
+// Copyright (c) 2017 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package field
+
+import (
+	"bytes"
+	"crypto/rand"
+	"encoding/hex"
+	"io"
+	"math/big"
+	"math/bits"
+	mathrand "math/rand"
+	"reflect"
+	"testing"
+	"testing/quick"
+)
+
+func (v Element) String() string {
+	return hex.EncodeToString(v.Bytes())
+}
+
+// quickCheckConfig1024 will make each quickcheck test run (1024 * -quickchecks)
+// times. The default value of -quickchecks is 100.
+var quickCheckConfig1024 = &quick.Config{MaxCountScale: 1 << 10}
+
+func generateFieldElement(rand *mathrand.Rand) Element {
+	const maskLow52Bits = (1 << 52) - 1
+	return Element{
+		rand.Uint64() & maskLow52Bits,
+		rand.Uint64() & maskLow52Bits,
+		rand.Uint64() & maskLow52Bits,
+		rand.Uint64() & maskLow52Bits,
+		rand.Uint64() & maskLow52Bits,
+	}
+}
+
+// weirdLimbs can be combined to generate a range of edge-case field elements.
+// 0 and -1 are intentionally more weighted, as they combine well.
+var (
+	weirdLimbs51 = []uint64{
+		0, 0, 0, 0,
+		1,
+		19 - 1,
+		19,
+		0x2aaaaaaaaaaaa,
+		0x5555555555555,
+		(1 << 51) - 20,
+		(1 << 51) - 19,
+		(1 << 51) - 1, (1 << 51) - 1,
+		(1 << 51) - 1, (1 << 51) - 1,
+	}
+	weirdLimbs52 = []uint64{
+		0, 0, 0, 0, 0, 0,
+		1,
+		19 - 1,
+		19,
+		0x2aaaaaaaaaaaa,
+		0x5555555555555,
+		(1 << 51) - 20,
+		(1 << 51) - 19,
+		(1 << 51) - 1, (1 << 51) - 1,
+		(1 << 51) - 1, (1 << 51) - 1,
+		(1 << 51) - 1, (1 << 51) - 1,
+		1 << 51,
+		(1 << 51) + 1,
+		(1 << 52) - 19,
+		(1 << 52) - 1,
+	}
+)
+
+func generateWeirdFieldElement(rand *mathrand.Rand) Element {
+	return Element{
+		weirdLimbs52[rand.Intn(len(weirdLimbs52))],
+		weirdLimbs51[rand.Intn(len(weirdLimbs51))],
+		weirdLimbs51[rand.Intn(len(weirdLimbs51))],
+		weirdLimbs51[rand.Intn(len(weirdLimbs51))],
+		weirdLimbs51[rand.Intn(len(weirdLimbs51))],
+	}
+}
+
+func (Element) Generate(rand *mathrand.Rand, size int) reflect.Value {
+	if rand.Intn(2) == 0 {
+		return reflect.ValueOf(generateWeirdFieldElement(rand))
+	}
+	return reflect.ValueOf(generateFieldElement(rand))
+}
+
+// isInBounds returns whether the element is within the expected bit size bounds
+// after a light reduction.
+func isInBounds(x *Element) bool {
+	return bits.Len64(x.l0) <= 52 &&
+		bits.Len64(x.l1) <= 52 &&
+		bits.Len64(x.l2) <= 52 &&
+		bits.Len64(x.l3) <= 52 &&
+		bits.Len64(x.l4) <= 52
+}
+
+func TestMultiplyDistributesOverAdd(t *testing.T) {
+	multiplyDistributesOverAdd := func(x, y, z Element) bool {
+		// Compute t1 = (x+y)*z
+		t1 := new(Element)
+		t1.Add(&x, &y)
+		t1.Multiply(t1, &z)
+
+		// Compute t2 = x*z + y*z
+		t2 := new(Element)
+		t3 := new(Element)
+		t2.Multiply(&x, &z)
+		t3.Multiply(&y, &z)
+		t2.Add(t2, t3)
+
+		return t1.Equal(t2) == 1 && isInBounds(t1) && isInBounds(t2)
+	}
+
+	if err := quick.Check(multiplyDistributesOverAdd, quickCheckConfig1024); err != nil {
+		t.Error(err)
+	}
+}
+
+func TestMul64to128(t *testing.T) {
+	a := uint64(5)
+	b := uint64(5)
+	r := mul64(a, b)
+	if r.lo != 0x19 || r.hi != 0 {
+		t.Errorf("lo-range wide mult failed, got %d + %d*(2**64)", r.lo, r.hi)
+	}
+
+	a = uint64(18014398509481983) // 2^54 - 1
+	b = uint64(18014398509481983) // 2^54 - 1
+	r = mul64(a, b)
+	if r.lo != 0xff80000000000001 || r.hi != 0xfffffffffff {
+		t.Errorf("hi-range wide mult failed, got %d + %d*(2**64)", r.lo, r.hi)
+	}
+
+	a = uint64(1125899906842661)
+	b = uint64(2097155)
+	r = mul64(a, b)
+	r = addMul64(r, a, b)
+	r = addMul64(r, a, b)
+	r = addMul64(r, a, b)
+	r = addMul64(r, a, b)
+	if r.lo != 16888498990613035 || r.hi != 640 {
+		t.Errorf("wrong answer: %d + %d*(2**64)", r.lo, r.hi)
+	}
+}
+
+func TestSetBytesRoundTrip(t *testing.T) {
+	f1 := func(in [32]byte, fe Element) bool {
+		fe.SetBytes(in[:])
+
+		// Mask the most significant bit as it's ignored by SetBytes. (Now
+		// instead of earlier so we check the masking in SetBytes is working.)
+		in[len(in)-1] &= (1 << 7) - 1
+
+		return bytes.Equal(in[:], fe.Bytes()) && isInBounds(&fe)
+	}
+	if err := quick.Check(f1, nil); err != nil {
+		t.Errorf("failed bytes->FE->bytes round-trip: %v", err)
+	}
+
+	f2 := func(fe, r Element) bool {
+		r.SetBytes(fe.Bytes())
+
+		// Intentionally not using Equal not to go through Bytes again.
+		// Calling reduce because both Generate and SetBytes can produce
+		// non-canonical representations.
+		fe.reduce()
+		r.reduce()
+		return fe == r
+	}
+	if err := quick.Check(f2, nil); err != nil {
+		t.Errorf("failed FE->bytes->FE round-trip: %v", err)
+	}
+
+	// Check some fixed vectors from dalek
+	type feRTTest struct {
+		fe Element
+		b  []byte
+	}
+	var tests = []feRTTest{
+		{
+			fe: Element{358744748052810, 1691584618240980, 977650209285361, 1429865912637724, 560044844278676},
+			b:  []byte{74, 209, 69, 197, 70, 70, 161, 222, 56, 226, 229, 19, 112, 60, 25, 92, 187, 74, 222, 56, 50, 153, 51, 233, 40, 74, 57, 6, 160, 185, 213, 31},
+		},
+		{
+			fe: Element{84926274344903, 473620666599931, 365590438845504, 1028470286882429, 2146499180330972},
+			b:  []byte{199, 23, 106, 112, 61, 77, 216, 79, 186, 60, 11, 118, 13, 16, 103, 15, 42, 32, 83, 250, 44, 57, 204, 198, 78, 199, 253, 119, 146, 172, 3, 122},
+		},
+	}
+
+	for _, tt := range tests {
+		b := tt.fe.Bytes()
+		if !bytes.Equal(b, tt.b) || new(Element).SetBytes(tt.b).Equal(&tt.fe) != 1 {
+			t.Errorf("Failed fixed roundtrip: %v", tt)
+		}
+	}
+}
+
+func swapEndianness(buf []byte) []byte {
+	for i := 0; i < len(buf)/2; i++ {
+		buf[i], buf[len(buf)-i-1] = buf[len(buf)-i-1], buf[i]
+	}
+	return buf
+}
+
+func TestBytesBigEquivalence(t *testing.T) {
+	f1 := func(in [32]byte, fe, fe1 Element) bool {
+		fe.SetBytes(in[:])
+
+		in[len(in)-1] &= (1 << 7) - 1 // mask the most significant bit
+		b := new(big.Int).SetBytes(swapEndianness(in[:]))
+		fe1.fromBig(b)
+
+		if fe != fe1 {
+			return false
+		}
+
+		buf := make([]byte, 32) // pad with zeroes
+		copy(buf, swapEndianness(fe1.toBig().Bytes()))
+
+		return bytes.Equal(fe.Bytes(), buf) && isInBounds(&fe) && isInBounds(&fe1)
+	}
+	if err := quick.Check(f1, nil); err != nil {
+		t.Error(err)
+	}
+}
+
+// fromBig sets v = n, and returns v. The bit length of n must not exceed 256.
+func (v *Element) fromBig(n *big.Int) *Element {
+	if n.BitLen() > 32*8 {
+		panic("edwards25519: invalid field element input size")
+	}
+
+	buf := make([]byte, 0, 32)
+	for _, word := range n.Bits() {
+		for i := 0; i < bits.UintSize; i += 8 {
+			if len(buf) >= cap(buf) {
+				break
+			}
+			buf = append(buf, byte(word))
+			word >>= 8
+		}
+	}
+
+	return v.SetBytes(buf[:32])
+}
+
+func (v *Element) fromDecimal(s string) *Element {
+	n, ok := new(big.Int).SetString(s, 10)
+	if !ok {
+		panic("not a valid decimal: " + s)
+	}
+	return v.fromBig(n)
+}
+
+// toBig returns v as a big.Int.
+func (v *Element) toBig() *big.Int {
+	buf := v.Bytes()
+
+	words := make([]big.Word, 32*8/bits.UintSize)
+	for n := range words {
+		for i := 0; i < bits.UintSize; i += 8 {
+			if len(buf) == 0 {
+				break
+			}
+			words[n] |= big.Word(buf[0]) << big.Word(i)
+			buf = buf[1:]
+		}
+	}
+
+	return new(big.Int).SetBits(words)
+}
+
+func TestDecimalConstants(t *testing.T) {
+	sqrtM1String := "19681161376707505956807079304988542015446066515923890162744021073123829784752"
+	if exp := new(Element).fromDecimal(sqrtM1String); sqrtM1.Equal(exp) != 1 {
+		t.Errorf("sqrtM1 is %v, expected %v", sqrtM1, exp)
+	}
+	// d is in the parent package, and we don't want to expose d or fromDecimal.
+	// dString := "37095705934669439343138083508754565189542113879843219016388785533085940283555"
+	// if exp := new(Element).fromDecimal(dString); d.Equal(exp) != 1 {
+	// 	t.Errorf("d is %v, expected %v", d, exp)
+	// }
+}
+
+func TestSetBytesRoundTripEdgeCases(t *testing.T) {
+	// TODO: values close to 0, close to 2^255-19, between 2^255-19 and 2^255-1,
+	// and between 2^255 and 2^256-1. Test both the documented SetBytes
+	// behavior, and that Bytes reduces them.
+}
+
+// Tests self-consistency between Multiply and Square.
+func TestConsistency(t *testing.T) {
+	var x Element
+	var x2, x2sq Element
+
+	x = Element{1, 1, 1, 1, 1}
+	x2.Multiply(&x, &x)
+	x2sq.Square(&x)
+
+	if x2 != x2sq {
+		t.Fatalf("all ones failed\nmul: %x\nsqr: %x\n", x2, x2sq)
+	}
+
+	var bytes [32]byte
+
+	_, err := io.ReadFull(rand.Reader, bytes[:])
+	if err != nil {
+		t.Fatal(err)
+	}
+	x.SetBytes(bytes[:])
+
+	x2.Multiply(&x, &x)
+	x2sq.Square(&x)
+
+	if x2 != x2sq {
+		t.Fatalf("all ones failed\nmul: %x\nsqr: %x\n", x2, x2sq)
+	}
+}
+
+func TestEqual(t *testing.T) {
+	x := Element{1, 1, 1, 1, 1}
+	y := Element{5, 4, 3, 2, 1}
+
+	eq := x.Equal(&x)
+	if eq != 1 {
+		t.Errorf("wrong about equality")
+	}
+
+	eq = x.Equal(&y)
+	if eq != 0 {
+		t.Errorf("wrong about inequality")
+	}
+}
+
+func TestInvert(t *testing.T) {
+	x := Element{1, 1, 1, 1, 1}
+	one := Element{1, 0, 0, 0, 0}
+	var xinv, r Element
+
+	xinv.Invert(&x)
+	r.Multiply(&x, &xinv)
+	r.reduce()
+
+	if one != r {
+		t.Errorf("inversion identity failed, got: %x", r)
+	}
+
+	var bytes [32]byte
+
+	_, err := io.ReadFull(rand.Reader, bytes[:])
+	if err != nil {
+		t.Fatal(err)
+	}
+	x.SetBytes(bytes[:])
+
+	xinv.Invert(&x)
+	r.Multiply(&x, &xinv)
+	r.reduce()
+
+	if one != r {
+		t.Errorf("random inversion identity failed, got: %x for field element %x", r, x)
+	}
+
+	zero := Element{}
+	x.Set(&zero)
+	if xx := xinv.Invert(&x); xx != &xinv {
+		t.Errorf("inverting zero did not return the receiver")
+	} else if xinv.Equal(&zero) != 1 {
+		t.Errorf("inverting zero did not return zero")
+	}
+}
+
+func TestSelectSwap(t *testing.T) {
+	a := Element{358744748052810, 1691584618240980, 977650209285361, 1429865912637724, 560044844278676}
+	b := Element{84926274344903, 473620666599931, 365590438845504, 1028470286882429, 2146499180330972}
+
+	var c, d Element
+
+	c.Select(&a, &b, 1)
+	d.Select(&a, &b, 0)
+
+	if c.Equal(&a) != 1 || d.Equal(&b) != 1 {
+		t.Errorf("Select failed")
+	}
+
+	c.Swap(&d, 0)
+
+	if c.Equal(&a) != 1 || d.Equal(&b) != 1 {
+		t.Errorf("Swap failed")
+	}
+
+	c.Swap(&d, 1)
+
+	if c.Equal(&b) != 1 || d.Equal(&a) != 1 {
+		t.Errorf("Swap failed")
+	}
+}
+
+func TestMult32(t *testing.T) {
+	mult32EquivalentToMul := func(x Element, y uint32) bool {
+		t1 := new(Element)
+		for i := 0; i < 100; i++ {
+			t1.Mult32(&x, y)
+		}
+
+		ty := new(Element)
+		ty.l0 = uint64(y)
+
+		t2 := new(Element)
+		for i := 0; i < 100; i++ {
+			t2.Multiply(&x, ty)
+		}
+
+		return t1.Equal(t2) == 1 && isInBounds(t1) && isInBounds(t2)
+	}
+
+	if err := quick.Check(mult32EquivalentToMul, quickCheckConfig1024); err != nil {
+		t.Error(err)
+	}
+}
+
+func TestSqrtRatio(t *testing.T) {
+	// From draft-irtf-cfrg-ristretto255-decaf448-00, Appendix A.4.
+	type test struct {
+		u, v      string
+		wasSquare int
+		r         string
+	}
+	var tests = []test{
+		// If u is 0, the function is defined to return (0, TRUE), even if v
+		// is zero. Note that where used in this package, the denominator v
+		// is never zero.
+		{
+			"0000000000000000000000000000000000000000000000000000000000000000",
+			"0000000000000000000000000000000000000000000000000000000000000000",
+			1, "0000000000000000000000000000000000000000000000000000000000000000",
+		},
+		// 0/1 == 0²
+		{
+			"0000000000000000000000000000000000000000000000000000000000000000",
+			"0100000000000000000000000000000000000000000000000000000000000000",
+			1, "0000000000000000000000000000000000000000000000000000000000000000",
+		},
+		// If u is non-zero and v is zero, defined to return (0, FALSE).
+		{
+			"0100000000000000000000000000000000000000000000000000000000000000",
+			"0000000000000000000000000000000000000000000000000000000000000000",
+			0, "0000000000000000000000000000000000000000000000000000000000000000",
+		},
+		// 2/1 is not square in this field.
+		{
+			"0200000000000000000000000000000000000000000000000000000000000000",
+			"0100000000000000000000000000000000000000000000000000000000000000",
+			0, "3c5ff1b5d8e4113b871bd052f9e7bcd0582804c266ffb2d4f4203eb07fdb7c54",
+		},
+		// 4/1 == 2²
+		{
+			"0400000000000000000000000000000000000000000000000000000000000000",
+			"0100000000000000000000000000000000000000000000000000000000000000",
+			1, "0200000000000000000000000000000000000000000000000000000000000000",
+		},
+		// 1/4 == (2⁻¹)² == (2^(p-2))² per Euler's theorem
+		{
+			"0100000000000000000000000000000000000000000000000000000000000000",
+			"0400000000000000000000000000000000000000000000000000000000000000",
+			1, "f6ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff3f",
+		},
+	}
+
+	for i, tt := range tests {
+		u := new(Element).SetBytes(decodeHex(tt.u))
+		v := new(Element).SetBytes(decodeHex(tt.v))
+		want := new(Element).SetBytes(decodeHex(tt.r))
+		got, wasSquare := new(Element).SqrtRatio(u, v)
+		if got.Equal(want) == 0 || wasSquare != tt.wasSquare {
+			t.Errorf("%d: got (%v, %v), want (%v, %v)", i, got, wasSquare, want, tt.wasSquare)
+		}
+	}
+}
+
+func TestCarryPropagate(t *testing.T) {
+	asmLikeGeneric := func(a [5]uint64) bool {
+		t1 := &Element{a[0], a[1], a[2], a[3], a[4]}
+		t2 := &Element{a[0], a[1], a[2], a[3], a[4]}
+
+		t1.carryPropagate()
+		t2.carryPropagateGeneric()
+
+		if *t1 != *t2 {
+			t.Logf("got: %#v,\nexpected: %#v", t1, t2)
+		}
+
+		return *t1 == *t2 && isInBounds(t2)
+	}
+
+	if err := quick.Check(asmLikeGeneric, quickCheckConfig1024); err != nil {
+		t.Error(err)
+	}
+
+	if !asmLikeGeneric([5]uint64{0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff}) {
+		t.Errorf("failed for {0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff}")
+	}
+}
+
+func TestFeSquare(t *testing.T) {
+	asmLikeGeneric := func(a Element) bool {
+		t1 := a
+		t2 := a
+
+		feSquareGeneric(&t1, &t1)
+		feSquare(&t2, &t2)
+
+		if t1 != t2 {
+			t.Logf("got: %#v,\nexpected: %#v", t1, t2)
+		}
+
+		return t1 == t2 && isInBounds(&t2)
+	}
+
+	if err := quick.Check(asmLikeGeneric, quickCheckConfig1024); err != nil {
+		t.Error(err)
+	}
+}
+
+func TestFeMul(t *testing.T) {
+	asmLikeGeneric := func(a, b Element) bool {
+		a1 := a
+		a2 := a
+		b1 := b
+		b2 := b
+
+		feMulGeneric(&a1, &a1, &b1)
+		feMul(&a2, &a2, &b2)
+
+		if a1 != a2 || b1 != b2 {
+			t.Logf("got: %#v,\nexpected: %#v", a1, a2)
+			t.Logf("got: %#v,\nexpected: %#v", b1, b2)
+		}
+
+		return a1 == a2 && isInBounds(&a2) &&
+			b1 == b2 && isInBounds(&b2)
+	}
+
+	if err := quick.Check(asmLikeGeneric, quickCheckConfig1024); err != nil {
+		t.Error(err)
+	}
+}
+
+func decodeHex(s string) []byte {
+	b, err := hex.DecodeString(s)
+	if err != nil {
+		panic(err)
+	}
+	return b
+}
diff --git a/crypto/edwards25519/scalar.go b/crypto/edwards25519/scalar.go
new file mode 100644
index 000000000..889acaa0f
--- /dev/null
+++ b/crypto/edwards25519/scalar.go
@@ -0,0 +1,1025 @@
+// Copyright (c) 2016 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package edwards25519
+
+import (
+	"crypto/subtle"
+	"encoding/binary"
+	"errors"
+)
+
+// A Scalar is an integer modulo
+//
+//     l = 2^252 + 27742317777372353535851937790883648493
+//
+// which is the prime order of the edwards25519 group.
+//
+// This type works similarly to math/big.Int, and all arguments and
+// receivers are allowed to alias.
+//
+// The zero value is a valid zero element.
+type Scalar struct {
+	// s is the Scalar value in little-endian. The value is always reduced
+	// between operations.
+	s [32]byte
+}
+
+var (
+	scZero = Scalar{[32]byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}
+
+	scOne = Scalar{[32]byte{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}
+
+	scMinusOne = Scalar{[32]byte{236, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16}}
+)
+
+// NewScalar returns a new zero Scalar.
+func NewScalar() *Scalar {
+	return &Scalar{}
+}
+
+// MultiplyAdd sets s = x * y + z mod l, and returns s.
+func (s *Scalar) MultiplyAdd(x, y, z *Scalar) *Scalar {
+	scMulAdd(&s.s, &x.s, &y.s, &z.s)
+	return s
+}
+
+// Add sets s = x + y mod l, and returns s.
+func (s *Scalar) Add(x, y *Scalar) *Scalar {
+	// s = 1 * x + y mod l
+	scMulAdd(&s.s, &scOne.s, &x.s, &y.s)
+	return s
+}
+
+// Subtract sets s = x - y mod l, and returns s.
+func (s *Scalar) Subtract(x, y *Scalar) *Scalar {
+	// s = -1 * y + x mod l
+	scMulAdd(&s.s, &scMinusOne.s, &y.s, &x.s)
+	return s
+}
+
+// Negate sets s = -x mod l, and returns s.
+func (s *Scalar) Negate(x *Scalar) *Scalar {
+	// s = -1 * x + 0 mod l
+	scMulAdd(&s.s, &scMinusOne.s, &x.s, &scZero.s)
+	return s
+}
+
+// Multiply sets s = x * y mod l, and returns s.
+func (s *Scalar) Multiply(x, y *Scalar) *Scalar {
+	// s = x * y + 0 mod l
+	scMulAdd(&s.s, &x.s, &y.s, &scZero.s)
+	return s
+}
+
+// Set sets s = x, and returns s.
+func (s *Scalar) Set(x *Scalar) *Scalar {
+	*s = *x
+	return s
+}
+
+// SetUniformBytes sets s to an uniformly distributed value given 64 uniformly
+// distributed random bytes.
+func (s *Scalar) SetUniformBytes(x []byte) *Scalar {
+	if len(x) != 64 {
+		panic("edwards25519: invalid SetUniformBytes input length")
+	}
+	var wideBytes [64]byte
+	copy(wideBytes[:], x[:])
+	scReduce(&s.s, &wideBytes)
+	return s
+}
+
+// SetCanonicalBytes sets s = x, where x is a 32-byte little-endian encoding of
+// s, and returns s. If x is not a canonical encoding of s, SetCanonicalBytes
+// returns nil and an error, and the receiver is unchanged.
+func (s *Scalar) SetCanonicalBytes(x []byte) (*Scalar, error) {
+	if len(x) != 32 {
+		return nil, errors.New("invalid scalar length")
+	}
+	ss := &Scalar{}
+	copy(ss.s[:], x)
+	if !isReduced(ss) {
+		return nil, errors.New("invalid scalar encoding")
+	}
+	s.s = ss.s
+	return s, nil
+}
+
+// isReduced returns whether the given scalar is reduced modulo l.
+func isReduced(s *Scalar) bool {
+	for i := len(s.s) - 1; i >= 0; i-- {
+		switch {
+		case s.s[i] > scMinusOne.s[i]:
+			return false
+		case s.s[i] < scMinusOne.s[i]:
+			return true
+		}
+	}
+	return true
+}
+
+// SetBytesWithClamping applies the buffer pruning described in RFC 8032,
+// Section 5.1.5 (also known as clamping) and sets s to the result. The input
+// must be 32 bytes, and it is not modified.
+//
+// Note that since Scalar values are always reduced modulo the prime order of
+// the curve, the resulting value will not preserve any of the cofactor-clearing
+// properties that clamping is meant to provide. It will however work as
+// expected as long as it is applied to points on the prime order subgroup, like
+// in Ed25519. In fact, it is lost to history why RFC 8032 adopted the
+// irrelevant RFC 7748 clamping, but it is now required for compatibility.
+func (s *Scalar) SetBytesWithClamping(x []byte) *Scalar {
+	// The description above omits the purpose of the high bits of the clamping
+	// for brevity, but those are also lost to reductions, and are also
+	// irrelevant to edwards25519 as they protect against a specific
+	// implementation bug that was once observed in a generic Montgomery ladder.
+	if len(x) != 32 {
+		panic("edwards25519: invalid SetBytesWithClamping input length")
+	}
+	var wideBytes [64]byte
+	copy(wideBytes[:], x[:])
+	wideBytes[0] &= 248
+	wideBytes[31] &= 63
+	wideBytes[31] |= 64
+	scReduce(&s.s, &wideBytes)
+	return s
+}
+
+// Bytes returns the canonical 32-byte little-endian encoding of s.
+func (s *Scalar) Bytes() []byte {
+	buf := make([]byte, 32)
+	copy(buf, s.s[:])
+	return buf
+}
+
+// Equal returns 1 if s and t are equal, and 0 otherwise.
+func (s *Scalar) Equal(t *Scalar) int {
+	return subtle.ConstantTimeCompare(s.s[:], t.s[:])
+}
+
+// scMulAdd and scReduce are ported from the public domain, “ref10”
+// implementation of ed25519 from SUPERCOP.
+
+func load3(in []byte) int64 {
+	r := int64(in[0])
+	r |= int64(in[1]) << 8
+	r |= int64(in[2]) << 16
+	return r
+}
+
+func load4(in []byte) int64 {
+	r := int64(in[0])
+	r |= int64(in[1]) << 8
+	r |= int64(in[2]) << 16
+	r |= int64(in[3]) << 24
+	return r
+}
+
+// Input:
+//   a[0]+256*a[1]+...+256^31*a[31] = a
+//   b[0]+256*b[1]+...+256^31*b[31] = b
+//   c[0]+256*c[1]+...+256^31*c[31] = c
+//
+// Output:
+//   s[0]+256*s[1]+...+256^31*s[31] = (ab+c) mod l
+//   where l = 2^252 + 27742317777372353535851937790883648493.
+func scMulAdd(s, a, b, c *[32]byte) {
+	a0 := 2097151 & load3(a[:])
+	a1 := 2097151 & (load4(a[2:]) >> 5)
+	a2 := 2097151 & (load3(a[5:]) >> 2)
+	a3 := 2097151 & (load4(a[7:]) >> 7)
+	a4 := 2097151 & (load4(a[10:]) >> 4)
+	a5 := 2097151 & (load3(a[13:]) >> 1)
+	a6 := 2097151 & (load4(a[15:]) >> 6)
+	a7 := 2097151 & (load3(a[18:]) >> 3)
+	a8 := 2097151 & load3(a[21:])
+	a9 := 2097151 & (load4(a[23:]) >> 5)
+	a10 := 2097151 & (load3(a[26:]) >> 2)
+	a11 := (load4(a[28:]) >> 7)
+	b0 := 2097151 & load3(b[:])
+	b1 := 2097151 & (load4(b[2:]) >> 5)
+	b2 := 2097151 & (load3(b[5:]) >> 2)
+	b3 := 2097151 & (load4(b[7:]) >> 7)
+	b4 := 2097151 & (load4(b[10:]) >> 4)
+	b5 := 2097151 & (load3(b[13:]) >> 1)
+	b6 := 2097151 & (load4(b[15:]) >> 6)
+	b7 := 2097151 & (load3(b[18:]) >> 3)
+	b8 := 2097151 & load3(b[21:])
+	b9 := 2097151 & (load4(b[23:]) >> 5)
+	b10 := 2097151 & (load3(b[26:]) >> 2)
+	b11 := (load4(b[28:]) >> 7)
+	c0 := 2097151 & load3(c[:])
+	c1 := 2097151 & (load4(c[2:]) >> 5)
+	c2 := 2097151 & (load3(c[5:]) >> 2)
+	c3 := 2097151 & (load4(c[7:]) >> 7)
+	c4 := 2097151 & (load4(c[10:]) >> 4)
+	c5 := 2097151 & (load3(c[13:]) >> 1)
+	c6 := 2097151 & (load4(c[15:]) >> 6)
+	c7 := 2097151 & (load3(c[18:]) >> 3)
+	c8 := 2097151 & load3(c[21:])
+	c9 := 2097151 & (load4(c[23:]) >> 5)
+	c10 := 2097151 & (load3(c[26:]) >> 2)
+	c11 := (load4(c[28:]) >> 7)
+	var carry [23]int64
+
+	s0 := c0 + a0*b0
+	s1 := c1 + a0*b1 + a1*b0
+	s2 := c2 + a0*b2 + a1*b1 + a2*b0
+	s3 := c3 + a0*b3 + a1*b2 + a2*b1 + a3*b0
+	s4 := c4 + a0*b4 + a1*b3 + a2*b2 + a3*b1 + a4*b0
+	s5 := c5 + a0*b5 + a1*b4 + a2*b3 + a3*b2 + a4*b1 + a5*b0
+	s6 := c6 + a0*b6 + a1*b5 + a2*b4 + a3*b3 + a4*b2 + a5*b1 + a6*b0
+	s7 := c7 + a0*b7 + a1*b6 + a2*b5 + a3*b4 + a4*b3 + a5*b2 + a6*b1 + a7*b0
+	s8 := c8 + a0*b8 + a1*b7 + a2*b6 + a3*b5 + a4*b4 + a5*b3 + a6*b2 + a7*b1 + a8*b0
+	s9 := c9 + a0*b9 + a1*b8 + a2*b7 + a3*b6 + a4*b5 + a5*b4 + a6*b3 + a7*b2 + a8*b1 + a9*b0
+	s10 := c10 + a0*b10 + a1*b9 + a2*b8 + a3*b7 + a4*b6 + a5*b5 + a6*b4 + a7*b3 + a8*b2 + a9*b1 + a10*b0
+	s11 := c11 + a0*b11 + a1*b10 + a2*b9 + a3*b8 + a4*b7 + a5*b6 + a6*b5 + a7*b4 + a8*b3 + a9*b2 + a10*b1 + a11*b0
+	s12 := a1*b11 + a2*b10 + a3*b9 + a4*b8 + a5*b7 + a6*b6 + a7*b5 + a8*b4 + a9*b3 + a10*b2 + a11*b1
+	s13 := a2*b11 + a3*b10 + a4*b9 + a5*b8 + a6*b7 + a7*b6 + a8*b5 + a9*b4 + a10*b3 + a11*b2
+	s14 := a3*b11 + a4*b10 + a5*b9 + a6*b8 + a7*b7 + a8*b6 + a9*b5 + a10*b4 + a11*b3
+	s15 := a4*b11 + a5*b10 + a6*b9 + a7*b8 + a8*b7 + a9*b6 + a10*b5 + a11*b4
+	s16 := a5*b11 + a6*b10 + a7*b9 + a8*b8 + a9*b7 + a10*b6 + a11*b5
+	s17 := a6*b11 + a7*b10 + a8*b9 + a9*b8 + a10*b7 + a11*b6
+	s18 := a7*b11 + a8*b10 + a9*b9 + a10*b8 + a11*b7
+	s19 := a8*b11 + a9*b10 + a10*b9 + a11*b8
+	s20 := a9*b11 + a10*b10 + a11*b9
+	s21 := a10*b11 + a11*b10
+	s22 := a11 * b11
+	s23 := int64(0)
+
+	carry[0] = (s0 + (1 << 20)) >> 21
+	s1 += carry[0]
+	s0 -= carry[0] << 21
+	carry[2] = (s2 + (1 << 20)) >> 21
+	s3 += carry[2]
+	s2 -= carry[2] << 21
+	carry[4] = (s4 + (1 << 20)) >> 21
+	s5 += carry[4]
+	s4 -= carry[4] << 21
+	carry[6] = (s6 + (1 << 20)) >> 21
+	s7 += carry[6]
+	s6 -= carry[6] << 21
+	carry[8] = (s8 + (1 << 20)) >> 21
+	s9 += carry[8]
+	s8 -= carry[8] << 21
+	carry[10] = (s10 + (1 << 20)) >> 21
+	s11 += carry[10]
+	s10 -= carry[10] << 21
+	carry[12] = (s12 + (1 << 20)) >> 21
+	s13 += carry[12]
+	s12 -= carry[12] << 21
+	carry[14] = (s14 + (1 << 20)) >> 21
+	s15 += carry[14]
+	s14 -= carry[14] << 21
+	carry[16] = (s16 + (1 << 20)) >> 21
+	s17 += carry[16]
+	s16 -= carry[16] << 21
+	carry[18] = (s18 + (1 << 20)) >> 21
+	s19 += carry[18]
+	s18 -= carry[18] << 21
+	carry[20] = (s20 + (1 << 20)) >> 21
+	s21 += carry[20]
+	s20 -= carry[20] << 21
+	carry[22] = (s22 + (1 << 20)) >> 21
+	s23 += carry[22]
+	s22 -= carry[22] << 21
+
+	carry[1] = (s1 + (1 << 20)) >> 21
+	s2 += carry[1]
+	s1 -= carry[1] << 21
+	carry[3] = (s3 + (1 << 20)) >> 21
+	s4 += carry[3]
+	s3 -= carry[3] << 21
+	carry[5] = (s5 + (1 << 20)) >> 21
+	s6 += carry[5]
+	s5 -= carry[5] << 21
+	carry[7] = (s7 + (1 << 20)) >> 21
+	s8 += carry[7]
+	s7 -= carry[7] << 21
+	carry[9] = (s9 + (1 << 20)) >> 21
+	s10 += carry[9]
+	s9 -= carry[9] << 21
+	carry[11] = (s11 + (1 << 20)) >> 21
+	s12 += carry[11]
+	s11 -= carry[11] << 21
+	carry[13] = (s13 + (1 << 20)) >> 21
+	s14 += carry[13]
+	s13 -= carry[13] << 21
+	carry[15] = (s15 + (1 << 20)) >> 21
+	s16 += carry[15]
+	s15 -= carry[15] << 21
+	carry[17] = (s17 + (1 << 20)) >> 21
+	s18 += carry[17]
+	s17 -= carry[17] << 21
+	carry[19] = (s19 + (1 << 20)) >> 21
+	s20 += carry[19]
+	s19 -= carry[19] << 21
+	carry[21] = (s21 + (1 << 20)) >> 21
+	s22 += carry[21]
+	s21 -= carry[21] << 21
+
+	s11 += s23 * 666643
+	s12 += s23 * 470296
+	s13 += s23 * 654183
+	s14 -= s23 * 997805
+	s15 += s23 * 136657
+	s16 -= s23 * 683901
+	s23 = 0
+
+	s10 += s22 * 666643
+	s11 += s22 * 470296
+	s12 += s22 * 654183
+	s13 -= s22 * 997805
+	s14 += s22 * 136657
+	s15 -= s22 * 683901
+	s22 = 0
+
+	s9 += s21 * 666643
+	s10 += s21 * 470296
+	s11 += s21 * 654183
+	s12 -= s21 * 997805
+	s13 += s21 * 136657
+	s14 -= s21 * 683901
+	s21 = 0
+
+	s8 += s20 * 666643
+	s9 += s20 * 470296
+	s10 += s20 * 654183
+	s11 -= s20 * 997805
+	s12 += s20 * 136657
+	s13 -= s20 * 683901
+	s20 = 0
+
+	s7 += s19 * 666643
+	s8 += s19 * 470296
+	s9 += s19 * 654183
+	s10 -= s19 * 997805
+	s11 += s19 * 136657
+	s12 -= s19 * 683901
+	s19 = 0
+
+	s6 += s18 * 666643
+	s7 += s18 * 470296
+	s8 += s18 * 654183
+	s9 -= s18 * 997805
+	s10 += s18 * 136657
+	s11 -= s18 * 683901
+	s18 = 0
+
+	carry[6] = (s6 + (1 << 20)) >> 21
+	s7 += carry[6]
+	s6 -= carry[6] << 21
+	carry[8] = (s8 + (1 << 20)) >> 21
+	s9 += carry[8]
+	s8 -= carry[8] << 21
+	carry[10] = (s10 + (1 << 20)) >> 21
+	s11 += carry[10]
+	s10 -= carry[10] << 21
+	carry[12] = (s12 + (1 << 20)) >> 21
+	s13 += carry[12]
+	s12 -= carry[12] << 21
+	carry[14] = (s14 + (1 << 20)) >> 21
+	s15 += carry[14]
+	s14 -= carry[14] << 21
+	carry[16] = (s16 + (1 << 20)) >> 21
+	s17 += carry[16]
+	s16 -= carry[16] << 21
+
+	carry[7] = (s7 + (1 << 20)) >> 21
+	s8 += carry[7]
+	s7 -= carry[7] << 21
+	carry[9] = (s9 + (1 << 20)) >> 21
+	s10 += carry[9]
+	s9 -= carry[9] << 21
+	carry[11] = (s11 + (1 << 20)) >> 21
+	s12 += carry[11]
+	s11 -= carry[11] << 21
+	carry[13] = (s13 + (1 << 20)) >> 21
+	s14 += carry[13]
+	s13 -= carry[13] << 21
+	carry[15] = (s15 + (1 << 20)) >> 21
+	s16 += carry[15]
+	s15 -= carry[15] << 21
+
+	s5 += s17 * 666643
+	s6 += s17 * 470296
+	s7 += s17 * 654183
+	s8 -= s17 * 997805
+	s9 += s17 * 136657
+	s10 -= s17 * 683901
+	s17 = 0
+
+	s4 += s16 * 666643
+	s5 += s16 * 470296
+	s6 += s16 * 654183
+	s7 -= s16 * 997805
+	s8 += s16 * 136657
+	s9 -= s16 * 683901
+	s16 = 0
+
+	s3 += s15 * 666643
+	s4 += s15 * 470296
+	s5 += s15 * 654183
+	s6 -= s15 * 997805
+	s7 += s15 * 136657
+	s8 -= s15 * 683901
+	s15 = 0
+
+	s2 += s14 * 666643
+	s3 += s14 * 470296
+	s4 += s14 * 654183
+	s5 -= s14 * 997805
+	s6 += s14 * 136657
+	s7 -= s14 * 683901
+	s14 = 0
+
+	s1 += s13 * 666643
+	s2 += s13 * 470296
+	s3 += s13 * 654183
+	s4 -= s13 * 997805
+	s5 += s13 * 136657
+	s6 -= s13 * 683901
+	s13 = 0
+
+	s0 += s12 * 666643
+	s1 += s12 * 470296
+	s2 += s12 * 654183
+	s3 -= s12 * 997805
+	s4 += s12 * 136657
+	s5 -= s12 * 683901
+	s12 = 0
+
+	carry[0] = (s0 + (1 << 20)) >> 21
+	s1 += carry[0]
+	s0 -= carry[0] << 21
+	carry[2] = (s2 + (1 << 20)) >> 21
+	s3 += carry[2]
+	s2 -= carry[2] << 21
+	carry[4] = (s4 + (1 << 20)) >> 21
+	s5 += carry[4]
+	s4 -= carry[4] << 21
+	carry[6] = (s6 + (1 << 20)) >> 21
+	s7 += carry[6]
+	s6 -= carry[6] << 21
+	carry[8] = (s8 + (1 << 20)) >> 21
+	s9 += carry[8]
+	s8 -= carry[8] << 21
+	carry[10] = (s10 + (1 << 20)) >> 21
+	s11 += carry[10]
+	s10 -= carry[10] << 21
+
+	carry[1] = (s1 + (1 << 20)) >> 21
+	s2 += carry[1]
+	s1 -= carry[1] << 21
+	carry[3] = (s3 + (1 << 20)) >> 21
+	s4 += carry[3]
+	s3 -= carry[3] << 21
+	carry[5] = (s5 + (1 << 20)) >> 21
+	s6 += carry[5]
+	s5 -= carry[5] << 21
+	carry[7] = (s7 + (1 << 20)) >> 21
+	s8 += carry[7]
+	s7 -= carry[7] << 21
+	carry[9] = (s9 + (1 << 20)) >> 21
+	s10 += carry[9]
+	s9 -= carry[9] << 21
+	carry[11] = (s11 + (1 << 20)) >> 21
+	s12 += carry[11]
+	s11 -= carry[11] << 21
+
+	s0 += s12 * 666643
+	s1 += s12 * 470296
+	s2 += s12 * 654183
+	s3 -= s12 * 997805
+	s4 += s12 * 136657
+	s5 -= s12 * 683901
+	s12 = 0
+
+	carry[0] = s0 >> 21
+	s1 += carry[0]
+	s0 -= carry[0] << 21
+	carry[1] = s1 >> 21
+	s2 += carry[1]
+	s1 -= carry[1] << 21
+	carry[2] = s2 >> 21
+	s3 += carry[2]
+	s2 -= carry[2] << 21
+	carry[3] = s3 >> 21
+	s4 += carry[3]
+	s3 -= carry[3] << 21
+	carry[4] = s4 >> 21
+	s5 += carry[4]
+	s4 -= carry[4] << 21
+	carry[5] = s5 >> 21
+	s6 += carry[5]
+	s5 -= carry[5] << 21
+	carry[6] = s6 >> 21
+	s7 += carry[6]
+	s6 -= carry[6] << 21
+	carry[7] = s7 >> 21
+	s8 += carry[7]
+	s7 -= carry[7] << 21
+	carry[8] = s8 >> 21
+	s9 += carry[8]
+	s8 -= carry[8] << 21
+	carry[9] = s9 >> 21
+	s10 += carry[9]
+	s9 -= carry[9] << 21
+	carry[10] = s10 >> 21
+	s11 += carry[10]
+	s10 -= carry[10] << 21
+	carry[11] = s11 >> 21
+	s12 += carry[11]
+	s11 -= carry[11] << 21
+
+	s0 += s12 * 666643
+	s1 += s12 * 470296
+	s2 += s12 * 654183
+	s3 -= s12 * 997805
+	s4 += s12 * 136657
+	s5 -= s12 * 683901
+	s12 = 0
+
+	carry[0] = s0 >> 21
+	s1 += carry[0]
+	s0 -= carry[0] << 21
+	carry[1] = s1 >> 21
+	s2 += carry[1]
+	s1 -= carry[1] << 21
+	carry[2] = s2 >> 21
+	s3 += carry[2]
+	s2 -= carry[2] << 21
+	carry[3] = s3 >> 21
+	s4 += carry[3]
+	s3 -= carry[3] << 21
+	carry[4] = s4 >> 21
+	s5 += carry[4]
+	s4 -= carry[4] << 21
+	carry[5] = s5 >> 21
+	s6 += carry[5]
+	s5 -= carry[5] << 21
+	carry[6] = s6 >> 21
+	s7 += carry[6]
+	s6 -= carry[6] << 21
+	carry[7] = s7 >> 21
+	s8 += carry[7]
+	s7 -= carry[7] << 21
+	carry[8] = s8 >> 21
+	s9 += carry[8]
+	s8 -= carry[8] << 21
+	carry[9] = s9 >> 21
+	s10 += carry[9]
+	s9 -= carry[9] << 21
+	carry[10] = s10 >> 21
+	s11 += carry[10]
+	s10 -= carry[10] << 21
+
+	s[0] = byte(s0 >> 0)
+	s[1] = byte(s0 >> 8)
+	s[2] = byte((s0 >> 16) | (s1 << 5))
+	s[3] = byte(s1 >> 3)
+	s[4] = byte(s1 >> 11)
+	s[5] = byte((s1 >> 19) | (s2 << 2))
+	s[6] = byte(s2 >> 6)
+	s[7] = byte((s2 >> 14) | (s3 << 7))
+	s[8] = byte(s3 >> 1)
+	s[9] = byte(s3 >> 9)
+	s[10] = byte((s3 >> 17) | (s4 << 4))
+	s[11] = byte(s4 >> 4)
+	s[12] = byte(s4 >> 12)
+	s[13] = byte((s4 >> 20) | (s5 << 1))
+	s[14] = byte(s5 >> 7)
+	s[15] = byte((s5 >> 15) | (s6 << 6))
+	s[16] = byte(s6 >> 2)
+	s[17] = byte(s6 >> 10)
+	s[18] = byte((s6 >> 18) | (s7 << 3))
+	s[19] = byte(s7 >> 5)
+	s[20] = byte(s7 >> 13)
+	s[21] = byte(s8 >> 0)
+	s[22] = byte(s8 >> 8)
+	s[23] = byte((s8 >> 16) | (s9 << 5))
+	s[24] = byte(s9 >> 3)
+	s[25] = byte(s9 >> 11)
+	s[26] = byte((s9 >> 19) | (s10 << 2))
+	s[27] = byte(s10 >> 6)
+	s[28] = byte((s10 >> 14) | (s11 << 7))
+	s[29] = byte(s11 >> 1)
+	s[30] = byte(s11 >> 9)
+	s[31] = byte(s11 >> 17)
+}
+
+// Input:
+//   s[0]+256*s[1]+...+256^63*s[63] = s
+//
+// Output:
+//   s[0]+256*s[1]+...+256^31*s[31] = s mod l
+//   where l = 2^252 + 27742317777372353535851937790883648493.
+func scReduce(out *[32]byte, s *[64]byte) {
+	s0 := 2097151 & load3(s[:])
+	s1 := 2097151 & (load4(s[2:]) >> 5)
+	s2 := 2097151 & (load3(s[5:]) >> 2)
+	s3 := 2097151 & (load4(s[7:]) >> 7)
+	s4 := 2097151 & (load4(s[10:]) >> 4)
+	s5 := 2097151 & (load3(s[13:]) >> 1)
+	s6 := 2097151 & (load4(s[15:]) >> 6)
+	s7 := 2097151 & (load3(s[18:]) >> 3)
+	s8 := 2097151 & load3(s[21:])
+	s9 := 2097151 & (load4(s[23:]) >> 5)
+	s10 := 2097151 & (load3(s[26:]) >> 2)
+	s11 := 2097151 & (load4(s[28:]) >> 7)
+	s12 := 2097151 & (load4(s[31:]) >> 4)
+	s13 := 2097151 & (load3(s[34:]) >> 1)
+	s14 := 2097151 & (load4(s[36:]) >> 6)
+	s15 := 2097151 & (load3(s[39:]) >> 3)
+	s16 := 2097151 & load3(s[42:])
+	s17 := 2097151 & (load4(s[44:]) >> 5)
+	s18 := 2097151 & (load3(s[47:]) >> 2)
+	s19 := 2097151 & (load4(s[49:]) >> 7)
+	s20 := 2097151 & (load4(s[52:]) >> 4)
+	s21 := 2097151 & (load3(s[55:]) >> 1)
+	s22 := 2097151 & (load4(s[57:]) >> 6)
+	s23 := (load4(s[60:]) >> 3)
+
+	s11 += s23 * 666643
+	s12 += s23 * 470296
+	s13 += s23 * 654183
+	s14 -= s23 * 997805
+	s15 += s23 * 136657
+	s16 -= s23 * 683901
+	s23 = 0
+
+	s10 += s22 * 666643
+	s11 += s22 * 470296
+	s12 += s22 * 654183
+	s13 -= s22 * 997805
+	s14 += s22 * 136657
+	s15 -= s22 * 683901
+	s22 = 0
+
+	s9 += s21 * 666643
+	s10 += s21 * 470296
+	s11 += s21 * 654183
+	s12 -= s21 * 997805
+	s13 += s21 * 136657
+	s14 -= s21 * 683901
+	s21 = 0
+
+	s8 += s20 * 666643
+	s9 += s20 * 470296
+	s10 += s20 * 654183
+	s11 -= s20 * 997805
+	s12 += s20 * 136657
+	s13 -= s20 * 683901
+	s20 = 0
+
+	s7 += s19 * 666643
+	s8 += s19 * 470296
+	s9 += s19 * 654183
+	s10 -= s19 * 997805
+	s11 += s19 * 136657
+	s12 -= s19 * 683901
+	s19 = 0
+
+	s6 += s18 * 666643
+	s7 += s18 * 470296
+	s8 += s18 * 654183
+	s9 -= s18 * 997805
+	s10 += s18 * 136657
+	s11 -= s18 * 683901
+	s18 = 0
+
+	var carry [17]int64
+
+	carry[6] = (s6 + (1 << 20)) >> 21
+	s7 += carry[6]
+	s6 -= carry[6] << 21
+	carry[8] = (s8 + (1 << 20)) >> 21
+	s9 += carry[8]
+	s8 -= carry[8] << 21
+	carry[10] = (s10 + (1 << 20)) >> 21
+	s11 += carry[10]
+	s10 -= carry[10] << 21
+	carry[12] = (s12 + (1 << 20)) >> 21
+	s13 += carry[12]
+	s12 -= carry[12] << 21
+	carry[14] = (s14 + (1 << 20)) >> 21
+	s15 += carry[14]
+	s14 -= carry[14] << 21
+	carry[16] = (s16 + (1 << 20)) >> 21
+	s17 += carry[16]
+	s16 -= carry[16] << 21
+
+	carry[7] = (s7 + (1 << 20)) >> 21
+	s8 += carry[7]
+	s7 -= carry[7] << 21
+	carry[9] = (s9 + (1 << 20)) >> 21
+	s10 += carry[9]
+	s9 -= carry[9] << 21
+	carry[11] = (s11 + (1 << 20)) >> 21
+	s12 += carry[11]
+	s11 -= carry[11] << 21
+	carry[13] = (s13 + (1 << 20)) >> 21
+	s14 += carry[13]
+	s13 -= carry[13] << 21
+	carry[15] = (s15 + (1 << 20)) >> 21
+	s16 += carry[15]
+	s15 -= carry[15] << 21
+
+	s5 += s17 * 666643
+	s6 += s17 * 470296
+	s7 += s17 * 654183
+	s8 -= s17 * 997805
+	s9 += s17 * 136657
+	s10 -= s17 * 683901
+	s17 = 0
+
+	s4 += s16 * 666643
+	s5 += s16 * 470296
+	s6 += s16 * 654183
+	s7 -= s16 * 997805
+	s8 += s16 * 136657
+	s9 -= s16 * 683901
+	s16 = 0
+
+	s3 += s15 * 666643
+	s4 += s15 * 470296
+	s5 += s15 * 654183
+	s6 -= s15 * 997805
+	s7 += s15 * 136657
+	s8 -= s15 * 683901
+	s15 = 0
+
+	s2 += s14 * 666643
+	s3 += s14 * 470296
+	s4 += s14 * 654183
+	s5 -= s14 * 997805
+	s6 += s14 * 136657
+	s7 -= s14 * 683901
+	s14 = 0
+
+	s1 += s13 * 666643
+	s2 += s13 * 470296
+	s3 += s13 * 654183
+	s4 -= s13 * 997805
+	s5 += s13 * 136657
+	s6 -= s13 * 683901
+	s13 = 0
+
+	s0 += s12 * 666643
+	s1 += s12 * 470296
+	s2 += s12 * 654183
+	s3 -= s12 * 997805
+	s4 += s12 * 136657
+	s5 -= s12 * 683901
+	s12 = 0
+
+	carry[0] = (s0 + (1 << 20)) >> 21
+	s1 += carry[0]
+	s0 -= carry[0] << 21
+	carry[2] = (s2 + (1 << 20)) >> 21
+	s3 += carry[2]
+	s2 -= carry[2] << 21
+	carry[4] = (s4 + (1 << 20)) >> 21
+	s5 += carry[4]
+	s4 -= carry[4] << 21
+	carry[6] = (s6 + (1 << 20)) >> 21
+	s7 += carry[6]
+	s6 -= carry[6] << 21
+	carry[8] = (s8 + (1 << 20)) >> 21
+	s9 += carry[8]
+	s8 -= carry[8] << 21
+	carry[10] = (s10 + (1 << 20)) >> 21
+	s11 += carry[10]
+	s10 -= carry[10] << 21
+
+	carry[1] = (s1 + (1 << 20)) >> 21
+	s2 += carry[1]
+	s1 -= carry[1] << 21
+	carry[3] = (s3 + (1 << 20)) >> 21
+	s4 += carry[3]
+	s3 -= carry[3] << 21
+	carry[5] = (s5 + (1 << 20)) >> 21
+	s6 += carry[5]
+	s5 -= carry[5] << 21
+	carry[7] = (s7 + (1 << 20)) >> 21
+	s8 += carry[7]
+	s7 -= carry[7] << 21
+	carry[9] = (s9 + (1 << 20)) >> 21
+	s10 += carry[9]
+	s9 -= carry[9] << 21
+	carry[11] = (s11 + (1 << 20)) >> 21
+	s12 += carry[11]
+	s11 -= carry[11] << 21
+
+	s0 += s12 * 666643
+	s1 += s12 * 470296
+	s2 += s12 * 654183
+	s3 -= s12 * 997805
+	s4 += s12 * 136657
+	s5 -= s12 * 683901
+	s12 = 0
+
+	carry[0] = s0 >> 21
+	s1 += carry[0]
+	s0 -= carry[0] << 21
+	carry[1] = s1 >> 21
+	s2 += carry[1]
+	s1 -= carry[1] << 21
+	carry[2] = s2 >> 21
+	s3 += carry[2]
+	s2 -= carry[2] << 21
+	carry[3] = s3 >> 21
+	s4 += carry[3]
+	s3 -= carry[3] << 21
+	carry[4] = s4 >> 21
+	s5 += carry[4]
+	s4 -= carry[4] << 21
+	carry[5] = s5 >> 21
+	s6 += carry[5]
+	s5 -= carry[5] << 21
+	carry[6] = s6 >> 21
+	s7 += carry[6]
+	s6 -= carry[6] << 21
+	carry[7] = s7 >> 21
+	s8 += carry[7]
+	s7 -= carry[7] << 21
+	carry[8] = s8 >> 21
+	s9 += carry[8]
+	s8 -= carry[8] << 21
+	carry[9] = s9 >> 21
+	s10 += carry[9]
+	s9 -= carry[9] << 21
+	carry[10] = s10 >> 21
+	s11 += carry[10]
+	s10 -= carry[10] << 21
+	carry[11] = s11 >> 21
+	s12 += carry[11]
+	s11 -= carry[11] << 21
+
+	s0 += s12 * 666643
+	s1 += s12 * 470296
+	s2 += s12 * 654183
+	s3 -= s12 * 997805
+	s4 += s12 * 136657
+	s5 -= s12 * 683901
+	s12 = 0
+
+	carry[0] = s0 >> 21
+	s1 += carry[0]
+	s0 -= carry[0] << 21
+	carry[1] = s1 >> 21
+	s2 += carry[1]
+	s1 -= carry[1] << 21
+	carry[2] = s2 >> 21
+	s3 += carry[2]
+	s2 -= carry[2] << 21
+	carry[3] = s3 >> 21
+	s4 += carry[3]
+	s3 -= carry[3] << 21
+	carry[4] = s4 >> 21
+	s5 += carry[4]
+	s4 -= carry[4] << 21
+	carry[5] = s5 >> 21
+	s6 += carry[5]
+	s5 -= carry[5] << 21
+	carry[6] = s6 >> 21
+	s7 += carry[6]
+	s6 -= carry[6] << 21
+	carry[7] = s7 >> 21
+	s8 += carry[7]
+	s7 -= carry[7] << 21
+	carry[8] = s8 >> 21
+	s9 += carry[8]
+	s8 -= carry[8] << 21
+	carry[9] = s9 >> 21
+	s10 += carry[9]
+	s9 -= carry[9] << 21
+	carry[10] = s10 >> 21
+	s11 += carry[10]
+	s10 -= carry[10] << 21
+
+	out[0] = byte(s0 >> 0)
+	out[1] = byte(s0 >> 8)
+	out[2] = byte((s0 >> 16) | (s1 << 5))
+	out[3] = byte(s1 >> 3)
+	out[4] = byte(s1 >> 11)
+	out[5] = byte((s1 >> 19) | (s2 << 2))
+	out[6] = byte(s2 >> 6)
+	out[7] = byte((s2 >> 14) | (s3 << 7))
+	out[8] = byte(s3 >> 1)
+	out[9] = byte(s3 >> 9)
+	out[10] = byte((s3 >> 17) | (s4 << 4))
+	out[11] = byte(s4 >> 4)
+	out[12] = byte(s4 >> 12)
+	out[13] = byte((s4 >> 20) | (s5 << 1))
+	out[14] = byte(s5 >> 7)
+	out[15] = byte((s5 >> 15) | (s6 << 6))
+	out[16] = byte(s6 >> 2)
+	out[17] = byte(s6 >> 10)
+	out[18] = byte((s6 >> 18) | (s7 << 3))
+	out[19] = byte(s7 >> 5)
+	out[20] = byte(s7 >> 13)
+	out[21] = byte(s8 >> 0)
+	out[22] = byte(s8 >> 8)
+	out[23] = byte((s8 >> 16) | (s9 << 5))
+	out[24] = byte(s9 >> 3)
+	out[25] = byte(s9 >> 11)
+	out[26] = byte((s9 >> 19) | (s10 << 2))
+	out[27] = byte(s10 >> 6)
+	out[28] = byte((s10 >> 14) | (s11 << 7))
+	out[29] = byte(s11 >> 1)
+	out[30] = byte(s11 >> 9)
+	out[31] = byte(s11 >> 17)
+}
+
+// nonAdjacentForm computes a width-w non-adjacent form for this scalar.
+//
+// w must be between 2 and 8, or nonAdjacentForm will panic.
+func (s *Scalar) nonAdjacentForm(w uint) [256]int8 {
+	// This implementation is adapted from the one
+	// in curve25519-dalek and is documented there:
+	// https://github.com/dalek-cryptography/curve25519-dalek/blob/f630041af28e9a405255f98a8a93adca18e4315b/src/scalar.rs#L800-L871
+	if s.s[31] > 127 {
+		panic("scalar has high bit set illegally")
+	}
+	if w < 2 {
+		panic("w must be at least 2 by the definition of NAF")
+	} else if w > 8 {
+		panic("NAF digits must fit in int8")
+	}
+
+	var naf [256]int8
+	var digits [5]uint64
+
+	for i := 0; i < 4; i++ {
+		digits[i] = binary.LittleEndian.Uint64(s.s[i*8:])
+	}
+
+	width := uint64(1 << w)
+	windowMask := uint64(width - 1)
+
+	pos := uint(0)
+	carry := uint64(0)
+	for pos < 256 {
+		indexU64 := pos / 64
+		indexBit := pos % 64
+		var bitBuf uint64
+		if indexBit < 64-w {
+			// This window's bits are contained in a single u64
+			bitBuf = digits[indexU64] >> indexBit
+		} else {
+			// Combine the current 64 bits with bits from the next 64
+			bitBuf = (digits[indexU64] >> indexBit) | (digits[1+indexU64] << (64 - indexBit))
+		}
+
+		// Add carry into the current window
+		window := carry + (bitBuf & windowMask)
+
+		if window&1 == 0 {
+			// If the window value is even, preserve the carry and continue.
+			// Why is the carry preserved?
+			// If carry == 0 and window & 1 == 0,
+			//    then the next carry should be 0
+			// If carry == 1 and window & 1 == 0,
+			//    then bit_buf & 1 == 1 so the next carry should be 1
+			pos += 1
+			continue
+		}
+
+		if window < width/2 {
+			carry = 0
+			naf[pos] = int8(window)
+		} else {
+			carry = 1
+			naf[pos] = int8(window) - int8(width)
+		}
+
+		pos += w
+	}
+	return naf
+}
+
+func (s *Scalar) signedRadix16() [64]int8 {
+	if s.s[31] > 127 {
+		panic("scalar has high bit set illegally")
+	}
+
+	var digits [64]int8
+
+	// Compute unsigned radix-16 digits:
+	for i := 0; i < 32; i++ {
+		digits[2*i] = int8(s.s[i] & 15)
+		digits[2*i+1] = int8((s.s[i] >> 4) & 15)
+	}
+
+	// Recenter coefficients:
+	for i := 0; i < 63; i++ {
+		carry := (digits[i] + 8) >> 4
+		digits[i] -= carry << 4
+		digits[i+1] += carry
+	}
+
+	return digits
+}
diff --git a/crypto/edwards25519/scalar_alias_test.go b/crypto/edwards25519/scalar_alias_test.go
new file mode 100644
index 000000000..827153b9b
--- /dev/null
+++ b/crypto/edwards25519/scalar_alias_test.go
@@ -0,0 +1,93 @@
+// Copyright (c) 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package edwards25519
+
+import (
+	"testing"
+	"testing/quick"
+)
+
+func TestScalarAliasing(t *testing.T) {
+	checkAliasingOneArg := func(f func(v, x *Scalar) *Scalar, v, x Scalar) bool {
+		x1, v1 := x, x
+
+		// Calculate a reference f(x) without aliasing.
+		if out := f(&v, &x); out != &v || !isReduced(out) {
+			return false
+		}
+
+		// Test aliasing the argument and the receiver.
+		if out := f(&v1, &v1); out != &v1 || v1 != v || !isReduced(out) {
+			return false
+		}
+
+		// Ensure the arguments was not modified.
+		return x == x1
+	}
+
+	checkAliasingTwoArgs := func(f func(v, x, y *Scalar) *Scalar, v, x, y Scalar) bool {
+		x1, y1, v1 := x, y, Scalar{}
+
+		// Calculate a reference f(x, y) without aliasing.
+		if out := f(&v, &x, &y); out != &v || !isReduced(out) {
+			return false
+		}
+
+		// Test aliasing the first argument and the receiver.
+		v1 = x
+		if out := f(&v1, &v1, &y); out != &v1 || v1 != v || !isReduced(out) {
+			return false
+		}
+		// Test aliasing the second argument and the receiver.
+		v1 = y
+		if out := f(&v1, &x, &v1); out != &v1 || v1 != v || !isReduced(out) {
+			return false
+		}
+
+		// Calculate a reference f(x, x) without aliasing.
+		if out := f(&v, &x, &x); out != &v || !isReduced(out) {
+			return false
+		}
+
+		// Test aliasing the first argument and the receiver.
+		v1 = x
+		if out := f(&v1, &v1, &x); out != &v1 || v1 != v || !isReduced(out) {
+			return false
+		}
+		// Test aliasing the second argument and the receiver.
+		v1 = x
+		if out := f(&v1, &x, &v1); out != &v1 || v1 != v || !isReduced(out) {
+			return false
+		}
+		// Test aliasing both arguments and the receiver.
+		v1 = x
+		if out := f(&v1, &v1, &v1); out != &v1 || v1 != v || !isReduced(out) {
+			return false
+		}
+
+		// Ensure the arguments were not modified.
+		return x == x1 && y == y1
+	}
+
+	for name, f := range map[string]any{
+		"Negate": func(v, x Scalar) bool {
+			return checkAliasingOneArg((*Scalar).Negate, v, x)
+		},
+		"Multiply": func(v, x, y Scalar) bool {
+			return checkAliasingTwoArgs((*Scalar).Multiply, v, x, y)
+		},
+		"Add": func(v, x, y Scalar) bool {
+			return checkAliasingTwoArgs((*Scalar).Add, v, x, y)
+		},
+		"Subtract": func(v, x, y Scalar) bool {
+			return checkAliasingTwoArgs((*Scalar).Subtract, v, x, y)
+		},
+	} {
+		err := quick.Check(f, &quick.Config{MaxCountScale: 1 << 5})
+		if err != nil {
+			t.Errorf("%v: %v", name, err)
+		}
+	}
+}
diff --git a/crypto/edwards25519/scalar_test.go b/crypto/edwards25519/scalar_test.go
new file mode 100644
index 000000000..704caffc5
--- /dev/null
+++ b/crypto/edwards25519/scalar_test.go
@@ -0,0 +1,233 @@
+// Copyright (c) 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package edwards25519
+
+import (
+	"bytes"
+	"encoding/hex"
+	"math/big"
+	mathrand "math/rand"
+	"reflect"
+	"testing"
+	"testing/quick"
+)
+
+// Generate returns a valid (reduced modulo l) Scalar with a distribution
+// weighted towards high, low, and edge values.
+func (Scalar) Generate(rand *mathrand.Rand, size int) reflect.Value {
+	s := scZero
+	diceRoll := rand.Intn(100)
+	switch {
+	case diceRoll == 0:
+	case diceRoll == 1:
+		s = scOne
+	case diceRoll == 2:
+		s = scMinusOne
+	case diceRoll < 5:
+		// Generate a low scalar in [0, 2^125).
+		rand.Read(s.s[:16])
+		s.s[15] &= (1 << 5) - 1
+	case diceRoll < 10:
+		// Generate a high scalar in [2^252, 2^252 + 2^124).
+		s.s[31] = 1 << 4
+		rand.Read(s.s[:16])
+		s.s[15] &= (1 << 4) - 1
+	default:
+		// Generate a valid scalar in [0, l) by returning [0, 2^252) which has a
+		// negligibly different distribution (the former has a 2^-127.6 chance
+		// of being out of the latter range).
+		rand.Read(s.s[:])
+		s.s[31] &= (1 << 4) - 1
+	}
+	return reflect.ValueOf(s)
+}
+
+// quickCheckConfig1024 will make each quickcheck test run (1024 * -quickchecks)
+// times. The default value of -quickchecks is 100.
+var quickCheckConfig1024 = &quick.Config{MaxCountScale: 1 << 10}
+
+func TestScalarGenerate(t *testing.T) {
+	f := func(sc Scalar) bool {
+		return isReduced(&sc)
+	}
+	if err := quick.Check(f, quickCheckConfig1024); err != nil {
+		t.Errorf("generated unreduced scalar: %v", err)
+	}
+}
+
+func TestScalarSetCanonicalBytes(t *testing.T) {
+	f1 := func(in [32]byte, sc Scalar) bool {
+		// Mask out top 4 bits to guarantee value falls in [0, l).
+		in[len(in)-1] &= (1 << 4) - 1
+		if _, err := sc.SetCanonicalBytes(in[:]); err != nil {
+			return false
+		}
+		return bytes.Equal(in[:], sc.Bytes()) && isReduced(&sc)
+	}
+	if err := quick.Check(f1, quickCheckConfig1024); err != nil {
+		t.Errorf("failed bytes->scalar->bytes round-trip: %v", err)
+	}
+
+	f2 := func(sc1, sc2 Scalar) bool {
+		if _, err := sc2.SetCanonicalBytes(sc1.Bytes()); err != nil {
+			return false
+		}
+		return sc1 == sc2
+	}
+	if err := quick.Check(f2, quickCheckConfig1024); err != nil {
+		t.Errorf("failed scalar->bytes->scalar round-trip: %v", err)
+	}
+
+	b := scMinusOne.s
+	b[31] += 1
+	s := scOne
+	if out, err := s.SetCanonicalBytes(b[:]); err == nil {
+		t.Errorf("SetCanonicalBytes worked on a non-canonical value")
+	} else if s != scOne {
+		t.Errorf("SetCanonicalBytes modified its receiver")
+	} else if out != nil {
+		t.Errorf("SetCanonicalBytes did not return nil with an error")
+	}
+}
+
+func TestScalarSetUniformBytes(t *testing.T) {
+	mod, _ := new(big.Int).SetString("27742317777372353535851937790883648493", 10)
+	mod.Add(mod, new(big.Int).Lsh(big.NewInt(1), 252))
+	f := func(in [64]byte, sc Scalar) bool {
+		sc.SetUniformBytes(in[:])
+		if !isReduced(&sc) {
+			return false
+		}
+		scBig := bigIntFromLittleEndianBytes(sc.s[:])
+		inBig := bigIntFromLittleEndianBytes(in[:])
+		return inBig.Mod(inBig, mod).Cmp(scBig) == 0
+	}
+	if err := quick.Check(f, quickCheckConfig1024); err != nil {
+		t.Error(err)
+	}
+}
+
+func TestScalarSetBytesWithClamping(t *testing.T) {
+	// Generated with libsodium.js 1.0.18 crypto_scalarmult_ed25519_base.
+
+	random := "633d368491364dc9cd4c1bf891b1d59460face1644813240a313e61f2c88216e"
+	s := new(Scalar).SetBytesWithClamping(decodeHex(random))
+	p := new(Point).ScalarBaseMult(s)
+	want := "1d87a9026fd0126a5736fe1628c95dd419172b5b618457e041c9c861b2494a94"
+	if got := hex.EncodeToString(p.Bytes()); got != want {
+		t.Errorf("random: got %q, want %q", got, want)
+	}
+
+	zero := "0000000000000000000000000000000000000000000000000000000000000000"
+	s = new(Scalar).SetBytesWithClamping(decodeHex(zero))
+	p = new(Point).ScalarBaseMult(s)
+	want = "693e47972caf527c7883ad1b39822f026f47db2ab0e1919955b8993aa04411d1"
+	if got := hex.EncodeToString(p.Bytes()); got != want {
+		t.Errorf("zero: got %q, want %q", got, want)
+	}
+
+	one := "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"
+	s = new(Scalar).SetBytesWithClamping(decodeHex(one))
+	p = new(Point).ScalarBaseMult(s)
+	want = "12e9a68b73fd5aacdbcaf3e88c46fea6ebedb1aa84eed1842f07f8edab65e3a7"
+	if got := hex.EncodeToString(p.Bytes()); got != want {
+		t.Errorf("one: got %q, want %q", got, want)
+	}
+}
+
+func bigIntFromLittleEndianBytes(b []byte) *big.Int {
+	bb := make([]byte, len(b))
+	for i := range b {
+		bb[i] = b[len(b)-i-1]
+	}
+	return new(big.Int).SetBytes(bb)
+}
+
+func TestScalarMultiplyDistributesOverAdd(t *testing.T) {
+	multiplyDistributesOverAdd := func(x, y, z Scalar) bool {
+		// Compute t1 = (x+y)*z
+		var t1 Scalar
+		t1.Add(&x, &y)
+		t1.Multiply(&t1, &z)
+
+		// Compute t2 = x*z + y*z
+		var t2 Scalar
+		var t3 Scalar
+		t2.Multiply(&x, &z)
+		t3.Multiply(&y, &z)
+		t2.Add(&t2, &t3)
+
+		return t1 == t2 && isReduced(&t1) && isReduced(&t3)
+	}
+
+	if err := quick.Check(multiplyDistributesOverAdd, quickCheckConfig1024); err != nil {
+		t.Error(err)
+	}
+}
+
+func TestScalarAddLikeSubNeg(t *testing.T) {
+	addLikeSubNeg := func(x, y Scalar) bool {
+		// Compute t1 = x - y
+		var t1 Scalar
+		t1.Subtract(&x, &y)
+
+		// Compute t2 = -y + x
+		var t2 Scalar
+		t2.Negate(&y)
+		t2.Add(&t2, &x)
+
+		return t1 == t2 && isReduced(&t1)
+	}
+
+	if err := quick.Check(addLikeSubNeg, quickCheckConfig1024); err != nil {
+		t.Error(err)
+	}
+}
+
+func TestScalarNonAdjacentForm(t *testing.T) {
+	s := Scalar{[32]byte{
+		0x1a, 0x0e, 0x97, 0x8a, 0x90, 0xf6, 0x62, 0x2d,
+		0x37, 0x47, 0x02, 0x3f, 0x8a, 0xd8, 0x26, 0x4d,
+		0xa7, 0x58, 0xaa, 0x1b, 0x88, 0xe0, 0x40, 0xd1,
+		0x58, 0x9e, 0x7b, 0x7f, 0x23, 0x76, 0xef, 0x09,
+	}}
+	expectedNaf := [256]int8{
+		0, 13, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, -9, 0, 0, 0, 0, -11, 0, 0, 0, 0, 3, 0, 0, 0, 0, 1,
+		0, 0, 0, 0, 9, 0, 0, 0, 0, -5, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 11, 0, 0, 0, 0, 11, 0, 0, 0, 0, 0,
+		-9, 0, 0, 0, 0, 0, -3, 0, 0, 0, 0, 9, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 9, 0,
+		0, 0, 0, -15, 0, 0, 0, 0, -7, 0, 0, 0, 0, -9, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 13, 0, 0, 0, 0, 0, -3, 0,
+		0, 0, 0, -11, 0, 0, 0, 0, -7, 0, 0, 0, 0, -13, 0, 0, 0, 0, 11, 0, 0, 0, 0, -9, 0, 0, 0, 0, 0, 1, 0, 0,
+		0, 0, 0, -15, 0, 0, 0, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 13, 0, 0, 0,
+		0, 0, 0, 11, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, -9, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 7,
+		0, 0, 0, 0, 0, -15, 0, 0, 0, 0, 0, 15, 0, 0, 0, 0, 15, 0, 0, 0, 0, 15, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
+	}
+
+	sNaf := s.nonAdjacentForm(5)
+
+	for i := 0; i < 256; i++ {
+		if expectedNaf[i] != sNaf[i] {
+			t.Errorf("Wrong digit at position %d, got %d, expected %d", i, sNaf[i], expectedNaf[i])
+		}
+	}
+}
+
+type notZeroScalar Scalar
+
+func (notZeroScalar) Generate(rand *mathrand.Rand, size int) reflect.Value {
+	var s Scalar
+	for s == scZero {
+		s = Scalar{}.Generate(rand, size).Interface().(Scalar)
+	}
+	return reflect.ValueOf(notZeroScalar(s))
+}
+
+func TestScalarEqual(t *testing.T) {
+	if scOne.Equal(&scMinusOne) == 1 {
+		t.Errorf("scOne.Equal(&scMinusOne) is true")
+	}
+	if scMinusOne.Equal(&scMinusOne) == 0 {
+		t.Errorf("scMinusOne.Equal(&scMinusOne) is false")
+	}
+}
diff --git a/crypto/edwards25519/scalarmult.go b/crypto/edwards25519/scalarmult.go
new file mode 100644
index 000000000..f7ca3cef9
--- /dev/null
+++ b/crypto/edwards25519/scalarmult.go
@@ -0,0 +1,214 @@
+// Copyright (c) 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package edwards25519
+
+import "sync"
+
+// basepointTable is a set of 32 affineLookupTables, where table i is generated
+// from 256i * basepoint. It is precomputed the first time it's used.
+func basepointTable() *[32]affineLookupTable {
+	basepointTablePrecomp.initOnce.Do(func() {
+		p := NewGeneratorPoint()
+		for i := 0; i < 32; i++ {
+			basepointTablePrecomp.table[i].FromP3(p)
+			for j := 0; j < 8; j++ {
+				p.Add(p, p)
+			}
+		}
+	})
+	return &basepointTablePrecomp.table
+}
+
+var basepointTablePrecomp struct {
+	table    [32]affineLookupTable
+	initOnce sync.Once
+}
+
+// ScalarBaseMult sets v = x * B, where B is the canonical generator, and
+// returns v.
+//
+// The scalar multiplication is done in constant time.
+func (v *Point) ScalarBaseMult(x *Scalar) *Point {
+	basepointTable := basepointTable()
+
+	// Write x = sum(x_i * 16^i) so  x*B = sum( B*x_i*16^i )
+	// as described in the Ed25519 paper
+	//
+	// Group even and odd coefficients
+	// x*B     = x_0*16^0*B + x_2*16^2*B + ... + x_62*16^62*B
+	//         + x_1*16^1*B + x_3*16^3*B + ... + x_63*16^63*B
+	// x*B     = x_0*16^0*B + x_2*16^2*B + ... + x_62*16^62*B
+	//    + 16*( x_1*16^0*B + x_3*16^2*B + ... + x_63*16^62*B)
+	//
+	// We use a lookup table for each i to get x_i*16^(2*i)*B
+	// and do four doublings to multiply by 16.
+	digits := x.signedRadix16()
+
+	multiple := &affineCached{}
+	tmp1 := &projP1xP1{}
+	tmp2 := &projP2{}
+
+	// Accumulate the odd components first
+	v.Set(NewIdentityPoint())
+	for i := 1; i < 64; i += 2 {
+		basepointTable[i/2].SelectInto(multiple, digits[i])
+		tmp1.AddAffine(v, multiple)
+		v.fromP1xP1(tmp1)
+	}
+
+	// Multiply by 16
+	tmp2.FromP3(v)       // tmp2 =    v in P2 coords
+	tmp1.Double(tmp2)    // tmp1 =  2*v in P1xP1 coords
+	tmp2.FromP1xP1(tmp1) // tmp2 =  2*v in P2 coords
+	tmp1.Double(tmp2)    // tmp1 =  4*v in P1xP1 coords
+	tmp2.FromP1xP1(tmp1) // tmp2 =  4*v in P2 coords
+	tmp1.Double(tmp2)    // tmp1 =  8*v in P1xP1 coords
+	tmp2.FromP1xP1(tmp1) // tmp2 =  8*v in P2 coords
+	tmp1.Double(tmp2)    // tmp1 = 16*v in P1xP1 coords
+	v.fromP1xP1(tmp1)    // now v = 16*(odd components)
+
+	// Accumulate the even components
+	for i := 0; i < 64; i += 2 {
+		basepointTable[i/2].SelectInto(multiple, digits[i])
+		tmp1.AddAffine(v, multiple)
+		v.fromP1xP1(tmp1)
+	}
+
+	return v
+}
+
+// ScalarMult sets v = x * q, and returns v.
+//
+// The scalar multiplication is done in constant time.
+func (v *Point) ScalarMult(x *Scalar, q *Point) *Point {
+	checkInitialized(q)
+
+	var table projLookupTable
+	table.FromP3(q)
+
+	// Write x = sum(x_i * 16^i)
+	// so  x*Q = sum( Q*x_i*16^i )
+	//         = Q*x_0 + 16*(Q*x_1 + 16*( ... + Q*x_63) ... )
+	//           <------compute inside out---------
+	//
+	// We use the lookup table to get the x_i*Q values
+	// and do four doublings to compute 16*Q
+	digits := x.signedRadix16()
+
+	// Unwrap first loop iteration to save computing 16*identity
+	multiple := &projCached{}
+	tmp1 := &projP1xP1{}
+	tmp2 := &projP2{}
+	table.SelectInto(multiple, digits[63])
+
+	v.Set(NewIdentityPoint())
+	tmp1.Add(v, multiple) // tmp1 = x_63*Q in P1xP1 coords
+	for i := 62; i >= 0; i-- {
+		tmp2.FromP1xP1(tmp1) // tmp2 =    (prev) in P2 coords
+		tmp1.Double(tmp2)    // tmp1 =  2*(prev) in P1xP1 coords
+		tmp2.FromP1xP1(tmp1) // tmp2 =  2*(prev) in P2 coords
+		tmp1.Double(tmp2)    // tmp1 =  4*(prev) in P1xP1 coords
+		tmp2.FromP1xP1(tmp1) // tmp2 =  4*(prev) in P2 coords
+		tmp1.Double(tmp2)    // tmp1 =  8*(prev) in P1xP1 coords
+		tmp2.FromP1xP1(tmp1) // tmp2 =  8*(prev) in P2 coords
+		tmp1.Double(tmp2)    // tmp1 = 16*(prev) in P1xP1 coords
+		v.fromP1xP1(tmp1)    //    v = 16*(prev) in P3 coords
+		table.SelectInto(multiple, digits[i])
+		tmp1.Add(v, multiple) // tmp1 = x_i*Q + 16*(prev) in P1xP1 coords
+	}
+	v.fromP1xP1(tmp1)
+	return v
+}
+
+// basepointNafTable is the nafLookupTable8 for the basepoint.
+// It is precomputed the first time it's used.
+func basepointNafTable() *nafLookupTable8 {
+	basepointNafTablePrecomp.initOnce.Do(func() {
+		basepointNafTablePrecomp.table.FromP3(NewGeneratorPoint())
+	})
+	return &basepointNafTablePrecomp.table
+}
+
+var basepointNafTablePrecomp struct {
+	table    nafLookupTable8
+	initOnce sync.Once
+}
+
+// VarTimeDoubleScalarBaseMult sets v = a * A + b * B, where B is the canonical
+// generator, and returns v.
+//
+// Execution time depends on the inputs.
+func (v *Point) VarTimeDoubleScalarBaseMult(a *Scalar, A *Point, b *Scalar) *Point {
+	checkInitialized(A)
+
+	// Similarly to the single variable-base approach, we compute
+	// digits and use them with a lookup table.  However, because
+	// we are allowed to do variable-time operations, we don't
+	// need constant-time lookups or constant-time digit
+	// computations.
+	//
+	// So we use a non-adjacent form of some width w instead of
+	// radix 16.  This is like a binary representation (one digit
+	// for each binary place) but we allow the digits to grow in
+	// magnitude up to 2^{w-1} so that the nonzero digits are as
+	// sparse as possible.  Intuitively, this "condenses" the
+	// "mass" of the scalar onto sparse coefficients (meaning
+	// fewer additions).
+
+	basepointNafTable := basepointNafTable()
+	var aTable nafLookupTable5
+	aTable.FromP3(A)
+	// Because the basepoint is fixed, we can use a wider NAF
+	// corresponding to a bigger table.
+	aNaf := a.nonAdjacentForm(5)
+	bNaf := b.nonAdjacentForm(8)
+
+	// Find the first nonzero coefficient.
+	i := 255
+	for j := i; j >= 0; j-- {
+		if aNaf[j] != 0 || bNaf[j] != 0 {
+			break
+		}
+	}
+
+	multA := &projCached{}
+	multB := &affineCached{}
+	tmp1 := &projP1xP1{}
+	tmp2 := &projP2{}
+	tmp2.Zero()
+
+	// Move from high to low bits, doubling the accumulator
+	// at each iteration and checking whether there is a nonzero
+	// coefficient to look up a multiple of.
+	for ; i >= 0; i-- {
+		tmp1.Double(tmp2)
+
+		// Only update v if we have a nonzero coeff to add in.
+		if aNaf[i] > 0 {
+			v.fromP1xP1(tmp1)
+			aTable.SelectInto(multA, aNaf[i])
+			tmp1.Add(v, multA)
+		} else if aNaf[i] < 0 {
+			v.fromP1xP1(tmp1)
+			aTable.SelectInto(multA, -aNaf[i])
+			tmp1.Sub(v, multA)
+		}
+
+		if bNaf[i] > 0 {
+			v.fromP1xP1(tmp1)
+			basepointNafTable.SelectInto(multB, bNaf[i])
+			tmp1.AddAffine(v, multB)
+		} else if bNaf[i] < 0 {
+			v.fromP1xP1(tmp1)
+			basepointNafTable.SelectInto(multB, -bNaf[i])
+			tmp1.SubAffine(v, multB)
+		}
+
+		tmp2.FromP1xP1(tmp1)
+	}
+
+	v.fromP2(tmp2)
+	return v
+}
diff --git a/crypto/edwards25519/scalarmult_test.go b/crypto/edwards25519/scalarmult_test.go
new file mode 100644
index 000000000..c2027f5dd
--- /dev/null
+++ b/crypto/edwards25519/scalarmult_test.go
@@ -0,0 +1,209 @@
+// Copyright (c) 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package edwards25519
+
+import (
+	"testing"
+	"testing/quick"
+)
+
+var (
+	// quickCheckConfig32 will make each quickcheck test run (32 * -quickchecks)
+	// times. The default value of -quickchecks is 100.
+	quickCheckConfig32 = &quick.Config{MaxCountScale: 1 << 5}
+
+	// a random scalar generated using dalek.
+	dalekScalar = Scalar{[32]byte{219, 106, 114, 9, 174, 249, 155, 89, 69, 203, 201, 93, 92, 116, 234, 187, 78, 115, 103, 172, 182, 98, 62, 103, 187, 136, 13, 100, 248, 110, 12, 4}}
+	// the above, times the edwards25519 basepoint.
+	dalekScalarBasepoint, _ = new(Point).SetBytes([]byte{0xf4, 0xef, 0x7c, 0xa, 0x34, 0x55, 0x7b, 0x9f, 0x72, 0x3b, 0xb6, 0x1e, 0xf9, 0x46, 0x9, 0x91, 0x1c, 0xb9, 0xc0, 0x6c, 0x17, 0x28, 0x2d, 0x8b, 0x43, 0x2b, 0x5, 0x18, 0x6a, 0x54, 0x3e, 0x48})
+)
+
+func TestScalarMultSmallScalars(t *testing.T) {
+	var z Scalar
+	var p Point
+	p.ScalarMult(&z, B)
+	if I.Equal(&p) != 1 {
+		t.Error("0*B != 0")
+	}
+	checkOnCurve(t, &p)
+
+	z = Scalar{[32]byte{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}
+	p.ScalarMult(&z, B)
+	if B.Equal(&p) != 1 {
+		t.Error("1*B != 1")
+	}
+	checkOnCurve(t, &p)
+}
+
+func TestScalarMultVsDalek(t *testing.T) {
+	var p Point
+	p.ScalarMult(&dalekScalar, B)
+	if dalekScalarBasepoint.Equal(&p) != 1 {
+		t.Error("Scalar mul does not match dalek")
+	}
+	checkOnCurve(t, &p)
+}
+
+func TestBaseMultVsDalek(t *testing.T) {
+	var p Point
+	p.ScalarBaseMult(&dalekScalar)
+	if dalekScalarBasepoint.Equal(&p) != 1 {
+		t.Error("Scalar mul does not match dalek")
+	}
+	checkOnCurve(t, &p)
+}
+
+func TestVarTimeDoubleBaseMultVsDalek(t *testing.T) {
+	var p Point
+	var z Scalar
+	p.VarTimeDoubleScalarBaseMult(&dalekScalar, B, &z)
+	if dalekScalarBasepoint.Equal(&p) != 1 {
+		t.Error("VarTimeDoubleScalarBaseMult fails with b=0")
+	}
+	checkOnCurve(t, &p)
+	p.VarTimeDoubleScalarBaseMult(&z, B, &dalekScalar)
+	if dalekScalarBasepoint.Equal(&p) != 1 {
+		t.Error("VarTimeDoubleScalarBaseMult fails with a=0")
+	}
+	checkOnCurve(t, &p)
+}
+
+func TestScalarMultDistributesOverAdd(t *testing.T) {
+	scalarMultDistributesOverAdd := func(x, y Scalar) bool {
+		var z Scalar
+		z.Add(&x, &y)
+		var p, q, r, check Point
+		p.ScalarMult(&x, B)
+		q.ScalarMult(&y, B)
+		r.ScalarMult(&z, B)
+		check.Add(&p, &q)
+		checkOnCurve(t, &p, &q, &r, &check)
+		return check.Equal(&r) == 1
+	}
+
+	if err := quick.Check(scalarMultDistributesOverAdd, quickCheckConfig32); err != nil {
+		t.Error(err)
+	}
+}
+
+func TestScalarMultNonIdentityPoint(t *testing.T) {
+	// Check whether p.ScalarMult and q.ScalaBaseMult give the same,
+	// when p and q are originally set to the base point.
+
+	scalarMultNonIdentityPoint := func(x Scalar) bool {
+		var p, q Point
+		p.Set(B)
+		q.Set(B)
+
+		p.ScalarMult(&x, B)
+		q.ScalarBaseMult(&x)
+
+		checkOnCurve(t, &p, &q)
+
+		return p.Equal(&q) == 1
+	}
+
+	if err := quick.Check(scalarMultNonIdentityPoint, quickCheckConfig32); err != nil {
+		t.Error(err)
+	}
+}
+
+func TestBasepointTableGeneration(t *testing.T) {
+	// The basepoint table is 32 affineLookupTables,
+	// corresponding to (16^2i)*B for table i.
+	basepointTable := basepointTable()
+
+	tmp1 := &projP1xP1{}
+	tmp2 := &projP2{}
+	tmp3 := &Point{}
+	tmp3.Set(B)
+	table := make([]affineLookupTable, 32)
+	for i := 0; i < 32; i++ {
+		// Build the table
+		table[i].FromP3(tmp3)
+		// Assert equality with the hardcoded one
+		if table[i] != basepointTable[i] {
+			t.Errorf("Basepoint table %d does not match", i)
+		}
+
+		// Set p = (16^2)*p = 256*p = 2^8*p
+		tmp2.FromP3(tmp3)
+		for j := 0; j < 7; j++ {
+			tmp1.Double(tmp2)
+			tmp2.FromP1xP1(tmp1)
+		}
+		tmp1.Double(tmp2)
+		tmp3.fromP1xP1(tmp1)
+		checkOnCurve(t, tmp3)
+	}
+}
+
+func TestScalarMultMatchesBaseMult(t *testing.T) {
+	scalarMultMatchesBaseMult := func(x Scalar) bool {
+		var p, q Point
+		p.ScalarMult(&x, B)
+		q.ScalarBaseMult(&x)
+		checkOnCurve(t, &p, &q)
+		return p.Equal(&q) == 1
+	}
+
+	if err := quick.Check(scalarMultMatchesBaseMult, quickCheckConfig32); err != nil {
+		t.Error(err)
+	}
+}
+
+func TestBasepointNafTableGeneration(t *testing.T) {
+	var table nafLookupTable8
+	table.FromP3(B)
+
+	if table != *basepointNafTable() {
+		t.Error("BasepointNafTable does not match")
+	}
+}
+
+func TestVarTimeDoubleBaseMultMatchesBaseMult(t *testing.T) {
+	varTimeDoubleBaseMultMatchesBaseMult := func(x, y Scalar) bool {
+		var p, q1, q2, check Point
+
+		p.VarTimeDoubleScalarBaseMult(&x, B, &y)
+
+		q1.ScalarBaseMult(&x)
+		q2.ScalarBaseMult(&y)
+		check.Add(&q1, &q2)
+
+		checkOnCurve(t, &p, &check, &q1, &q2)
+		return p.Equal(&check) == 1
+	}
+
+	if err := quick.Check(varTimeDoubleBaseMultMatchesBaseMult, quickCheckConfig32); err != nil {
+		t.Error(err)
+	}
+}
+
+// Benchmarks.
+
+func BenchmarkScalarBaseMult(t *testing.B) {
+	var p Point
+
+	for i := 0; i < t.N; i++ {
+		p.ScalarBaseMult(&dalekScalar)
+	}
+}
+
+func BenchmarkScalarMult(t *testing.B) {
+	var p Point
+
+	for i := 0; i < t.N; i++ {
+		p.ScalarMult(&dalekScalar, B)
+	}
+}
+
+func BenchmarkVarTimeDoubleScalarBaseMult(t *testing.B) {
+	var p Point
+
+	for i := 0; i < t.N; i++ {
+		p.VarTimeDoubleScalarBaseMult(&dalekScalar, B, &dalekScalar)
+	}
+}
diff --git a/crypto/edwards25519/tables.go b/crypto/edwards25519/tables.go
new file mode 100644
index 000000000..5ca40f7bf
--- /dev/null
+++ b/crypto/edwards25519/tables.go
@@ -0,0 +1,129 @@
+// Copyright (c) 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package edwards25519
+
+import (
+	"crypto/subtle"
+)
+
+// A dynamic lookup table for variable-base, constant-time scalar muls.
+type projLookupTable struct {
+	points [8]projCached
+}
+
+// A precomputed lookup table for fixed-base, constant-time scalar muls.
+type affineLookupTable struct {
+	points [8]affineCached
+}
+
+// A dynamic lookup table for variable-base, variable-time scalar muls.
+type nafLookupTable5 struct {
+	points [8]projCached
+}
+
+// A precomputed lookup table for fixed-base, variable-time scalar muls.
+type nafLookupTable8 struct {
+	points [64]affineCached
+}
+
+// Constructors.
+
+// Builds a lookup table at runtime. Fast.
+func (v *projLookupTable) FromP3(q *Point) {
+	// Goal: v.points[i] = (i+1)*Q, i.e., Q, 2Q, ..., 8Q
+	// This allows lookup of -8Q, ..., -Q, 0, Q, ..., 8Q
+	v.points[0].FromP3(q)
+	tmpP3 := Point{}
+	tmpP1xP1 := projP1xP1{}
+	for i := 0; i < 7; i++ {
+		// Compute (i+1)*Q as Q + i*Q and convert to a ProjCached
+		// This is needlessly complicated because the API has explicit
+		// receivers instead of creating stack objects and relying on RVO
+		v.points[i+1].FromP3(tmpP3.fromP1xP1(tmpP1xP1.Add(q, &v.points[i])))
+	}
+}
+
+// This is not optimised for speed; fixed-base tables should be precomputed.
+func (v *affineLookupTable) FromP3(q *Point) {
+	// Goal: v.points[i] = (i+1)*Q, i.e., Q, 2Q, ..., 8Q
+	// This allows lookup of -8Q, ..., -Q, 0, Q, ..., 8Q
+	v.points[0].FromP3(q)
+	tmpP3 := Point{}
+	tmpP1xP1 := projP1xP1{}
+	for i := 0; i < 7; i++ {
+		// Compute (i+1)*Q as Q + i*Q and convert to AffineCached
+		v.points[i+1].FromP3(tmpP3.fromP1xP1(tmpP1xP1.AddAffine(q, &v.points[i])))
+	}
+}
+
+// Builds a lookup table at runtime. Fast.
+func (v *nafLookupTable5) FromP3(q *Point) {
+	// Goal: v.points[i] = (2*i+1)*Q, i.e., Q, 3Q, 5Q, ..., 15Q
+	// This allows lookup of -15Q, ..., -3Q, -Q, 0, Q, 3Q, ..., 15Q
+	v.points[0].FromP3(q)
+	q2 := Point{}
+	q2.Add(q, q)
+	tmpP3 := Point{}
+	tmpP1xP1 := projP1xP1{}
+	for i := 0; i < 7; i++ {
+		v.points[i+1].FromP3(tmpP3.fromP1xP1(tmpP1xP1.Add(&q2, &v.points[i])))
+	}
+}
+
+// This is not optimised for speed; fixed-base tables should be precomputed.
+func (v *nafLookupTable8) FromP3(q *Point) {
+	v.points[0].FromP3(q)
+	q2 := Point{}
+	q2.Add(q, q)
+	tmpP3 := Point{}
+	tmpP1xP1 := projP1xP1{}
+	for i := 0; i < 63; i++ {
+		v.points[i+1].FromP3(tmpP3.fromP1xP1(tmpP1xP1.AddAffine(&q2, &v.points[i])))
+	}
+}
+
+// Selectors.
+
+// Set dest to x*Q, where -8 <= x <= 8, in constant time.
+func (v *projLookupTable) SelectInto(dest *projCached, x int8) {
+	// Compute xabs = |x|
+	xmask := x >> 7
+	xabs := uint8((x + xmask) ^ xmask)
+
+	dest.Zero()
+	for j := 1; j <= 8; j++ {
+		// Set dest = j*Q if |x| = j
+		cond := subtle.ConstantTimeByteEq(xabs, uint8(j))
+		dest.Select(&v.points[j-1], dest, cond)
+	}
+	// Now dest = |x|*Q, conditionally negate to get x*Q
+	dest.CondNeg(int(xmask & 1))
+}
+
+// Set dest to x*Q, where -8 <= x <= 8, in constant time.
+func (v *affineLookupTable) SelectInto(dest *affineCached, x int8) {
+	// Compute xabs = |x|
+	xmask := x >> 7
+	xabs := uint8((x + xmask) ^ xmask)
+
+	dest.Zero()
+	for j := 1; j <= 8; j++ {
+		// Set dest = j*Q if |x| = j
+		cond := subtle.ConstantTimeByteEq(xabs, uint8(j))
+		dest.Select(&v.points[j-1], dest, cond)
+	}
+	// Now dest = |x|*Q, conditionally negate to get x*Q
+	dest.CondNeg(int(xmask & 1))
+}
+
+// Given odd x with 0 < x < 2^4, return x*Q (in variable time).
+func (v *nafLookupTable5) SelectInto(dest *projCached, x int8) {
+	*dest = v.points[x/2]
+}
+
+// Given odd x with 0 < x < 2^7, return x*Q (in variable time).
+func (v *nafLookupTable8) SelectInto(dest *affineCached, x int8) {
+	*dest = v.points[x/2]
+}
diff --git a/crypto/edwards25519/tables_test.go b/crypto/edwards25519/tables_test.go
new file mode 100644
index 000000000..b5d161ad4
--- /dev/null
+++ b/crypto/edwards25519/tables_test.go
@@ -0,0 +1,119 @@
+// Copyright (c) 2019 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package edwards25519
+
+import (
+	"testing"
+)
+
+func TestProjLookupTable(t *testing.T) {
+	var table projLookupTable
+	table.FromP3(B)
+
+	var tmp1, tmp2, tmp3 projCached
+	table.SelectInto(&tmp1, 6)
+	table.SelectInto(&tmp2, -2)
+	table.SelectInto(&tmp3, -4)
+	// Expect T1 + T2 + T3 = identity
+
+	var accP1xP1 projP1xP1
+	accP3 := NewIdentityPoint()
+
+	accP1xP1.Add(accP3, &tmp1)
+	accP3.fromP1xP1(&accP1xP1)
+	accP1xP1.Add(accP3, &tmp2)
+	accP3.fromP1xP1(&accP1xP1)
+	accP1xP1.Add(accP3, &tmp3)
+	accP3.fromP1xP1(&accP1xP1)
+
+	if accP3.Equal(I) != 1 {
+		t.Errorf("Consistency check on ProjLookupTable.SelectInto failed!  %x %x %x", tmp1, tmp2, tmp3)
+	}
+}
+
+func TestAffineLookupTable(t *testing.T) {
+	var table affineLookupTable
+	table.FromP3(B)
+
+	var tmp1, tmp2, tmp3 affineCached
+	table.SelectInto(&tmp1, 3)
+	table.SelectInto(&tmp2, -7)
+	table.SelectInto(&tmp3, 4)
+	// Expect T1 + T2 + T3 = identity
+
+	var accP1xP1 projP1xP1
+	accP3 := NewIdentityPoint()
+
+	accP1xP1.AddAffine(accP3, &tmp1)
+	accP3.fromP1xP1(&accP1xP1)
+	accP1xP1.AddAffine(accP3, &tmp2)
+	accP3.fromP1xP1(&accP1xP1)
+	accP1xP1.AddAffine(accP3, &tmp3)
+	accP3.fromP1xP1(&accP1xP1)
+
+	if accP3.Equal(I) != 1 {
+		t.Errorf("Consistency check on ProjLookupTable.SelectInto failed!  %x %x %x", tmp1, tmp2, tmp3)
+	}
+}
+
+func TestNafLookupTable5(t *testing.T) {
+	var table nafLookupTable5
+	table.FromP3(B)
+
+	var tmp1, tmp2, tmp3, tmp4 projCached
+	table.SelectInto(&tmp1, 9)
+	table.SelectInto(&tmp2, 11)
+	table.SelectInto(&tmp3, 7)
+	table.SelectInto(&tmp4, 13)
+	// Expect T1 + T2 = T3 + T4
+
+	var accP1xP1 projP1xP1
+	lhs := NewIdentityPoint()
+	rhs := NewIdentityPoint()
+
+	accP1xP1.Add(lhs, &tmp1)
+	lhs.fromP1xP1(&accP1xP1)
+	accP1xP1.Add(lhs, &tmp2)
+	lhs.fromP1xP1(&accP1xP1)
+
+	accP1xP1.Add(rhs, &tmp3)
+	rhs.fromP1xP1(&accP1xP1)
+	accP1xP1.Add(rhs, &tmp4)
+	rhs.fromP1xP1(&accP1xP1)
+
+	if lhs.Equal(rhs) != 1 {
+		t.Errorf("Consistency check on nafLookupTable5 failed")
+	}
+}
+
+func TestNafLookupTable8(t *testing.T) {
+	var table nafLookupTable8
+	table.FromP3(B)
+
+	var tmp1, tmp2, tmp3, tmp4 affineCached
+	table.SelectInto(&tmp1, 49)
+	table.SelectInto(&tmp2, 11)
+	table.SelectInto(&tmp3, 35)
+	table.SelectInto(&tmp4, 25)
+	// Expect T1 + T2 = T3 + T4
+
+	var accP1xP1 projP1xP1
+	lhs := NewIdentityPoint()
+	rhs := NewIdentityPoint()
+
+	accP1xP1.AddAffine(lhs, &tmp1)
+	lhs.fromP1xP1(&accP1xP1)
+	accP1xP1.AddAffine(lhs, &tmp2)
+	lhs.fromP1xP1(&accP1xP1)
+
+	accP1xP1.AddAffine(rhs, &tmp3)
+	rhs.fromP1xP1(&accP1xP1)
+	accP1xP1.AddAffine(rhs, &tmp4)
+	rhs.fromP1xP1(&accP1xP1)
+
+	if lhs.Equal(rhs) != 1 {
+		t.Errorf("Consistency check on nafLookupTable8 failed")
+	}
+}
diff --git a/go.mod b/go.mod
index f9af9abe0..35a8e980d 100644
--- a/go.mod
+++ b/go.mod
@@ -4,6 +4,7 @@ go 1.17
 
 require (
 	github.com/Azure/azure-sdk-for-go/sdk/storage/azblob v0.3.0
+	github.com/Scratch-net/vxeddsa v0.0.0-20180216190124-07c00d1c9bf7
 	github.com/VictoriaMetrics/fastcache v1.6.0
 	github.com/aws/aws-sdk-go-v2 v1.2.0
 	github.com/aws/aws-sdk-go-v2/config v1.1.1
diff --git a/go.sum b/go.sum
index 8d28443f6..45cce1b5c 100644
--- a/go.sum
+++ b/go.sum
@@ -28,6 +28,8 @@ github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03
 github.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=
 github.com/DATA-DOG/go-sqlmock v1.3.3/go.mod h1:f/Ixk793poVmq4qj/V1dPUg2JEAKC73Q5eFN3EC/SaM=
 github.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=
+github.com/Scratch-net/vxeddsa v0.0.0-20180216190124-07c00d1c9bf7 h1:uIoKcV3dhX/iud2XD82DLKJa7fgoIWTBUnPk8odVMts=
+github.com/Scratch-net/vxeddsa v0.0.0-20180216190124-07c00d1c9bf7/go.mod h1:e/eah4KoWvDvhSSm5bu/LNqR+mwgbr9qt4twvLz0w7s=
 github.com/StackExchange/wmi v0.0.0-20180116203802-5d049714c4a6 h1:fLjPD/aNc3UIOA6tDi6QXUemppXK3P9BI7mr2hd6gx8=
 github.com/StackExchange/wmi v0.0.0-20180116203802-5d049714c4a6/go.mod h1:3eOhrUMpNV+6aFIbp5/iudMxNCF27Vw2OZgy4xEx0Fg=
 github.com/VictoriaMetrics/fastcache v1.6.0 h1:C/3Oi3EiBCqufydp1neRZkqcwmEiuRT9c3fqvvgKm5o=
diff --git a/params/protocol_params.go b/params/protocol_params.go
index 5f154597a..2494f3e26 100644
--- a/params/protocol_params.go
+++ b/params/protocol_params.go
@@ -144,6 +144,13 @@ const (
 	Bn256PairingPerPointGasByzantium uint64 = 80000  // Byzantium per-point price for an elliptic curve pairing check
 	Bn256PairingPerPointGasIstanbul  uint64 = 34000  // Per-point price for an elliptic curve pairing check
 
+	Ed25519AddGas                uint64 = 100
+	Ed25519ScalarMulGas          uint64 = 3000
+	Ed25519HashToPointBaseGas    uint64 = 500
+	Ed25519HashToPointPerWordGas uint64 = 24
+	Bn256HashToPointBaseGas      uint64 = 1000
+	Bn256HashToPointPerWordGas   uint64 = 24
+
 	Bls12381G1AddGas          uint64 = 600    // Price for BLS12-381 elliptic curve G1 point addition
 	Bls12381G1MulGas          uint64 = 12000  // Price for BLS12-381 elliptic curve G1 point scalar multiplication
 	Bls12381G2AddGas          uint64 = 4500   // Price for BLS12-381 elliptic curve G2 point addition
-- 
2.36.1.windows.1

